{"firstLayout":"Start Screen","gdVersion":{"build":213,"major":5,"minor":4,"revision":0},"properties":{"adaptGameResolutionAtRuntime":false,"antialiasingMode":"MSAA","antialisingEnabledOnMobile":false,"folderProject":false,"orientation":"default","packageName":"com.example.gamename","pixelsRounding":false,"projectUuid":"0cd6e0a0-a991-4e04-b6ef-4d3ca430ce91","scaleMode":"linear","sizeOnStartupMode":"adaptHeight","templateSlug":"","useExternalSourceFiles":false,"version":"0.0.9","name":"Alpaca Extraction","description":"You are bean curd. Run.","author":"Earthan Huq","windowWidth":1280,"windowHeight":1280,"latestCompilationDirectory":"","maxFPS":60,"minFPS":20,"verticalSync":false,"platformSpecificAssets":{},"loadingScreen":{"backgroundColor":0,"backgroundFadeInDuration":0.2,"backgroundImageResourceName":"","gdevelopLogoStyle":"light","logoAndProgressFadeInDuration":0.2,"logoAndProgressLogoFadeInDelay":0.2,"minDuration":1.5,"progressBarColor":16777215,"progressBarHeight":20.0,"progressBarMaxWidth":200.0,"progressBarMinWidth":40.0,"progressBarWidthPercent":30.0,"showGDevelopSplash":true,"showProgressBar":true},"watermark":{"placement":"bottom-left","showWatermark":true},"authorIds":["snwl7cwI2Xd9eRKqTjTV6w2bft53"],"authorUsernames":["Yourself (no username)"],"categories":[],"playableDevices":[],"extensionProperties":[],"platforms":[{"name":"GDevelop JS platform"}],"currentPlatform":"GDevelop JS platform"},"resources":{"resources":[{"alwaysLoaded":false,"file":"assets/New3DBox_Front.png","kind":"image","metadata":"{\"extension\":\".png\",\"pskl\":{}}","name":"New3DBox_Front","smoothed":false,"userAdded":true},{"alwaysLoaded":false,"file":"assets/Tofu_Front.png","kind":"image","metadata":"{\"extension\":\".png\",\"pskl\":{}}","name":"Tofu_Texture","smoothed":false,"userAdded":true},{"file":"assets/Alpaca.glb","kind":"model3D","metadata":"","name":"Alpaca.glb","userAdded":false,"origin":{"identifier":"https://asset-resources.gdevelop.io/public-resources/3D Animated Animals/4010952711ac121c345bce36c954ada1866c8cf0ad32e8975d5ff478f2ea6844_Alpaca.glb","name":"Alpaca.glb"}},{"file":"assets/Trex.glb","kind":"model3D","metadata":"","name":"Trex.glb","userAdded":false,"origin":{"identifier":"https://asset-resources.gdevelop.io/public-resources/3D Animated Dinosaurs/3e3bd01d1390a6f4da0e4e284e6225c61107ce1cf2b47abb04e0e1dbeb613c00_Trex.glb","name":"Trex.glb"}},{"alwaysLoaded":false,"file":"assets/tiled_Grass8.png","kind":"image","metadata":"","name":"tiled_Grass8.png","smoothed":false,"userAdded":false,"origin":{"identifier":"https://asset-resources.gdevelop.io/public-resources/Tileable Ground Textures/3e76f78e35eb1f8a1f2dcb97e575c422af3c15c794f1df655ecaec568b1f63d4_tiled_Grass8.png","name":"tiled_Grass8.png"}},{"alwaysLoaded":false,"file":"assets/Medieval Button Beige_Hovered.png","kind":"image","metadata":"","name":"Medieval Button Beige_Hovered.png","smoothed":false,"userAdded":false,"origin":{"identifier":"https://asset-resources.gdevelop.io/public-resources/Menu buttons/6fad8e544ef611861ec9222dd95874cd2b011f1a98a4593372a25801f3236c1c_Medieval Button Beige_Hovered.png","name":"Medieval Button Beige_Hovered.png"}},{"alwaysLoaded":false,"file":"assets/Medieval Button Beige_Idle.png","kind":"image","metadata":"","name":"Medieval Button Beige_Idle.png","smoothed":false,"userAdded":false,"origin":{"identifier":"https://asset-resources.gdevelop.io/public-resources/Menu buttons/7366f06f5fb6f903e0745608c31da98b3d781c9f29af9016636619b32685ec97_Medieval Button Beige_Idle.png","name":"Medieval Button Beige_Idle.png"}},{"alwaysLoaded":false,"file":"assets/Medieval Button Beige_Pressed.png","kind":"image","metadata":"","name":"Medieval Button Beige_Pressed.png","smoothed":false,"userAdded":false,"origin":{"identifier":"https://asset-resources.gdevelop.io/public-resources/Menu buttons/8ca64832a117b91bf3128f96ab66c83c7126c3ffb82909ac01ab1d687137997a_Medieval Button Beige_Pressed.png","name":"Medieval Button Beige_Pressed.png"}},{"file":"assets/CaesarDressing-Regular.ttf","kind":"font","metadata":"","name":"CaesarDressing-Regular.ttf","userAdded":false,"origin":{"identifier":"https://asset-resources.gdevelop.io/public-resources/Menu buttons/f66c77b4a9335111fb8db2dc84354aeb1fc92eb0db7c7302e849c4d421eec02c_CaesarDressing-Regular.ttf","name":"CaesarDressing-Regular.ttf"}},{"alwaysLoaded":false,"file":"assets/Large sign.png","kind":"image","metadata":"","name":"Large sign.png","smoothed":false,"userAdded":false,"origin":{"identifier":"https://asset-resources.gdevelop.io/public-resources/Abstract Platformer Pack (370 assets)/PNG/Other/184caf8844c91aff060202e8af13f21e6a7e2a70f4222518836b3015ce3cfa5b_Large sign.png","name":"Large sign.png"}},{"alwaysLoaded":false,"file":"assets/tiled_Forest Background.png","kind":"image","metadata":"","name":"tiled_Forest Background.png","smoothed":false,"userAdded":false,"origin":{"identifier":"https://asset-resources.gdevelop.io/public-resources/Generic Backgrounds/9c836518da4f93f1a442e4beaa4023bdde907296b1a03f5562a73693fac0f778_tiled_Forest Background.png","name":"tiled_Forest Background.png"}},{"alwaysLoaded":false,"file":"assets/NewSprite.png","kind":"image","metadata":"{\"extension\":\".png\"}","name":"NewSprite","smoothed":false,"userAdded":true},{"file":"assets/Common Tree 5.glb","kind":"model3D","metadata":"","name":"Common Tree 5.glb","userAdded":false,"origin":{"identifier":"https://asset-resources.gdevelop.io/public-resources/3D Rocks and Trees/Plant/5c75e138678c2f1c00a2cfda2b7adfa7582820c09d68b1fc4c2d3f6c81ee2bd8_Common Tree 5.glb","name":"Common Tree 5.glb"}},{"file":"assets/Common Tree 2.glb","kind":"model3D","metadata":"","name":"Common Tree 2.glb","userAdded":false,"origin":{"identifier":"https://asset-resources.gdevelop.io/public-resources/3D Rocks and Trees/Plant/298abe38153e3b0f60b63adf1c4265ffd0264e7bbc28a36e2084dd03b4ae0dea_Common Tree 2.glb","name":"Common Tree 2.glb"}},{"file":"assets/Wood Log.glb","kind":"model3D","metadata":"","name":"Wood Log.glb","userAdded":false,"origin":{"identifier":"https://asset-resources.gdevelop.io/public-resources/3D Rocks and Trees/Plant/03ce0f1351091e22953c2767093ae95871ee32edee3c196afe1fc44fd6fc9907_Wood Log.glb","name":"Wood Log.glb"}},{"file":"assets/Rock 2.glb","kind":"model3D","metadata":"","name":"Rock 2.glb","userAdded":false,"origin":{"identifier":"https://asset-resources.gdevelop.io/public-resources/3D Rocks and Trees/Rock/3b902f48bcc9e815a501479ac88fefddce1d2175564fa1686dc05ea2712d5f07_Rock 2.glb","name":"Rock 2.glb"}},{"file":"assets/Rock 5.glb","kind":"model3D","metadata":"","name":"Rock 5.glb","userAdded":false,"origin":{"identifier":"https://asset-resources.gdevelop.io/public-resources/3D Rocks and Trees/Rock/e960ca1b738a4c8d33deb80927e974614533dac97972f1094bd0b99f2f67d9ea_Rock 5.glb","name":"Rock 5.glb"}},{"alwaysLoaded":false,"file":"assets/NewSprite2.png","kind":"image","metadata":"{\"extension\":\".png\"}","name":"NewSprite2","smoothed":true,"userAdded":true},{"alwaysLoaded":false,"file":"assets/NewTiledSprite.png","kind":"image","metadata":"{\"extension\":\".png\",\"pskl\":{}}","name":"NewTiledSprite","smoothed":true,"userAdded":true},{"alwaysLoaded":false,"file":"assets/NewTiledSprite2.png","kind":"image","metadata":"{\"extension\":\".png\",\"pskl\":{}}","name":"NewTiledSprite2","smoothed":true,"userAdded":true},{"alwaysLoaded":false,"file":"assets/Yellow Button_Hovered.png","kind":"image","metadata":"","name":"Yellow Button_Hovered.png","smoothed":true,"userAdded":false,"origin":{"identifier":"https://asset-resources.gdevelop.io/public-resources/Menu buttons/c1e14acb64b9963341656c997853154dc4c86cd1c46fb12bfbe012d99712ef61_Yellow Button_Hovered.png","name":"Yellow Button_Hovered.png"}},{"alwaysLoaded":false,"file":"assets/Yellow Button_Idle.png","kind":"image","metadata":"","name":"Yellow Button_Idle.png","smoothed":true,"userAdded":false,"origin":{"identifier":"https://asset-resources.gdevelop.io/public-resources/Menu buttons/1cacfd123a1eb708837337c27982f6871f5127c5890dbf0775e0f411958fcbf1_Yellow Button_Idle.png","name":"Yellow Button_Idle.png"}},{"alwaysLoaded":false,"file":"assets/Yellow Button_Pressed.png","kind":"image","metadata":"","name":"Yellow Button_Pressed.png","smoothed":true,"userAdded":false,"origin":{"identifier":"https://asset-resources.gdevelop.io/public-resources/Menu buttons/928c3ea4db1da835c9f8cc5b7089a47228350209d2ff489e1484c31e5ce41b3d_Yellow Button_Pressed.png","name":"Yellow Button_Pressed.png"}},{"file":"assets/Kings-Regular.ttf","kind":"font","metadata":"","name":"406df17d817dc408f30b1c9d5f0557c8316e5be190192c482fdfb58c0659163a_Kings-Regular.ttf","userAdded":true,"origin":{"identifier":"https://asset-resources.gdevelop.io/public-resources/Open Font License/406df17d817dc408f30b1c9d5f0557c8316e5be190192c482fdfb58c0659163a_Kings-Regular.ttf","name":"gdevelop-asset-store"}},{"file":"assets/Roboto-Bold.ttf","kind":"font","metadata":"","name":"3bd40ac788d44626fd640ec67ef04ab0364816b5e8c831f2077bff8805cfe689_Roboto-Bold.ttf","userAdded":true,"origin":{"identifier":"https://asset-resources.gdevelop.io/public-resources/Menu buttons/3bd40ac788d44626fd640ec67ef04ab0364816b5e8c831f2077bff8805cfe689_Roboto-Bold.ttf","name":"gdevelop-asset-store"}}],"resourceFolders":[]},"objects":[{"assetStoreId":"5f90c586d878e13fecd2a3cac659e5c53a80f5f54f2473bd61d81aef212f4258","height":512.0,"name":"Grass8","texture":"tiled_Grass8.png","type":"TiledSpriteObject::TiledSprite","width":512.0,"variables":[],"effects":[{"effectType":"Adjustment","name":"Effect","doubleParameters":{"alpha":1.0,"blue":1.0,"brightness":1.1,"contrast":1.2,"gamma":0.7,"green":0.9,"red":1.5,"saturation":0.75},"stringParameters":{},"booleanParameters":{}}],"behaviors":[{"name":"PlaneProjectionFromTiled","type":"WithThreeJS::PlaneProjectionFromTiled","Id":"","FirstFrame":true,"Hide":false,"AlphaTest":0.0,"AntiAliasing":true,"Blend":"Normal","Rotate90":false,"Depth":0.0,"CastShadow":false,"ReceiveShadow":true,"TextureId":"","OffsetV":2.0247e-320}]},{"assetStoreId":"f72a9e6a0c90ef1c213eb822ad829319845d913cd597270f29be3540c241133c","name":"Alpaca","type":"Scene3D::Model3DObject","variables":[],"effects":[],"behaviors":[{"name":"LightObstacleBehavior","type":"Lighting::LightObstacleBehavior"},{"name":"Pathfinding","type":"PathfindingBehavior::PathfindingBehavior","acceleration":400.0,"allowDiagonals":true,"angleOffset":0.0,"angularMaxSpeed":180.0,"cellHeight":20.0,"cellWidth":20.0,"extraBorder":0.0,"gridOffsetX":0.0,"gridOffsetY":0.0,"maxSpeed":200.0,"rotateObject":true,"smoothingMaxCellGap":1.0}],"content":{"centerLocation":"ModelOrigin","depth":162.0,"height":162.0,"keepAspectRatio":true,"materialType":"StandardWithoutMetalness","modelResourceName":"Alpaca.glb","originLocation":"ModelOrigin","rotationX":90.0,"rotationY":0.0,"rotationZ":90.0,"width":162.0,"animations":[{"loop":true,"name":"Idle","source":"Idle"},{"loop":true,"name":"Walk","source":"Walk"},{"loop":true,"name":"Run","source":"Gallop"},{"loop":false,"name":"Jump","source":"Gallop_Jump"},{"loop":false,"name":"Death","source":"Death"},{"loop":false,"name":"Eating","source":"Eating"},{"loop":true,"name":"Idle2","source":"Idle_2"},{"loop":false,"name":"IdleHitReactLeft","source":"Idle_HitReact_Left"},{"loop":false,"name":"IdleHitReactRight","source":"Idle_HitReact_Right"}]}},{"assetStoreId":"5f75fc241faac48c2e7081c4ad1295faf238b9f5ae75d3e403054813ce1bcb56","name":"Trex","type":"Scene3D::Model3DObject","variables":[],"effects":[],"behaviors":[{"acceleration":400.0,"maxSpeed":300.0,"name":"Pathfinding","type":"PathfindingBehavior::PathfindingBehavior","allowDiagonals":true,"angleOffset":0.0,"angularMaxSpeed":180.0,"cellHeight":20.0,"cellWidth":20.0,"extraBorder":0.0,"gridOffsetX":0.0,"gridOffsetY":0.0,"rotateObject":true,"smoothingMaxCellGap":1.0}],"content":{"centerLocation":"ModelOrigin","depth":152.2499744161529,"height":79.53674696408216,"keepAspectRatio":true,"materialType":"StandardWithoutMetalness","modelResourceName":"Trex.glb","originLocation":"ModelOrigin","rotationX":90.0,"rotationY":0.0,"rotationZ":90.0,"width":310.295692449735,"animations":[{"loop":true,"name":"Idle","source":"TRex_Idle"},{"loop":true,"name":"Walk","source":"TRex_Walk"},{"loop":true,"name":"Run","source":"TRex_Run"},{"loop":false,"name":"Jump","source":"TRex_Jump"},{"loop":false,"name":"Attack","source":"TRex_Attack"},{"loop":false,"name":"Death","source":"TRex_Death"}]}},{"assetStoreId":"","name":"Tofu","type":"Scene3D::Cube3DObject","variables":[],"effects":[],"behaviors":[{"name":"LightObstacleBehavior","type":"Lighting::LightObstacleBehavior"},{"acceleration":1000.0,"allowDiagonals":true,"angleOffset":0,"angularMaxSpeed":180,"cellHeight":20,"cellWidth":20,"extraBorder":0,"gridOffsetX":0,"gridOffsetY":0,"maxSpeed":500.0,"name":"Pathfinding","rotateObject":true,"smoothingMaxCellGap":1,"type":"PathfindingBehavior::PathfindingBehavior"}],"content":{"width":50.0,"height":50.0,"depth":100.0,"enableTextureTransparency":false,"facesOrientation":"Y","frontFaceResourceName":"Tofu_Texture","backFaceResourceName":"","backFaceUpThroughWhichAxisRotation":"X","leftFaceResourceName":"Tofu_Texture","rightFaceResourceName":"Tofu_Texture","topFaceResourceName":"Tofu_Texture","bottomFaceResourceName":"Tofu_Texture","frontFaceVisible":true,"backFaceVisible":false,"leftFaceVisible":true,"rightFaceVisible":true,"topFaceVisible":true,"bottomFaceVisible":true,"frontFaceResourceRepeat":false,"backFaceResourceRepeat":false,"leftFaceResourceRepeat":false,"rightFaceResourceRepeat":false,"topFaceResourceRepeat":false,"bottomFaceResourceRepeat":false,"materialType":"StandardWithoutMetalness"}},{"assetStoreId":"","name":"Tofu2","type":"Scene3D::Cube3DObject","variables":[],"effects":[],"behaviors":[{"name":"LightObstacleBehavior","type":"Lighting::LightObstacleBehavior"},{"name":"Pathfinding","type":"PathfindingBehavior::PathfindingBehavior","acceleration":400.0,"allowDiagonals":true,"angleOffset":0.0,"angularMaxSpeed":180.0,"cellHeight":20.0,"cellWidth":20.0,"extraBorder":0.0,"gridOffsetX":0.0,"gridOffsetY":0.0,"maxSpeed":200.0,"rotateObject":true,"smoothingMaxCellGap":1.0}],"content":{"width":50.0,"height":50.0,"depth":100.0,"enableTextureTransparency":false,"facesOrientation":"Y","frontFaceResourceName":"Tofu_Texture","backFaceResourceName":"","backFaceUpThroughWhichAxisRotation":"X","leftFaceResourceName":"Tofu_Texture","rightFaceResourceName":"Tofu_Texture","topFaceResourceName":"Tofu_Texture","bottomFaceResourceName":"Tofu_Texture","frontFaceVisible":true,"backFaceVisible":false,"leftFaceVisible":true,"rightFaceVisible":true,"topFaceVisible":true,"bottomFaceVisible":true,"frontFaceResourceRepeat":false,"backFaceResourceRepeat":false,"leftFaceResourceRepeat":false,"rightFaceResourceRepeat":false,"topFaceResourceRepeat":false,"bottomFaceResourceRepeat":false,"materialType":"StandardWithoutMetalness"}}],"objectsFolderStructure":{"folderName":"__ROOT","children":[{"objectName":"Grass8"},{"folderName":"Movers","children":[{"objectName":"Alpaca"},{"objectName":"Trex"},{"objectName":"Tofu"},{"objectName":"Tofu2"}]}]},"objectsGroups":[],"variables":[],"layouts":[{"b":31,"disableInputWhenNotFocused":true,"mangledName":"Tofu_32Goes_32to_32Hollywood","name":"Tofu Goes to Hollywood","r":68,"standardSortMethod":true,"stopSoundsOnStartup":true,"title":"","v":56,"uiSettings":{"grid":false,"gridType":"rectangular","gridWidth":32.0,"gridHeight":32.0,"gridOffsetX":0.0,"gridOffsetY":0.0,"gridColor":10401023.0,"gridAlpha":0.8,"snap":false,"zoomFactor":0.4062993355881543,"windowMask":false},"objectsGroups":[{"name":"Food Group","objects":[{"name":"Tofu"},{"name":"Alpaca"}]},{"name":"Movers","objects":[{"name":"Alpaca"},{"name":"Trex"}]},{"name":"Obstacles","objects":[{"name":"CommonTree5"},{"name":"CommonTree2"},{"name":"WoodLog"},{"name":"Rock2"},{"name":"Rock5"}]}],"variables":[],"instances":[{"angle":0.0,"customSize":false,"height":39.0,"keepRatio":true,"layer":"","name":"Tofu","persistentUuid":"720dd60f-3636-40e4-8cec-6b0c6896c233","width":46.0,"x":631.0,"y":1067.0,"zOrder":2,"numberProperties":[],"stringProperties":[],"initialVariables":[]},{"angle":181.0,"customSize":true,"depth":102.94013403359385,"height":24.113405150010679,"keepRatio":true,"layer":"","name":"Alpaca","persistentUuid":"94d0f8a0-dee5-475c-ba0c-ed728ae66fb3","width":81.92003521191404,"x":1089.0,"y":103.0,"zOrder":5,"numberProperties":[],"stringProperties":[],"initialVariables":[]},{"angle":0.0,"customSize":true,"depth":179.72689684680717,"height":93.89093674374762,"keepRatio":true,"layer":"","name":"Trex","persistentUuid":"d84f12a7-c2db-4b4b-840f-67e18f9c34e3","width":366.2955092293626,"x":372.0,"y":143.0,"zOrder":6,"numberProperties":[],"stringProperties":[],"initialVariables":[]},{"angle":0.0,"customSize":true,"depth":1.0,"height":333.0,"keepRatio":true,"layer":"TRex ate Tofu message layer","name":"TRex_ate_Tofu_message","persistentUuid":"1da0c084-cc1a-4d73-b438-66bd37272e3b","width":921.0,"x":180.0,"y":438.0,"zOrder":7,"numberProperties":[],"stringProperties":[],"initialVariables":[]},{"angle":0.0,"customSize":true,"depth":1.0,"height":1320.0,"keepRatio":true,"layer":"Ground Layer","name":"Grass8","persistentUuid":"4d35726a-a532-4b93-b6f4-7c175e05ae8d","width":1316.0,"x":-19.0,"y":-23.0,"zOrder":8,"numberProperties":[],"stringProperties":[],"initialVariables":[]},{"angle":0.0,"customSize":true,"depth":1.0,"height":329.0,"keepRatio":true,"layer":"TRex ate Alpaca message layer","name":"TRex_ate_Alpaca_message","persistentUuid":"9095d998-a2ff-49a6-ab8d-57e5fd0020da","width":973.0,"x":153.0,"y":439.0,"zOrder":9,"numberProperties":[],"stringProperties":[],"initialVariables":[]},{"angle":0.0,"customSize":true,"depth":1.0,"height":306.0,"keepRatio":true,"layer":"Player Escaped message layer","name":"TRex_ate_Alpaca_message2","persistentUuid":"7777eb04-4dad-41d8-9ef4-54813c7ef419","width":934.0,"x":193.0,"y":442.0,"zOrder":10,"numberProperties":[],"stringProperties":[],"initialVariables":[]},{"angle":90.0,"customSize":false,"height":0.0,"keepRatio":true,"layer":"","name":"Light_Source_1","persistentUuid":"bac0f7e0-8207-44f3-a57d-d3d0456a700f","width":0.0,"x":603.0,"y":-150.0,"zOrder":282,"numberProperties":[],"stringProperties":[],"initialVariables":[]},{"angle":0.0,"customSize":false,"height":0.0,"keepRatio":true,"layer":"","name":"Rock5","persistentUuid":"09d55fe5-e960-40be-b75a-8f6fa8e8a9cb","width":0.0,"x":194.0,"y":412.0,"zOrder":283,"numberProperties":[],"stringProperties":[],"initialVariables":[]},{"angle":59.0,"customSize":true,"depth":58.0,"height":109.0,"keepRatio":true,"layer":"","name":"Rock2","persistentUuid":"39b65617-36f7-473d-98ec-08126a32bb61","width":124.0,"x":730.0,"y":266.0,"zOrder":284,"numberProperties":[],"stringProperties":[],"initialVariables":[]},{"angle":17.0,"customSize":false,"height":0.0,"keepRatio":true,"layer":"","name":"WoodLog","persistentUuid":"1879f36e-8382-42c8-a82f-76b8fe7967d2","width":0.0,"x":1024.0,"y":384.0,"zOrder":285,"numberProperties":[],"stringProperties":[],"initialVariables":[]},{"angle":0.0,"customSize":true,"depth":281.0,"height":180.0,"keepRatio":true,"layer":"","name":"CommonTree2","persistentUuid":"cb84a0f9-c388-4c7e-a9a9-023b57ea19e2","width":220.0,"x":353.0,"y":820.0,"zOrder":286,"numberProperties":[],"stringProperties":[],"initialVariables":[]},{"angle":0.0,"customSize":true,"depth":227.0,"height":145.0,"keepRatio":true,"layer":"","name":"CommonTree5","persistentUuid":"5b5174f3-da57-4e17-b16a-acd649c42712","width":187.0,"x":680.0,"y":645.0,"zOrder":287,"numberProperties":[],"stringProperties":[],"initialVariables":[]},{"angle":0.0,"customSize":false,"height":0.0,"keepRatio":true,"layer":"Cursor Layer","name":"Cursor","persistentUuid":"70b27fbb-4d27-44e0-b1bb-1a7098fb0bb6","width":0.0,"x":616.0,"y":806.0,"zOrder":-473,"numberProperties":[],"stringProperties":[],"initialVariables":[]}],"objects":[{"assetStoreId":"","bold":false,"italic":false,"name":"TRex_ate_Tofu_message","smoothed":true,"type":"TextObject::Text","underlined":false,"variables":[],"effects":[],"behaviors":[],"string":"The Tyrannosaurus Rex has eaten the Tofu!\nShe's very unhappy :(","font":"CaesarDressing-Regular.ttf","textAlignment":"center","characterSize":90.0,"color":{"b":7,"g":79,"r":122},"content":{"bold":false,"isOutlineEnabled":true,"isShadowEnabled":false,"italic":false,"outlineColor":"56;37;1","outlineThickness":5.0,"shadowAngle":90.0,"shadowBlurRadius":2.0,"shadowColor":"0;0;0","shadowDistance":4.0,"shadowOpacity":127.0,"smoothed":true,"underlined":false,"text":"The Tyrannosaurus Rex has eaten the Tofu!\nShe's very unhappy :(","font":"CaesarDressing-Regular.ttf","textAlignment":"center","characterSize":90.0,"color":"122;79;7"}},{"assetStoreId":"","bold":false,"italic":false,"name":"TRex_ate_Alpaca_message","smoothed":true,"type":"TextObject::Text","underlined":false,"variables":[],"effects":[],"behaviors":[],"string":"The Tyrannosaurus Rex has eaten the alpaca!\nYou can't escape!","font":"CaesarDressing-Regular.ttf","textAlignment":"center","characterSize":90.0,"color":{"b":7,"g":79,"r":122},"content":{"bold":false,"isOutlineEnabled":true,"isShadowEnabled":false,"italic":false,"outlineColor":"56;37;1","outlineThickness":5.0,"shadowAngle":90.0,"shadowBlurRadius":2.0,"shadowColor":"0;0;0","shadowDistance":4.0,"shadowOpacity":127.0,"smoothed":true,"underlined":false,"text":"The Tyrannosaurus Rex has eaten the alpaca!\nYou can't escape!","font":"CaesarDressing-Regular.ttf","textAlignment":"center","characterSize":90.0,"color":"122;79;7"}},{"assetStoreId":"","bold":false,"italic":false,"name":"TRex_ate_Alpaca_message2","smoothed":true,"type":"TextObject::Text","underlined":false,"variables":[],"effects":[],"behaviors":[],"string":"The Tofu escaped on the brave and courageous Alpaca!","font":"CaesarDressing-Regular.ttf","textAlignment":"center","characterSize":90.0,"color":{"b":7,"g":79,"r":122},"content":{"bold":false,"isOutlineEnabled":true,"isShadowEnabled":false,"italic":false,"outlineColor":"56;37;1","outlineThickness":5.0,"shadowAngle":90.0,"shadowBlurRadius":2.0,"shadowColor":"0;0;0","shadowDistance":4.0,"shadowOpacity":127.0,"smoothed":true,"underlined":false,"text":"The Tofu escaped on the brave and courageous Alpaca!","font":"CaesarDressing-Regular.ttf","textAlignment":"center","characterSize":90.0,"color":"122;79;7"}},{"adaptCollisionMaskAutomatically":false,"assetStoreId":"","name":"Light_Source_1","type":"Sprite","updateIfNotVisible":false,"variables":[],"effects":[],"behaviors":[{"name":"LinkedLight","type":"WithThreeJS::LinkedLight","Id":"","FirstFrame":true,"Hide":true,"Type":"Directional Light","Color":"255;255;255","Intensity":1.0,"Distance":0.0,"SpotAngle":20.0,"SpotPenumbra":0.5,"Tilt":0.0,"CastShadow":true,"ShadowMapSize":"512px","ShadowRange":256.0,"ShadowDepthBias":0.002,"ShadowNormalBias":2.0,"LightHelper":true,"ShadowHelper":true}],"animations":[{"name":"NewSprite","useMultipleDirections":false,"directions":[{"looping":false,"metadata":"{\"pskl\":{}}","timeBetweenFrames":0.08,"sprites":[{"hasCustomCollisionMask":false,"image":"NewSprite","points":[],"originPoint":{"name":"origine","x":0.0,"y":0.0},"centerPoint":{"automatic":true,"name":"centre","x":0.0,"y":0.0},"customCollisionMask":[]}]}]}]},{"assetStoreId":"7004186b6fb5b63622ef1c76442a0e6223d511f8796dc79bbeb435d6d1ace38e","name":"CommonTree5","type":"Scene3D::Model3DObject","variables":[],"effects":[],"behaviors":[{"name":"PathfindingObstacle","type":"PathfindingBehavior::PathfindingObstacleBehavior","cost":2.0,"impassable":true}],"content":{"centerLocation":"ModelOrigin","depth":227.0,"height":227.0,"keepAspectRatio":true,"materialType":"StandardWithoutMetalness","modelResourceName":"Common Tree 5.glb","originLocation":"ModelOrigin","rotationX":90.0,"rotationY":0.0,"rotationZ":-90.0,"width":227.0,"animations":[]}},{"assetStoreId":"5bf9531e362ac2e17d0515c4f355bff376216522e5a39dd3705fc96cf02d1505","name":"CommonTree2","type":"Scene3D::Model3DObject","variables":[],"effects":[],"behaviors":[{"name":"PathfindingObstacle","type":"PathfindingBehavior::PathfindingObstacleBehavior","cost":2.0,"impassable":true}],"content":{"centerLocation":"ModelOrigin","depth":281.0,"height":281.0,"keepAspectRatio":true,"materialType":"StandardWithoutMetalness","modelResourceName":"Common Tree 2.glb","originLocation":"ModelOrigin","rotationX":90.0,"rotationY":0.0,"rotationZ":-90.0,"width":281.0,"animations":[]}},{"assetStoreId":"0ec908368e05a9f0c589fe1774a4c35c8d6866282bb8f6adeeb6a13ff7f4bc25","name":"WoodLog","type":"Scene3D::Model3DObject","variables":[],"effects":[],"behaviors":[{"name":"PathfindingObstacle","type":"PathfindingBehavior::PathfindingObstacleBehavior","cost":2.0,"impassable":true}],"content":{"centerLocation":"ModelOrigin","depth":240.0,"height":240.0,"keepAspectRatio":true,"materialType":"StandardWithoutMetalness","modelResourceName":"Wood Log.glb","originLocation":"ModelOrigin","rotationX":90.0,"rotationY":0.0,"rotationZ":-90.0,"width":240.0,"animations":[]}},{"assetStoreId":"685b99b5a69e23be1b31bc1bd919e6138fedafd8e38f74eeeac99e4494b2d5b4","name":"Rock2","type":"Scene3D::Model3DObject","variables":[],"effects":[],"behaviors":[{"name":"PathfindingObstacle","type":"PathfindingBehavior::PathfindingObstacleBehavior","cost":2.0,"impassable":true}],"content":{"centerLocation":"ModelOrigin","depth":58.0,"height":58.0,"keepAspectRatio":true,"materialType":"StandardWithoutMetalness","modelResourceName":"Rock 2.glb","originLocation":"ModelOrigin","rotationX":90.0,"rotationY":0.0,"rotationZ":-90.0,"width":58.0,"animations":[]}},{"assetStoreId":"2716608248700f3593088ac1f416bfaca79cecd8ca3e8a5aafadea831d45edec","name":"Rock5","type":"Scene3D::Model3DObject","variables":[],"effects":[],"behaviors":[{"bottomEdgeAnchor":0,"leftEdgeAnchor":0,"name":"Anchor","relativeToOriginalWindowSize":true,"rightEdgeAnchor":0,"topEdgeAnchor":0,"type":"AnchorBehavior::AnchorBehavior","useLegacyBottomAndRightAnchors":false},{"cost":2,"impassable":true,"name":"PathfindingObstacle","type":"PathfindingBehavior::PathfindingObstacleBehavior"}],"content":{"centerLocation":"ModelOrigin","depth":82.0,"height":82.0,"keepAspectRatio":true,"materialType":"StandardWithoutMetalness","modelResourceName":"Rock 5.glb","originLocation":"ModelOrigin","rotationX":90.0,"rotationY":0.0,"rotationZ":-90.0,"width":82.0,"animations":[]}},{"assetStoreId":"","name":"Enable_WithThreeJS","type":"WithThreeJS::EnableWithThreeJS","variables":[],"effects":[],"behaviors":[],"content":{},"childrenContent":{}},{"adaptCollisionMaskAutomatically":true,"assetStoreId":"","name":"Cursor","type":"Sprite","updateIfNotVisible":false,"variables":[],"effects":[{"effectType":"Adjustment","name":"Effect","doubleParameters":{"alpha":1.0,"blue":1.0,"brightness":1.0,"contrast":1.0,"gamma":1.0,"green":1.0,"red":1.0,"saturation":2.0},"stringParameters":{},"booleanParameters":{}}],"behaviors":[{"name":"cursor","type":"MouseHelper::cursor"}],"animations":[{"name":"NewSprite","useMultipleDirections":false,"directions":[{"looping":false,"metadata":"{\"pskl\":{\"data\":\"{\\\"modelVersion\\\":2,\\\"piskel\\\":{\\\"name\\\":\\\"New Animation\\\",\\\"description\\\":\\\"\\\",\\\"fps\\\":12,\\\"height\\\":64,\\\"width\\\":64,\\\"layers\\\":[\\\"{\\\\\\\"name\\\\\\\":\\\\\\\"outer\\\\\\\",\\\\\\\"opacity\\\\\\\":1,\\\\\\\"frameCount\\\\\\\":1,\\\\\\\"chunks\\\\\\\":[{\\\\\\\"layout\\\\\\\":[[0]],\\\\\\\"base64PNG\\\\\\\":\\\\\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAAAXNSR0IArs4c6QAAAgxJREFUeF7tmU1ywjAMhcm+x+j9T8QxuqcDQzIeI+tftlqLLcGSvvck2+G4bf45Nq//VgDKAZsTqBbY3AA1BKsFqgU2J1AtsLkB5u4Cj/vXgwP8+P6Z5szwQNyiR2CiYYQBsBbeA4kCEQLAu/gTRgQEVwCcwqkiPNbgzJkLquRh7Fkscaro0boRa360lgeAUaJQ4ZTCkt9owbY1u7QAVFSfHFU4NfQ4MTRimgFQifXfU6phz1OxpgOgEmq/pwrvkx/9loophWByAFctafFnEVwI2vWfcdQAMCUsynOc4OkCNwCtCmeCFmVaENB60tkyPGpLeway58tK7wuMd/F9vD6O9ZSocgDH/l7qcwG0IkhEdQEQrT4XggZ6AZDYZVX/lwPeBPoB67ETVAtUCygIjKwXdQZIPwMyHISmngOewWa7IGIAul6Gtr8LQG2gtSV0ERqtv+QuQB2I+hbRHFGxNTz2/wucYhO4fkLdyy3vBbgvQ6wuUx2ERhaF7ChVi/uWyWp9FweMWgFS5d++FYa2REwdCsSf/F8Ag2DpUQyWdrD2M888A6h58BGQ+O+fcogFKDTwXQFgM8Gy23gNvGkAqJbQwPCyfGgLQIVxLI0BiSrcdRvkKsqFEV10m2/IDOACyfBcAcigwsocygEr6WeIXQ7IoMLKHMoBK+lniF0OyKDCyhzKASvpZ4i9vQN+ASlnwFBQ8fCnAAAAAElFTkSuQmCC\\\\\\\"}]}\\\",\\\"{\\\\\\\"name\\\\\\\":\\\\\\\"middle\\\\\\\",\\\\\\\"opacity\\\\\\\":1,\\\\\\\"frameCount\\\\\\\":1,\\\\\\\"chunks\\\\\\\":[{\\\\\\\"layout\\\\\\\":[[0]],\\\\\\\"base64PNG\\\\\\\":\\\\\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAAAXNSR0IArs4c6QAAANVJREFUeF7tlbENgDAQxEjPGOw/EWPQg9IhBC0+6UxJcx+/LxlL+TfKz78IQAPKCViBcgG8BK2AFSgnYAXKBfAVsAJWoJyAFSgXwFfACliBcgJWoFwAXwErYAXKCWAVOPf1vLMf24HMgoTOwz8P/PbvDzkF8AflZ4YGtFdgGlF9CRK1+8pELkEBBBHQgKBlIKNoAII9KFQDgpaBjKIBCPagUA0IWgYyigYg2INCNSBoGcgoGoBgDwrVgKBlIKNoAII9KFQDgpaBjKIBCPagUA0IWgYyygWdoyhBz5PvFQAAAABJRU5ErkJggg==\\\\\\\"}]}\\\"],\\\"hiddenFrames\\\":[\\\"\\\"]}}\",\"resourceNames\":[\"NewSprite2\"],\"name\":\"NewSprite\"}}","timeBetweenFrames":0.08,"sprites":[{"hasCustomCollisionMask":true,"image":"NewSprite2","points":[],"originPoint":{"name":"origine","x":0.0,"y":0.0},"centerPoint":{"automatic":true,"name":"centre","x":0.0,"y":0.0},"customCollisionMask":[[{"x":13.0,"y":13.0},{"x":51.0,"y":13.0},{"x":51.0,"y":50.0},{"x":13.0,"y":50.0}]]}]}]}]}],"objectsFolderStructure":{"folderName":"__ROOT","children":[{"objectName":"TRex_ate_Tofu_message"},{"objectName":"TRex_ate_Alpaca_message"},{"objectName":"TRex_ate_Alpaca_message2"},{"objectName":"Light_Source_1"},{"folderName":"Obstacles","children":[{"objectName":"Rock5"},{"objectName":"Rock2"},{"objectName":"WoodLog"},{"objectName":"CommonTree2"},{"objectName":"CommonTree5"}]},{"objectName":"Enable_WithThreeJS"},{"objectName":"Cursor"}]},"events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"DepartScene"},"parameters":[""]}],"actions":[{"type":{"value":"SetWindowSize"},"parameters":["","ScreenHeight()","ScreenHeight()",""]},{"type":{"value":"CacheSouris"},"parameters":["Tofu"]}]},{"type":"BuiltinCommonInstructions::Comment","color":{"b":109,"g":230,"r":255,"textB":0,"textG":0,"textR":0},"comment":"T-Rex & Alpaca move towards Tofu, Tofu moves towards mouse cursor."},{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"PathfindingBehavior::SetDestination"},"parameters":["Trex","Pathfinding","","Tofu.X()","Tofu.Y()"]},{"type":{"value":"PathfindingBehavior::SetDestination"},"parameters":["Alpaca","Pathfinding","","Tofu.X()","Tofu.Y()"]},{"type":{"value":"PathfindingBehavior::SetDestination"},"parameters":["Tofu","Pathfinding","","Cursor.X()","Cursor.Y()"]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"PathfindingBehavior::Speed"},"parameters":["Movers","Pathfinding","=","0"]}],"actions":[{"type":{"value":"AnimatableCapability::AnimatableBehavior::SetName"},"parameters":["Movers","Animation","=","\"Idle\""]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"PathfindingBehavior::Speed"},"parameters":["Trex","Pathfinding",">","0"]}],"actions":[{"type":{"value":"AnimatableCapability::AnimatableBehavior::SetName"},"parameters":["Trex","Animation","=","\"Run\""]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"PathfindingBehavior::Speed"},"parameters":["Alpaca","Pathfinding",">","0"]}],"actions":[{"type":{"value":"AnimatableCapability::AnimatableBehavior::SetName"},"parameters":["Alpaca","Animation","=","\"Run\""]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"CollisionNP"},"parameters":["Trex","Alpaca","","",""]}],"actions":[{"type":{"value":"Delete"},"parameters":["Alpaca",""]}],"events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"SceneInstancesCount"},"parameters":["","Tofu",">","0"]}],"actions":[{"type":{"value":"ShowLayer"},"parameters":["","\"TRex ate Alpaca message layer\""]}]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"CollisionNP"},"parameters":["Trex","Tofu","","",""]}],"actions":[{"type":{"value":"HideLayer"},"parameters":["","\"TRex ate Alpaca message layer\""]},{"type":{"value":"Delete"},"parameters":["Tofu",""]},{"type":{"value":"ShowLayer"},"parameters":["","\"TRex ate Tofu message layer\""]}]},{"type":"BuiltinCommonInstructions::Comment","color":{"b":109,"g":230,"r":255,"textB":0,"textG":0,"textR":0},"comment":"Operant Tofu is Died."},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"SceneInstancesCount"},"parameters":["","Tofu","<","1"]}],"actions":[{"type":{"value":"PathfindingBehavior::SetDestination"},"parameters":["Trex","Pathfinding","=","Alpaca.X()","Alpaca.Y()"]},{"type":{"value":"PathfindingBehavior::SetDestination"},"parameters":["Alpaca","Pathfinding","=","Trex.X()","Trex.Y()"]},{"type":{"value":"PathfindingBehavior::Speed"},"parameters":["Alpaca","Pathfinding","=","-200"]},{"type":{"value":"MontreSouris"},"parameters":["Tofu"]}],"events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"SceneInstancesCount"},"parameters":["","Alpaca","<","1"]}],"actions":[{"type":{"value":"PathfindingBehavior::SetDestination"},"parameters":["Trex","Pathfinding","=","Trex.X()","Trex.Y()"]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"Wait"},"parameters":["2.3"]},{"type":{"value":"Scene"},"parameters":["","\"Start Screen\"","yes"]}]}]},{"type":"BuiltinCommonInstructions::Comment","color":{"b":109,"g":230,"r":255,"textB":0,"textG":0,"textR":0},"comment":"The player wins:"},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"CollisionNP"},"parameters":["Alpaca","Tofu","","",""]}],"actions":[{"type":{"value":"Scene"},"parameters":["","\"Victory\"",""]}]}],"layers":[{"ambientLightColorB":200,"ambientLightColorG":200,"ambientLightColorR":200,"camera3DFarPlaneDistance":10000.0,"camera3DFieldOfView":45.0,"camera3DNearPlaneDistance":3.0,"cameraType":"perspective","followBaseLayerCamera":false,"isLightingLayer":false,"isLocked":true,"name":"Ground Layer","renderingType":"","visibility":true,"cameras":[],"effects":[]},{"ambientLightColorB":200,"ambientLightColorG":200,"ambientLightColorR":200,"camera3DFarPlaneDistance":1000.0,"camera3DFieldOfView":70.0,"camera3DNearPlaneDistance":0.1,"cameraType":"perspective","followBaseLayerCamera":false,"isLightingLayer":false,"isLocked":false,"name":"","renderingType":"","visibility":true,"cameras":[{"defaultSize":true,"defaultViewport":true,"height":0.0,"viewportBottom":1.0,"viewportLeft":0.0,"viewportRight":1.0,"viewportTop":0.0,"width":0.0}],"effects":[{"effectType":"Scene3D::HemisphereLight","name":"Light 1","doubleParameters":{"elevation":90.0,"intensity":0.5,"rotation":0.0},"stringParameters":{"groundColor":"112;102;82","skyColor":"247;245;206","top":"Z+"},"booleanParameters":{}},{"effectType":"Scene3D::DirectionalLight","name":"Effect","doubleParameters":{"elevation":45.0,"intensity":0.5,"rotation":0.0},"stringParameters":{"color":"255;255;255","top":"Y-"},"booleanParameters":{}}]},{"ambientLightColorB":200,"ambientLightColorG":200,"ambientLightColorR":200,"camera3DFarPlaneDistance":10000.0,"camera3DFieldOfView":45.0,"camera3DNearPlaneDistance":3.0,"cameraType":"","followBaseLayerCamera":false,"isLightingLayer":false,"isLocked":false,"name":"TRex ate Tofu message layer","renderingType":"","visibility":false,"cameras":[],"effects":[]},{"ambientLightColorB":200,"ambientLightColorG":200,"ambientLightColorR":200,"camera3DFarPlaneDistance":10000.0,"camera3DFieldOfView":45.0,"camera3DNearPlaneDistance":3.0,"cameraType":"","followBaseLayerCamera":false,"isLightingLayer":false,"isLocked":false,"name":"TRex ate Alpaca message layer","renderingType":"","visibility":false,"cameras":[],"effects":[]},{"ambientLightColorB":200,"ambientLightColorG":200,"ambientLightColorR":200,"camera3DFarPlaneDistance":10000.0,"camera3DFieldOfView":45.0,"camera3DNearPlaneDistance":3.0,"cameraType":"","followBaseLayerCamera":false,"isLightingLayer":false,"isLocked":false,"name":"Player Escaped message layer","renderingType":"","visibility":false,"cameras":[],"effects":[]},{"ambientLightColorB":200,"ambientLightColorG":200,"ambientLightColorR":200,"camera3DFarPlaneDistance":10000.0,"camera3DFieldOfView":45.0,"camera3DNearPlaneDistance":3.0,"cameraType":"","followBaseLayerCamera":false,"isLightingLayer":false,"isLocked":false,"name":"Cursor Layer","renderingType":"","visibility":true,"cameras":[],"effects":[{"effectType":"Scene3D::HemisphereLight","name":"3D Light","doubleParameters":{"elevation":45.0,"intensity":1.0,"rotation":0.0},"stringParameters":{"groundColor":"64;64;64","skyColor":"255;255;255","top":"Y-"},"booleanParameters":{}}]}],"behaviorsSharedData":[{"name":"Anchor","type":"AnchorBehavior::AnchorBehavior"},{"name":"Animation","type":"AnimatableCapability::AnimatableBehavior"},{"name":"Effect","type":"EffectCapability::EffectBehavior"},{"name":"Flippable","type":"FlippableCapability::FlippableBehavior"},{"name":"LightObstacleBehavior","type":"Lighting::LightObstacleBehavior"},{"name":"LinkedLight","type":"WithThreeJS::LinkedLight"},{"name":"Object3D","type":"Scene3D::Base3DBehavior"},{"name":"Opacity","type":"OpacityCapability::OpacityBehavior"},{"name":"Pathfinding","type":"PathfindingBehavior::PathfindingBehavior"},{"name":"PathfindingObstacle","type":"PathfindingBehavior::PathfindingObstacleBehavior"},{"name":"PlaneProjectionFromTiled","type":"WithThreeJS::PlaneProjectionFromTiled"},{"name":"Resizable","type":"ResizableCapability::ResizableBehavior"},{"name":"Scale","type":"ScalableCapability::ScalableBehavior"},{"name":"Text","type":"TextContainerCapability::TextContainerBehavior"},{"name":"cursor","type":"MouseHelper::cursor"}]},{"b":31,"disableInputWhenNotFocused":true,"mangledName":"Start_32Screen","name":"Start Screen","r":68,"standardSortMethod":true,"stopSoundsOnStartup":true,"title":"","v":56,"uiSettings":{"grid":false,"gridType":"rectangular","gridWidth":32.0,"gridHeight":32.0,"gridOffsetX":0.0,"gridOffsetY":0.0,"gridColor":10401023.0,"gridAlpha":0.8,"snap":false,"zoomFactor":0.3822181710324154,"windowMask":false},"objectsGroups":[],"variables":[],"instances":[{"angle":0.0,"customSize":true,"depth":48.0,"height":114.0,"keepRatio":true,"layer":"","name":"Start_Button","persistentUuid":"9a63482f-0708-471e-908c-26bec51c2cdc","width":341.0,"x":484.0,"y":1063.0,"zOrder":5,"numberProperties":[],"stringProperties":[],"initialVariables":[]},{"angle":0.0,"customSize":true,"depth":1.0,"height":1315.0,"keepRatio":true,"layer":"","name":"Grass8","persistentUuid":"a7513888-33af-4888-abb7-6c0f50bcae3f","width":1318.0,"x":-21.0,"y":-18.0,"zOrder":0,"numberProperties":[],"stringProperties":[],"initialVariables":[]},{"angle":0.0,"customSize":true,"depth":1.0,"height":676.0,"keepRatio":true,"layer":"","name":"LargeSign","persistentUuid":"6f1735c1-c7f7-4937-90ca-55309bc460f2","width":1024.0,"x":134.0,"y":621.0,"zOrder":2,"numberProperties":[],"stringProperties":[],"initialVariables":[]},{"angle":0.0,"customSize":true,"depth":1.0,"height":454.0,"keepRatio":true,"layer":"","name":"Game_Explanation","persistentUuid":"d7550314-2709-438d-9a47-5e6dd9675037","width":940.0,"x":187.0,"y":711.0,"zOrder":6,"numberProperties":[],"stringProperties":[],"initialVariables":[]},{"angle":0.0,"customSize":false,"height":0.0,"keepRatio":true,"layer":"","name":"Side_Note","persistentUuid":"f9da268a-3360-46ff-8bb7-28a041f83967","width":0.0,"x":474.0,"y":833.0,"zOrder":7,"numberProperties":[],"stringProperties":[],"initialVariables":[]},{"angle":0.0,"customSize":false,"height":0.0,"keepRatio":true,"layer":"","name":"Side_Note2","persistentUuid":"5e0f5626-e3e1-4188-80e2-c58387a72336","width":0.0,"x":571.0,"y":1011.0,"zOrder":8,"numberProperties":[],"stringProperties":[],"initialVariables":[]},{"angle":0.0,"customSize":false,"height":0.0,"keepRatio":true,"layer":"","name":"Trex","persistentUuid":"df2fd11b-a7ea-4b45-9892-a9cb8eb4cd5c","rotationX":90.0,"width":0.0,"x":397.0,"y":404.0,"z":82.0,"zOrder":9,"numberProperties":[],"stringProperties":[],"initialVariables":[]},{"angle":0.0,"customSize":false,"flippedX":true,"height":0.0,"keepRatio":true,"layer":"","name":"Alpaca","persistentUuid":"63559c46-405b-465e-a5a9-ccc98a50c6d4","rotationX":90.0,"width":0.0,"x":924.0,"y":426.0,"z":82.0,"zOrder":10,"numberProperties":[],"stringProperties":[],"initialVariables":[]}],"objects":[{"assetStoreId":"1cacfe2713f10642e8079542f28282d52f1bf46ae2dc27dc6c291a2970c90971","name":"Start_Button","type":"PanelSpriteButton::PanelSpriteButton","variables":[],"effects":[],"behaviors":[{"name":"ButtonFSM","type":"ButtonStates::ButtonFSM","ShouldCheckHovering":true,"State":"Idle","TouchId":0.0,"TouchIsInside":false,"MouseIsInside":false,"Index":2.0247e-320}],"content":{"LeftPadding":0.0,"RightPadding":0.0,"PressedLabelOffsetY":4.0,"BottomPadding":10.0,"TopPadding":0.0,"HoveredFadeOutDuration":0.2},"childrenContent":{"Hovered":{"bottomMargin":11.0,"height":64.0,"leftMargin":7.0,"rightMargin":7.0,"texture":"Medieval Button Beige_Hovered.png","tiled":true,"topMargin":7.0,"width":192.0},"Idle":{"bottomMargin":11.0,"height":64.0,"leftMargin":7.0,"rightMargin":7.0,"texture":"Medieval Button Beige_Idle.png","tiled":true,"topMargin":7.0,"width":192.0},"Label":{"bold":false,"italic":false,"smoothed":true,"underlined":false,"string":"Run, Tofu!","font":"CaesarDressing-Regular.ttf","textAlignment":"center","characterSize":40.0,"color":{"b":64,"g":99,"r":133},"content":{"bold":false,"isOutlineEnabled":false,"isShadowEnabled":false,"italic":false,"outlineColor":"255;255;255","outlineThickness":2.0,"shadowAngle":90.0,"shadowBlurRadius":2.0,"shadowColor":"0;0;0","shadowDistance":4.0,"shadowOpacity":127.0,"smoothed":true,"underlined":false,"text":"Run, Tofu!","font":"CaesarDressing-Regular.ttf","textAlignment":"center","characterSize":40.0,"color":"133;99;64"}},"Pressed":{"bottomMargin":7.0,"height":64.0,"leftMargin":7.0,"rightMargin":7.0,"texture":"Medieval Button Beige_Pressed.png","tiled":true,"topMargin":11.0,"width":192.0}}},{"adaptCollisionMaskAutomatically":true,"assetStoreId":"39d02c8d833898dd906c948e8403596aba1fdcfa223f374b260aa5b0ae70b776","name":"LargeSign","type":"Sprite","updateIfNotVisible":false,"variables":[],"effects":[],"behaviors":[],"animations":[{"name":"","useMultipleDirections":false,"directions":[{"looping":true,"timeBetweenFrames":0.025,"sprites":[{"hasCustomCollisionMask":true,"image":"Large sign.png","points":[],"originPoint":{"name":"origine","x":0.0,"y":0.0},"centerPoint":{"automatic":true,"name":"centre","x":0.0,"y":0.0},"customCollisionMask":[[{"x":0.0,"y":0.0},{"x":64.0,"y":0.0},{"x":64.0,"y":55.0},{"x":0.0,"y":55.0}]]}]}]}]},{"assetStoreId":"","bold":false,"italic":false,"name":"Game_Explanation","smoothed":true,"type":"TextObject::Text","underlined":false,"variables":[],"effects":[],"behaviors":[],"string":"The T-Rex is starving! She'll eat anything, even tofu!\n\nReach your loyal, brave \nalpaca to escape!","font":"CaesarDressing-Regular.ttf","textAlignment":"center","characterSize":60.0,"color":{"b":0,"g":0,"r":0},"content":{"bold":false,"isOutlineEnabled":false,"isShadowEnabled":false,"italic":false,"outlineColor":"255;255;255","outlineThickness":2.0,"shadowAngle":90.0,"shadowBlurRadius":2.0,"shadowColor":"0;0;0","shadowDistance":4.0,"shadowOpacity":127.0,"smoothed":true,"underlined":false,"text":"The T-Rex is starving! She'll eat anything, even tofu!\n\nReach your loyal, brave \nalpaca to escape!","font":"CaesarDressing-Regular.ttf","textAlignment":"center","characterSize":60.0,"color":"0;0;0"}},{"assetStoreId":"","bold":false,"italic":false,"name":"Side_Note","smoothed":true,"type":"TextObject::Text","underlined":false,"variables":[],"effects":[],"behaviors":[],"string":"(even though she won't like it)","font":"CaesarDressing-Regular.ttf","textAlignment":"center","characterSize":30.0,"color":{"b":19,"g":39,"r":63},"content":{"bold":false,"isOutlineEnabled":false,"isShadowEnabled":false,"italic":false,"outlineColor":"255;255;255","outlineThickness":2.0,"shadowAngle":90.0,"shadowBlurRadius":2.0,"shadowColor":"0;0;0","shadowDistance":4.0,"shadowOpacity":127.0,"smoothed":true,"underlined":false,"text":"(even though she won't like it)","font":"CaesarDressing-Regular.ttf","textAlignment":"center","characterSize":30.0,"color":"63;39;19"}},{"assetStoreId":"","bold":false,"italic":false,"name":"Side_Note2","smoothed":true,"type":"TextObject::Text","underlined":false,"variables":[],"effects":[],"behaviors":[],"string":"(you're Tofu)","font":"CaesarDressing-Regular.ttf","textAlignment":"center","characterSize":30.0,"color":{"b":19,"g":39,"r":63},"content":{"bold":false,"isOutlineEnabled":false,"isShadowEnabled":false,"italic":false,"outlineColor":"255;255;255","outlineThickness":2.0,"shadowAngle":90.0,"shadowBlurRadius":2.0,"shadowColor":"0;0;0","shadowDistance":4.0,"shadowOpacity":127.0,"smoothed":true,"underlined":false,"text":"(you're Tofu)","font":"CaesarDressing-Regular.ttf","textAlignment":"center","characterSize":30.0,"color":"63;39;19"}}],"objectsFolderStructure":{"folderName":"__ROOT","children":[{"objectName":"Start_Button"},{"objectName":"LargeSign"},{"objectName":"Game_Explanation"},{"objectName":"Side_Note"},{"objectName":"Side_Note2"}]},"events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"DepartScene"},"parameters":[""]}],"actions":[{"type":{"value":"SetWindowSize"},"parameters":["","ScreenHeight()","ScreenHeight()",""]},{"type":{"value":"CenterWindow"},"parameters":["ScreenWidth() / 2"]}]},{"type":"BuiltinCommonInstructions::Comment","color":{"b":109,"g":230,"r":255,"textB":0,"textG":0,"textR":0},"comment":"The player won't get a good look at these characters in gameplay from the top down, so these rotating models act as a kind of primer. This was my compromise for not being able to figure out how to get a better camera angle.\n(I don't remember why I rotated them by two different methods, but at this point I'm afraid to \"fix\" it, since it ain't broke.)"},{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"Scene3D::Base3DBehavior::SetRotationY"},"parameters":["Trex","Object3D","+","2"]},{"type":{"value":"Scene3D::Base3DBehavior::TurnAroundY"},"parameters":["Alpaca","Object3D","-2"]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"ButtonStates::ButtonFSM::IsClicked"},"parameters":["Start_Button","ButtonFSM",""]}],"actions":[{"type":{"value":"Scene"},"parameters":["","\"Tofu Goes to Hollywood\"","yes"]}]}],"layers":[{"ambientLightColorB":200,"ambientLightColorG":200,"ambientLightColorR":200,"camera3DFarPlaneDistance":10000.0,"camera3DFieldOfView":45.0,"camera3DNearPlaneDistance":3.0,"cameraType":"","followBaseLayerCamera":false,"isLightingLayer":false,"isLocked":false,"name":"","renderingType":"","visibility":true,"cameras":[{"defaultSize":true,"defaultViewport":true,"height":0.0,"viewportBottom":1.0,"viewportLeft":0.0,"viewportRight":1.0,"viewportTop":0.0,"width":0.0}],"effects":[{"effectType":"Scene3D::HemisphereLight","name":"3D Light","doubleParameters":{"elevation":45.0,"intensity":1.0,"rotation":0.0},"stringParameters":{"groundColor":"64;64;64","skyColor":"255;255;255","top":"Y-"},"booleanParameters":{}}]}],"behaviorsSharedData":[{"name":"Animation","type":"AnimatableCapability::AnimatableBehavior"},{"name":"ButtonFSM","type":"ButtonStates::ButtonFSM"},{"name":"Effect","type":"EffectCapability::EffectBehavior"},{"name":"Flippable","type":"FlippableCapability::FlippableBehavior"},{"name":"LightObstacleBehavior","type":"Lighting::LightObstacleBehavior"},{"name":"Object3D","type":"Scene3D::Base3DBehavior"},{"name":"Opacity","type":"OpacityCapability::OpacityBehavior"},{"name":"Pathfinding","type":"PathfindingBehavior::PathfindingBehavior"},{"name":"PlaneProjectionFromTiled","type":"WithThreeJS::PlaneProjectionFromTiled"},{"name":"Resizable","type":"ResizableCapability::ResizableBehavior"},{"name":"Scale","type":"ScalableCapability::ScalableBehavior"},{"name":"Text","type":"TextContainerCapability::TextContainerBehavior"},{"name":"cursor","type":"MouseHelper::cursor"}]},{"b":0,"disableInputWhenNotFocused":true,"mangledName":"Victory","name":"Victory","r":0,"standardSortMethod":true,"stopSoundsOnStartup":true,"title":"","v":0,"uiSettings":{"grid":false,"gridType":"rectangular","gridWidth":100.0,"gridHeight":100.0,"gridOffsetX":0.0,"gridOffsetY":0.0,"gridColor":10401023.0,"gridAlpha":0.8,"snap":false,"zoomFactor":0.4335774304702382,"windowMask":false},"objectsGroups":[],"variables":[{"folded":true,"name":"buttonClicked","type":"boolean","value":false}],"instances":[{"angle":0.0,"customSize":true,"depth":1.0,"height":1023.0,"keepRatio":true,"layer":"","name":"ForestBackground","persistentUuid":"e330ee20-f1fa-431b-9ef3-6205c664fd7a","width":1392.0,"x":-65.0,"y":81.0,"zOrder":-20,"numberProperties":[],"stringProperties":[],"initialVariables":[]},{"angle":0.0,"customSize":false,"height":0.0,"keepRatio":true,"layer":"","name":"Alpaca","persistentUuid":"74f9d954-6eab-403d-9220-9f3b8a3480f5","rotationX":90.0,"width":0.0,"x":-80.0,"y":831.0,"z":100.0,"zOrder":2,"numberProperties":[],"stringProperties":[],"initialVariables":[]},{"angle":0.0,"customSize":true,"depth":348.5142583008844,"height":182.06696245534025,"keepRatio":true,"layer":"","name":"Trex","persistentUuid":"0906f53b-a035-4874-bc6d-5f2256da447c","rotationX":90.0,"width":710.2955092293626,"x":-891.0,"y":831.0,"z":100.0,"zOrder":3,"numberProperties":[],"stringProperties":[],"initialVariables":[]},{"angle":0.0,"customSize":false,"height":0.0,"keepRatio":true,"layer":"","name":"Tofu2","persistentUuid":"a2e10618-d5da-41ba-aaff-b57f919e5b44","rotationX":90.0,"width":0.0,"x":-80.0,"y":664.0,"z":100.0,"zOrder":4,"numberProperties":[],"stringProperties":[],"initialVariables":[]},{"angle":0.0,"customSize":true,"depth":1.0,"height":244.0,"keepRatio":true,"layer":"Message Layer 1","name":"You_Win_text","persistentUuid":"0b6b6ef5-d5eb-4049-a69e-e03df78a4657","width":273.0,"x":516.0,"y":400.0,"zOrder":5,"numberProperties":[],"stringProperties":[],"initialVariables":[]},{"angle":0.0,"customSize":true,"depth":48.0,"height":116.0,"keepRatio":true,"layer":"Button Layer","name":"Start_Again_button","persistentUuid":"76ed4023-8961-4ad1-9913-08e016472e57","width":192.0,"x":555.0,"y":705.0,"zOrder":6,"numberProperties":[],"stringProperties":[],"initialVariables":[]},{"angle":0.0,"customSize":true,"depth":48.0,"height":63.0,"keepRatio":true,"layer":"Button Layer","name":"Reset_Button","persistentUuid":"9beb6479-57e7-43bf-8cf3-0887ebc65158","width":256.0,"x":512.0,"y":1292.0,"zOrder":7,"numberProperties":[],"stringProperties":[],"initialVariables":[]}],"objects":[{"assetStoreId":"90cac64ec9901c742b38aea323e8c52dc954197bfb5511ef86067aa187ac06c4","height":1024.0,"name":"ForestBackground","texture":"tiled_Forest Background.png","type":"TiledSpriteObject::TiledSprite","width":1024.0,"variables":[],"effects":[],"behaviors":[]},{"assetStoreId":"","bold":false,"italic":false,"name":"You_Win_text","smoothed":true,"type":"TextObject::Text","underlined":false,"variables":[],"effects":[],"behaviors":[],"string":"You Win!","font":"CaesarDressing-Regular.ttf","textAlignment":"center","characterSize":100.0,"color":{"b":35,"g":83,"r":61},"content":{"bold":false,"isOutlineEnabled":true,"isShadowEnabled":false,"italic":false,"outlineColor":"255;255;255","outlineThickness":2.0,"shadowAngle":90.0,"shadowBlurRadius":2.0,"shadowColor":"0;0;0","shadowDistance":4.0,"shadowOpacity":127.0,"smoothed":true,"underlined":false,"text":"You Win!","font":"CaesarDressing-Regular.ttf","textAlignment":"center","characterSize":100.0,"color":"61;83;35"}},{"assetStoreId":"1cacfe2713f10642e8079542f28282d52f1bf46ae2dc27dc6c291a2970c90971","name":"Start_Again_button","type":"PanelSpriteButton::PanelSpriteButton","variables":[],"effects":[],"behaviors":[{"name":"ButtonFSM","type":"ButtonStates::ButtonFSM","ShouldCheckHovering":true,"State":"Idle","TouchId":0.0,"TouchIsInside":false,"MouseIsInside":false,"Index":2.0247e-320}],"content":{"LeftPadding":0.0,"RightPadding":0.0,"PressedLabelOffsetY":4.0,"BottomPadding":10.0,"TopPadding":0.0,"HoveredFadeOutDuration":0.2},"childrenContent":{"Hovered":{"bottomMargin":11.0,"height":64.0,"leftMargin":7.0,"rightMargin":7.0,"texture":"Medieval Button Beige_Hovered.png","tiled":true,"topMargin":7.0,"width":192.0},"Idle":{"bottomMargin":11.0,"height":64.0,"leftMargin":7.0,"rightMargin":7.0,"texture":"Medieval Button Beige_Idle.png","tiled":true,"topMargin":7.0,"width":192.0},"Label":{"bold":false,"italic":false,"smoothed":true,"underlined":false,"string":"Start Again?","font":"CaesarDressing-Regular.ttf","textAlignment":"center","characterSize":40.0,"color":{"b":64,"g":99,"r":133},"content":{"bold":false,"isOutlineEnabled":false,"isShadowEnabled":false,"italic":false,"outlineColor":"255;255;255","outlineThickness":2.0,"shadowAngle":90.0,"shadowBlurRadius":2.0,"shadowColor":"0;0;0","shadowDistance":4.0,"shadowOpacity":127.0,"smoothed":true,"underlined":false,"text":"Start Again?","font":"CaesarDressing-Regular.ttf","textAlignment":"center","characterSize":40.0,"color":"133;99;64"}},"Pressed":{"bottomMargin":7.0,"height":64.0,"leftMargin":7.0,"rightMargin":7.0,"texture":"Medieval Button Beige_Pressed.png","tiled":true,"topMargin":11.0,"width":192.0}}},{"assetStoreId":"","height":32.0,"name":"Invisible_Element_Placement_Visualizer","texture":"NewTiledSprite2","type":"TiledSpriteObject::TiledSprite","width":32.0,"variables":[],"effects":[],"behaviors":[]},{"assetStoreId":"615de0316452630b9f4f6a39decc82e2449b82c1afd1ff24d6470dad2922177b","name":"Reset_Button","type":"PanelSpriteButton::PanelSpriteButton","variables":[],"effects":[],"behaviors":[],"content":{"LeftPadding":16.0,"RightPadding":16.0,"PressedLabelOffsetY":10.0,"BottomPadding":32.0,"TopPadding":16.0,"HoveredFadeOutDuration":0.25},"childrenContent":{"Hovered":{"bottomMargin":32.0,"height":106.0,"leftMargin":16.0,"rightMargin":16.0,"texture":"Yellow Button_Hovered.png","tiled":true,"topMargin":16.0,"width":256.0},"Idle":{"bottomMargin":32.0,"height":106.0,"leftMargin":16.0,"rightMargin":16.0,"texture":"Yellow Button_Idle.png","tiled":true,"topMargin":16.0,"width":256.0},"Label":{"bold":false,"italic":false,"smoothed":true,"underlined":false,"string":"Reset Game","font":"3bd40ac788d44626fd640ec67ef04ab0364816b5e8c831f2077bff8805cfe689_Roboto-Bold.ttf","textAlignment":"center","characterSize":30.0,"color":{"b":25,"g":43,"r":63},"content":{"bold":false,"isOutlineEnabled":false,"isShadowEnabled":false,"italic":false,"outlineColor":"255;255;255","outlineThickness":2.0,"shadowAngle":90.0,"shadowBlurRadius":2.0,"shadowColor":"0;0;0","shadowDistance":4.0,"shadowOpacity":127.0,"smoothed":true,"underlined":false,"text":"Reset Game","font":"3bd40ac788d44626fd640ec67ef04ab0364816b5e8c831f2077bff8805cfe689_Roboto-Bold.ttf","textAlignment":"center","characterSize":30.0,"color":"63;43;25"}},"Pressed":{"bottomMargin":16.0,"height":106.0,"leftMargin":16.0,"rightMargin":16.0,"texture":"Yellow Button_Pressed.png","tiled":true,"topMargin":32.0,"width":256.0}}}],"objectsFolderStructure":{"folderName":"__ROOT","children":[{"objectName":"ForestBackground"},{"objectName":"You_Win_text"},{"objectName":"Start_Again_button"},{"objectName":"Invisible_Element_Placement_Visualizer"},{"objectName":"Reset_Button"}]},"events":[{"type":"BuiltinCommonInstructions::Comment","color":{"b":109,"g":230,"r":255,"textB":0,"textG":0,"textR":0},"comment":"The characters trot across the screen, exit stage right, pursued by a dinosaur. A victory message and 'Start Again' button appear as the alpaca crosses one quarter, and just over half the game-field distance, respectively."},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"DepartScene"},"parameters":[""]}],"actions":[{"type":{"value":"SetWindowSize"},"parameters":["","ScreenHeight()","ScreenHeight()",""]},{"type":{"value":"MontreSouris"},"parameters":[""]},{"type":{"value":"AnimatableCapability::AnimatableBehavior::SetName"},"parameters":["Trex","Animation","=","\"Walk\""]},{"type":{"value":"AnimatableCapability::AnimatableBehavior::SetName"},"parameters":["Alpaca","Animation","=","\"Run\""]},{"type":{"value":"PathfindingBehavior::MaxSpeed"},"parameters":["Trex","Pathfinding","=","200"]},{"type":{"value":"PathfindingBehavior::SetDestination"},"parameters":["Tofu2","Pathfinding","","SceneWindowWidth() * 1.5","Tofu2.Y()"]},{"type":{"value":"PathfindingBehavior::SetDestination"},"parameters":["Trex","Pathfinding","","SceneWindowWidth() * 1.5","Trex.Y()"]},{"type":{"value":"PathfindingBehavior::SetDestination"},"parameters":["Alpaca","Pathfinding","","SceneWindowWidth() * 1.5","Alpaca.Y()"]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"PosX"},"parameters":["Alpaca",">","SceneWindowWidth() * 0.25"]}],"actions":[{"type":{"value":"ShowLayer"},"parameters":["","\"Message Layer 1\""]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"PosX"},"parameters":["Alpaca",">","SceneWindowWidth() * 0.6"]}],"actions":[{"type":{"value":"ShowLayer"},"parameters":["","\"Button Layer\""]}]},{"type":"BuiltinCommonInstructions::Comment","color":{"b":109,"g":230,"r":255,"textB":0,"textG":0,"textR":0},"comment":"The Player clicks 'Start Again' : A video appears. After a short timer, a true 'Reset' button appears which will reset the game."},{"colorB":228,"colorG":176,"colorR":74,"creationTime":0,"name":"The Player clicks 'Start Again'","source":"","type":"BuiltinCommonInstructions::Group","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"ButtonStates::ButtonFSM::IsClicked"},"parameters":["Start_Again_button","ButtonFSM","="]}],"actions":[{"type":{"value":"SetBooleanVariable"},"parameters":["buttonClicked","True",""]},{"type":{"value":"Iframe::Create"},"parameters":["","\"Win Video\"","\"https://www.youtube.com/embed/G87p148EOjo?si=al65LttpOI8rD3Yq&amp;start=39&autoplay=1\"","SceneWindowWidth() * 0.5","SceneWindowHeight() * 0.5","100","55","yes","yes","",""]}],"events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"CenterY"},"parameters":["Reset_Button",">","SceneWindowHeight() * 0.9"]}],"actions":[{"type":{"value":"Wait"},"parameters":["14.5"]},{"type":{"value":"SetCenterX"},"parameters":["Reset_Button","=","SceneWindowWidth() * 0.5"]},{"type":{"value":"SetCenterY"},"parameters":["Reset_Button","-","Reset_Button.Y() - SceneWindowHeight() * 0.9"]}]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"PanelSpriteButton::PanelSpriteButton::IsClicked"},"parameters":["Reset_Button",""]}],"actions":[{"type":{"value":"Iframe::Delete"},"parameters":["","\"Win Video\"",""]},{"type":{"value":"Scene"},"parameters":["","\"Start Screen\"",""]}]}],"parameters":[]},{"type":"BuiltinCommonInstructions::Comment","color":{"b":109,"g":230,"r":255,"textB":0,"textG":0,"textR":0},"comment":"If the Player does not interact with the Start Again button for 8 seconds, the game resets itself. (Wait...why, for easter egg? Consider deleting; only way to restart is to click 'Start Again' and wait for 'Restart' button to appear.)dd"},{"colorB":228,"colorG":176,"colorR":74,"creationTime":0,"disabled":true,"folded":true,"name":"The Player Ignores the 'Start Again' button","source":"","type":"BuiltinCommonInstructions::Group","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"LayerVisible"},"parameters":["buttonClicked","\"Button Layer\""]}],"actions":[{"type":{"value":"Wait"},"parameters":["8"]}],"events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"BooleanVariable"},"parameters":["buttonClicked","False",""]}],"actions":[{"type":{"value":"Scene"},"parameters":["","\"Start Screen\"",""]}]}]}],"parameters":[]}],"layers":[{"ambientLightColorB":200,"ambientLightColorG":200,"ambientLightColorR":200,"camera3DFarPlaneDistance":10000.0,"camera3DFieldOfView":45.0,"camera3DNearPlaneDistance":3.0,"cameraType":"perspective","followBaseLayerCamera":false,"isLightingLayer":false,"isLocked":false,"name":"","renderingType":"","visibility":true,"cameras":[{"defaultSize":true,"defaultViewport":true,"height":0.0,"viewportBottom":1.0,"viewportLeft":0.0,"viewportRight":1.0,"viewportTop":0.0,"width":0.0}],"effects":[{"effectType":"Scene3D::HemisphereLight","name":"3D Light","doubleParameters":{"elevation":45.0,"intensity":1.0,"rotation":0.0},"stringParameters":{"groundColor":"64;64;64","skyColor":"255;255;255","top":"Y-"},"booleanParameters":{}}]},{"ambientLightColorB":200,"ambientLightColorG":200,"ambientLightColorR":200,"camera3DFarPlaneDistance":10000.0,"camera3DFieldOfView":45.0,"camera3DNearPlaneDistance":3.0,"cameraType":"","followBaseLayerCamera":false,"isLightingLayer":false,"isLocked":false,"name":"Message Layer 1","renderingType":"","visibility":false,"cameras":[],"effects":[{"effectType":"Scene3D::HemisphereLight","name":"3D Light","doubleParameters":{"elevation":45.0,"intensity":1.0,"rotation":0.0},"stringParameters":{"groundColor":"64;64;64","skyColor":"255;255;255","top":"Y-"},"booleanParameters":{}}]},{"ambientLightColorB":200,"ambientLightColorG":200,"ambientLightColorR":200,"camera3DFarPlaneDistance":10000.0,"camera3DFieldOfView":45.0,"camera3DNearPlaneDistance":3.0,"cameraType":"","followBaseLayerCamera":false,"isLightingLayer":false,"isLocked":false,"name":"Button Layer","renderingType":"","visibility":true,"cameras":[],"effects":[{"effectType":"Scene3D::HemisphereLight","name":"3D Light","doubleParameters":{"elevation":45.0,"intensity":1.0,"rotation":0.0},"stringParameters":{"groundColor":"64;64;64","skyColor":"255;255;255","top":"Y-"},"booleanParameters":{}}]}],"behaviorsSharedData":[{"name":"Animation","type":"AnimatableCapability::AnimatableBehavior"},{"name":"ButtonFSM","type":"ButtonStates::ButtonFSM"},{"name":"Effect","type":"EffectCapability::EffectBehavior"},{"name":"Flippable","type":"FlippableCapability::FlippableBehavior"},{"name":"LightObstacleBehavior","type":"Lighting::LightObstacleBehavior"},{"name":"Object3D","type":"Scene3D::Base3DBehavior"},{"name":"Opacity","type":"OpacityCapability::OpacityBehavior"},{"name":"Pathfinding","type":"PathfindingBehavior::PathfindingBehavior"},{"name":"PlaneProjectionFromTiled","type":"WithThreeJS::PlaneProjectionFromTiled"},{"name":"Resizable","type":"ResizableCapability::ResizableBehavior"},{"name":"Scale","type":"ScalableCapability::ScalableBehavior"},{"name":"Text","type":"TextContainerCapability::TextContainerBehavior"}]}],"externalEvents":[],"eventsFunctionsExtensions":[{"author":"@Bouh, @arthuro555","category":"User interface","extensionNamespace":"","fullName":"Cursor type","helpPath":"","iconUrl":"data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiBpZD0ibWRpLWN1cnNvci1kZWZhdWx0LW91dGxpbmUiIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0Ij48cGF0aCBkPSJNMTAuMDcsMTQuMjdDMTAuNTcsMTQuMDMgMTEuMTYsMTQuMjUgMTEuNCwxNC43NUwxMy43LDE5Ljc0TDE1LjUsMTguODlMMTMuMTksMTMuOTFDMTIuOTUsMTMuNDEgMTMuMTcsMTIuODEgMTMuNjcsMTIuNThMMTMuOTUsMTIuNUwxNi4yNSwxMi4wNUw4LDUuMTJWMTUuOUw5LjgyLDE0LjQzTDEwLjA3LDE0LjI3TTEzLjY0LDIxLjk3QzEzLjE0LDIyLjIxIDEyLjU0LDIyIDEyLjMxLDIxLjVMMTAuMTMsMTYuNzZMNy42MiwxOC43OEM3LjQ1LDE4LjkyIDcuMjQsMTkgNywxOUExLDEgMCAwLDEgNiwxOFYzQTEsMSAwIDAsMSA3LDJDNy4yNCwyIDcuNDcsMi4wOSA3LjY0LDIuMjNMNy42NSwyLjIyTDE5LjE0LDExLjg2QzE5LjU3LDEyLjIyIDE5LjYyLDEyLjg1IDE5LjI3LDEzLjI3QzE5LjEyLDEzLjQ1IDE4LjkxLDEzLjU3IDE4LjcsMTMuNjFMMTUuNTQsMTQuMjNMMTcuNzQsMTguOTZDMTgsMTkuNDYgMTcuNzYsMjAuMDUgMTcuMjYsMjAuMjhMMTMuNjQsMjEuOTdaIiAvPjwvc3ZnPg==","name":"CursorType","previewIconUrl":"https://resources.gdevelop-app.com/assets/Icons/cursor-default-outline.svg","shortDescription":"Provides an action to change the type of the cursor, and a behavior to change the cursor when an object is hovered.","version":"0.0.6","description":["Provides an action to change the type of the cursor, and a behavior to change the cursor when an object is hovered.","","Find the list of cursors here: https://developer.mozilla.org/en-US/docs/Web/CSS/cursor"],"origin":{"identifier":"CursorType","name":"gdevelop-extension-store"},"tags":["mouse","cursor","pointer","javascript","desktop"],"authorIds":["ZgrsWuRTAkXgeuPV9bo0zuEcA2w1","2OwwM8ToR9dx9RJ2sAKTcrLmCB92"],"dependencies":[],"globalVariables":[],"sceneVariables":[],"eventsFunctions":[{"description":"Change the type of the cursor.","fullName":"Cursor type","functionType":"Action","name":"ChangeCursorType","sentence":"Change the cursor to _PARAM1_","events":[{"type":"BuiltinCommonInstructions::Comment","color":{"b":109,"g":230,"r":255,"textB":0,"textG":0,"textR":0},"comment":"Set as variable instead of directly setting as a CursorHover behavior can override it.\nBy using a variable, we ensure to be able to change it back to that \"default\" after the override is over."},{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"ModVarGlobalTxt"},"parameters":["__CursorType.DefaultCursor","=","GetArgumentAsString(\"cursor_type\")"]}]},{"disabled":true,"type":"BuiltinCommonInstructions::JsCode","inlineCode":["// Reset to default cursor","runtimeScene.getGame().getRenderer().getCanvas().style.cursor =","    runtimeScene","        .getGame()","        .getVariables()","        .get(\"__CursorType\").getChild(\"DefaultCursor\")","        .getAsString();",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":false}],"parameters":[{"defaultValue":"default","description":"The new cursor type","longDescription":"List of available cursors on https://developer.mozilla.org/en-US/docs/Web/CSS/cursor","name":"cursor_type","supplementaryInformation":"[\"auto\",\"default\",\"none\",\"context-menu\",\"help\",\"pointer\",\"progress\",\"wait\",\"cell\",\"crosshair\",\"text\",\"vertical-text\",\"alias\",\"copy\",\"move\",\"no-drop\",\"not-allowed\",\"grab\",\"grabbing\",\"all-scroll\",\"col-resize\",\"row-resize\",\"n-resize\",\"e-resize\",\"s-resize\",\"w-resize\",\"ne-resize\",\"nw-resize\",\"se-resize\",\"sw-resize\",\"ew-resize\",\"ns-resize\",\"nwse-resize\",\"zoom-in\",\"zoom-out\"]","type":"stringWithSelector"}],"objectGroups":[]},{"fullName":"","functionType":"Action","name":"onScenePreEvents","sentence":"","events":[{"type":"BuiltinCommonInstructions::Comment","color":{"b":109,"g":230,"r":255,"textB":0,"textG":0,"textR":0},"comment":"Reset ordering as the object with highest Z-Order might not exist anymore or be not be hovered anymore."},{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"ModVarGlobal"},"parameters":["__CursorType.ZOrderSorting","=","0"]}]},{"type":"BuiltinCommonInstructions::Comment","color":{"b":109,"g":230,"r":255,"textB":0,"textG":0,"textR":0},"comment":"Set default value of the default cursor if the variable has just been created"},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"VarSceneTxt"},"parameters":["__CursorType.DefaultCursor","=","\"\""]}],"actions":[{"type":{"value":"ModVarGlobalTxt"},"parameters":["__CursorType.DefaultCursor","=","\"default\""]}]},{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["// Reset to default cursor","runtimeScene.getGame().getRenderer().getCanvas().style.cursor =","    runtimeScene","        .getGame()","        .getVariables()","        .get(\"__CursorType\").getChild(\"DefaultCursor\")","        .getAsString();",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"parameters":[],"objectGroups":[]}],"eventsBasedBehaviors":[{"description":"Change the cursor appearence when the object is hovered (on Windows, macOS or Linux).","fullName":"Custom cursor when hovered","name":"CursorHover","objectType":"","eventsFunctions":[{"fullName":"","functionType":"Action","name":"doStepPostEvents","sentence":"","events":[{"type":"BuiltinCommonInstructions::Comment","color":{"b":109,"g":230,"r":255,"textB":0,"textG":0,"textR":0},"comment":"Check the z Order to ensure the cursor shown is the one from the foremost object "},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"Plan"},"parameters":["Object",">","GlobalVariable(__CursorType.ZOrderSorting)"]},{"type":{"value":"SourisSurObjet"},"parameters":["Object","","",""]}],"actions":[{"type":{"value":"ModVarGlobal"},"parameters":["__CursorType.ZOrderSorting","=","Object.ZOrder()"]}],"events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["// Set cursor to behavior property cursor_type","objects.forEach(object => {","","    runtimeScene","        .getGame()","        .getRenderer()","        .getCanvas()","        .style","        .cursor = object","            .getBehavior(","                eventsFunctionContext.getBehaviorName(\"Behavior\")","            )","            ._getcursor_type();","});"],"parameterObjects":"Object","useStrict":true,"eventsSheetExpanded":true}]}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"CursorType::CursorHover","type":"behavior"}],"objectGroups":[]}],"propertyDescriptors":[{"value":"default","type":"Choice","label":"The cursor type","description":"See https://developer.mozilla.org/en-US/docs/Web/CSS/cursor for a list of possible cursors.","group":"","extraInformation":["auto","default","none","context-menu","help","pointer","progress","wait","cell","crosshair","text","vertical-text","alias","copy","move","no-drop","not-allowed","grab","grabbing","all-scroll","col-resize","row-resize","n-resize","e-resize","s-resize","w-resize","ne-resize","nw-resize","se-resize","sw-resize","ew-resize","ns-resize","nwse-resize","zoom-in","zoom-out"],"name":"cursor_type"}],"sharedPropertyDescriptors":[]}],"eventsBasedObjects":[]},{"author":"","category":"Movement","extensionNamespace":"","fullName":"Navigation mesh pathfinding (experimental)","helpPath":"","iconUrl":"data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4NCjwhLS0gR2VuZXJhdG9yOiBBZG9iZSBJbGx1c3RyYXRvciAyMy4wLjMsIFNWRyBFeHBvcnQgUGx1Zy1JbiAuIFNWRyBWZXJzaW9uOiA2LjAwIEJ1aWxkIDApICAtLT4NCjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iSWNvbnMiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4Ig0KCSB2aWV3Qm94PSIwIDAgMzIgMzIiIHN0eWxlPSJlbmFibGUtYmFja2dyb3VuZDpuZXcgMCAwIDMyIDMyOyIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+DQo8c3R5bGUgdHlwZT0idGV4dC9jc3MiPg0KCS5zdDB7ZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoyO3N0cm9rZS1saW5lY2FwOnJvdW5kO3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2UtbWl0ZXJsaW1pdDoxMDt9DQo8L3N0eWxlPg0KPHBvbHlsaW5lIGNsYXNzPSJzdDAiIHBvaW50cz0iMTcsMjYgNSwyNiA1LDQgMjcsNCAyNywyNiAyNSwyNiAiLz4NCjxwb2x5bGluZSBjbGFzcz0ic3QwIiBwb2ludHM9IjUsMTkgMTYsOCAyNywxOSAiLz4NCjxsaW5lIGNsYXNzPSJzdDAiIHgxPSIxMiIgeTE9IjQiIHgyPSIxOSIgeTI9IjExIi8+DQo8bGluZSBjbGFzcz0ic3QwIiB4MT0iMjIiIHkxPSI0IiB4Mj0iMjIiIHkyPSIxNCIvPg0KPHBhdGggY2xhc3M9InN0MCIgZD0iTTIwLjUsMTcuNWMtMS45LTEuOS01LjEtMS45LTcsMGMtMS45LDEuOS0xLjksNS4xLDAsN2MxLjQsMS41LDMuNiwxLjgsNS40LDEuMWMwLjYtMC4yLDEuMi0wLjYsMS42LTEuMQ0KCUMyMi40LDIyLjYsMjIuNCwxOS41LDIwLjUsMTcuNXoiLz4NCjxwYXRoIGNsYXNzPSJzdDAiIGQ9Ik0yMS41LDIzbDMuOSwzLjZjMC44LDAuOCwwLjgsMiwwLDIuOGwwLDBjLTAuOCwwLjgtMiwwLjgtMi44LDBsLTMuNS0zLjUiLz4NCjwvc3ZnPg0K","name":"NavMeshPathfinding","previewIconUrl":"https://resources.gdevelop-app.com/assets/Icons/Line Hero Pack/Master/SVG/Maps and Navigation/Maps and Navigation_map_find_search.svg","shortDescription":"Pathfinding allows to compute an efficient path for objects, avoiding obstacles on the way.","version":"0.2.3","description":["In comparison to the built-in pathfinding behavior, this one aims to:","- better respect obstacle shapes","- find paths faster if obstacles don't move","","The isometric example shows how to use this extension to move a character to a destination ([open the project online](https://editor.gdevelop.io/?project=example://isometric-game))."],"origin":{"identifier":"NavMeshPathfinding","name":"gdevelop-extension-store"},"tags":["navmesh","pathfinding","obstacle","solid","path","detour","recast"],"authorIds":["IWykYNRvhCZBN3vEgKEbBPOR3Oc2"],"dependencies":[],"globalVariables":[],"sceneVariables":[],"eventsFunctions":[{"description":"Define JavaScript classes.","fullName":"Define JavaScript classes","functionType":"Action","name":"DefineJavaScript","private":true,"sentence":"Define JavaScript classes","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["// This code has been built from https://github.com/D8H/NavMesh-GDevelop-Extension","// If you need to make any modification, please open a PR on github.","","if (gdjs.__NavMeshPathfinding) {","    return;","}","","var extendStatics = function(d, b) {","    extendStatics = Object.setPrototypeOf ||","        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||","        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };","    return extendStatics(d, b);","};","","function __extends(d, b) {","    if (typeof b !== \"function\" && b !== null)","        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");","    extendStatics(d, b);","    function __() { this.constructor = d; }","    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());","}","","/**"," * Stripped down version of Phaser's Vector2 with just the functionality needed for navmeshes."," *"," * @export"," * @class Vector2"," */","var Vector2 = /** @class */ (function () {","    function Vector2(x, y) {","        if (x === void 0) { x = 0; }","        if (y === void 0) { y = 0; }","        this.x = x;","        this.y = y;","    }","    Vector2.prototype.equals = function (v) {","        return this.x === v.x && this.y === v.y;","    };","    Vector2.prototype.angle = function (v) {","        return Math.atan2(v.y - this.y, v.x - this.x);","    };","    Vector2.prototype.distance = function (v) {","        var dx = v.x - this.x;","        var dy = v.y - this.y;","        return Math.sqrt(dx * dx + dy * dy);","    };","    Vector2.prototype.add = function (v) {","        this.x += v.x;","        this.y += v.y;","    };","    Vector2.prototype.subtract = function (v) {","        this.x -= v.x;","        this.y -= v.y;","    };","    Vector2.prototype.clone = function () {","        return new Vector2(this.x, this.y);","    };","    return Vector2;","}());","","var GridNode = /** @class */ (function () {","    function GridNode(weight) {","        this.h = 0;","        this.g = 0;","        this.f = 0;","        this.closed = false;","        this.visited = false;","        this.parent = null;","        this.weight = weight;","    }","    GridNode.prototype.isWall = function () {","        return this.weight === 0;","    };","    GridNode.prototype.clean = function () {","        this.f = 0;","        this.g = 0;","        this.h = 0;","        this.visited = false;","        this.closed = false;","        this.parent = null;","    };","    return GridNode;","}());","","/**"," * A class that represents a navigable polygon with a navmesh. It is built on top of a"," * {@link Polygon}. It implements the properties and fields that javascript-astar needs - weight,"," * toString, isWall and getCost. See GPS test from astar repo for structure:"," * https://github.com/bgrins/javascript-astar/blob/master/test/tests.js"," */","var NavPoly = /** @class */ (function (_super) {","    __extends(NavPoly, _super);","    /**","     * Creates an instance of NavPoly.","     */","    function NavPoly(id, polygon) {","        var _this = _super.call(this, 1) || this;","        _this.id = id;","        _this.polygon = polygon;","        _this.edges = polygon.edges;","        _this.neighbors = [];","        _this.portals = [];","        _this.centroid = _this.calculateCentroid();","        _this.boundingRadius = _this.calculateRadius();","        return _this;","    }","    /**","     * Returns an array of points that form the polygon.","     */","    NavPoly.prototype.getPoints = function () {","        return this.polygon.points;","    };","    /**","     * Check if the given point-like object is within the polygon.","     */","    NavPoly.prototype.contains = function (point) {","        // Phaser's polygon check doesn't handle when a point is on one of the edges of the line. Note:","        // check numerical stability here. It would also be good to optimize this for different shapes.","        return this.polygon.contains(point.x, point.y) || this.isPointOnEdge(point);","    };","    /**","     * Only rectangles are supported, so this calculation works, but this is not actually the centroid","     * calculation for a polygon. This is just the average of the vertices - proper centroid of a","     * polygon factors in the area.","     */","    NavPoly.prototype.calculateCentroid = function () {","        var centroid = new Vector2(0, 0);","        var length = this.polygon.points.length;","        this.polygon.points.forEach(function (p) { return centroid.add(p); });","        centroid.x /= length;","        centroid.y /= length;","        return centroid;","    };","    /**","     * Calculate the radius of a circle that circumscribes the polygon.","     */","    NavPoly.prototype.calculateRadius = function () {","        var boundingRadius = 0;","        for (var _i = 0, _a = this.polygon.points; _i < _a.length; _i++) {","            var point = _a[_i];","            var d = this.centroid.distance(point);","            if (d > boundingRadius)","                boundingRadius = d;","        }","        return boundingRadius;","    };","    /**","     * Check if the given point-like object is on one of the edges of the polygon.","     */","    NavPoly.prototype.isPointOnEdge = function (_a) {","        var x = _a.x, y = _a.y;","        for (var _i = 0, _b = this.edges; _i < _b.length; _i++) {","            var edge = _b[_i];","            if (edge.pointOnSegment(x, y))","                return true;","        }","        return false;","    };","    NavPoly.prototype.destroy = function () {","        this.neighbors = [];","        this.portals = [];","    };","    // === jsastar methods ===","    NavPoly.prototype.toString = function () {","        return \"NavPoly(id: \" + this.id + \" at: \" + this.centroid + \")\";","    };","    NavPoly.prototype.isWall = function () {","        return false;","    };","    NavPoly.prototype.centroidDistance = function (navPolygon) {","        return this.centroid.distance(navPolygon.centroid);","    };","    NavPoly.prototype.getCost = function (navPolygon) {","        //TODO the cost method should not be in the Node","        return this.centroidDistance(navPolygon);","    };","    return NavPoly;","}(GridNode));","","/**"," * A graph memory structure"," */","var Graph = /** @class */ (function () {","    /**","     * A graph memory structure","     * @param {Array} gridIn 2D array of input weights","     * @param {Object} [options]","     * @param {bool} [options.diagonal] Specifies whether diagonal moves are allowed","     */","    function Graph(nodes, options) {","        this.dirtyNodes = [];","        options = options || {};","        this.nodes = nodes;","        this.diagonal = !!options.diagonal;","        this.init();","    }","    Graph.prototype.init = function () {","        this.dirtyNodes = [];","        for (var i = 0; i < this.nodes.length; i++) {","            this.nodes[i].clean();","        }","    };","    Graph.prototype.cleanDirty = function () {","        for (var i = 0; i < this.dirtyNodes.length; i++) {","            this.dirtyNodes[i].clean();","        }","        this.dirtyNodes = [];","    };","    Graph.prototype.markDirty = function (node) {","        this.dirtyNodes.push(node);","    };","    return Graph;","}());","","/**"," * Graph for javascript-astar. It implements the functionality for astar. See GPS test from astar"," * repo for structure: https://github.com/bgrins/javascript-astar/blob/master/test/tests.js"," *"," * @class NavGraph"," * @private"," */","var NavGraph = /** @class */ (function (_super) {","    __extends(NavGraph, _super);","    function NavGraph(navPolygons) {","        var _this = _super.call(this, navPolygons) || this;","        _this.nodes = navPolygons;","        _this.init();","        return _this;","    }","    NavGraph.prototype.neighbors = function (navPolygon) {","        return navPolygon.neighbors;","    };","    NavGraph.prototype.navHeuristic = function (navPolygon1, navPolygon2) {","        return navPolygon1.centroidDistance(navPolygon2);","    };","    NavGraph.prototype.destroy = function () {","        this.cleanDirty();","        this.nodes = [];","    };","    return NavGraph;","}(Graph));","","/**"," * Calculate the distance squared between two points. This is an optimization to a square root when"," * you just need to compare relative distances without needing to know the specific distance."," * @param a"," * @param b"," */","function distanceSquared(a, b) {","    var dx = b.x - a.x;","    var dy = b.y - a.y;","    return dx * dx + dy * dy;","}","/**"," * Project a point onto a line segment."," * JS Source: http://stackoverflow.com/questions/849211/shortest-distance-between-a-point-and-a-line-segment"," * @param point"," * @param line"," */","function projectPointToEdge(point, line) {","    var a = line.start;","    var b = line.end;","    // Consider the parametric equation for the edge's line, p = a + t (b - a). We want to find","    // where our point lies on the line by solving for t:","    //  t = [(p-a) . (b-a)] / |b-a|^2","    var l2 = distanceSquared(a, b);","    var t = ((point.x - a.x) * (b.x - a.x) + (point.y - a.y) * (b.y - a.y)) / l2;","    // We clamp t from [0,1] to handle points outside the segment vw.","    t = clamp(t, 0, 1);","    // Project onto the segment","    var p = new Vector2(a.x + t * (b.x - a.x), a.y + t * (b.y - a.y));","    return p;","}","/**"," * Twice the area of the triangle formed by a, b and c."," */","function triarea2(a, b, c) {","    var ax = b.x - a.x;","    var ay = b.y - a.y;","    var bx = c.x - a.x;","    var by = c.y - a.y;","    return bx * ay - ax * by;","}","/**"," * Clamp the given value between min and max."," */","function clamp(value, min, max) {","    if (value < min)","        value = min;","    if (value > max)","        value = max;","    return value;","}","/**"," * Check if two values are within a small margin of one another."," */","function almostEqual(value1, value2, errorMargin) {","    if (errorMargin === void 0) { errorMargin = 0.0001; }","    if (Math.abs(value1 - value2) <= errorMargin)","        return true;","    else","        return false;","}","/**"," * Find the smallest angle difference between two angles"," * https://gist.github.com/Aaronduino/4068b058f8dbc34b4d3a9eedc8b2cbe0"," */","function angleDifference(x, y) {","    var a = x - y;","    var i = a + Math.PI;","    var j = Math.PI * 2;","    a = i - Math.floor(i / j) * j; // (a+180) % 360; this ensures the correct sign","    a -= Math.PI;","    return a;","}","/**"," * Check if two lines are collinear (within a small error margin)."," */","function areCollinear(line1, line2, errorMargin) {","    if (errorMargin === void 0) { errorMargin = 0.0001; }","    // Figure out if the two lines are equal by looking at the area of the triangle formed","    // by their points","    var area1 = triarea2(line1.start, line1.end, line2.start);","    var area2 = triarea2(line1.start, line1.end, line2.end);","    if (almostEqual(area1, 0, errorMargin) && almostEqual(area2, 0, errorMargin)) {","        return true;","    }","    else","        return false;","}","","// Mostly sourced from PatrolJS at the moment. TODO: come back and reimplement this as an incomplete","/**"," * @private"," */","var Channel = /** @class */ (function () {","    function Channel() {","        this.portals = [];","        this.path = [];","    }","    Channel.prototype.push = function (p1, p2) {","        if (p2 === undefined)","            p2 = p1;","        this.portals.push({","            left: p1,","            right: p2,","        });","    };","    Channel.prototype.stringPull = function () {","        var portals = this.portals;","        var pts = [];","        // Init scan state","        var apexIndex = 0;","        var leftIndex = 0;","        var rightIndex = 0;","        var portalApex = portals[0].left;","        var portalLeft = portals[0].left;","        var portalRight = portals[0].right;","        // Add start point.","        pts.push(portalApex);","        for (var i = 1; i < portals.length; i++) {","            // Find the next portal vertices","            var left = portals[i].left;","            var right = portals[i].right;","            // Update right vertex.","            if (triarea2(portalApex, portalRight, right) <= 0.0) {","                if (portalApex.equals(portalRight) || triarea2(portalApex, portalLeft, right) > 0.0) {","                    // Tighten the funnel.","                    portalRight = right;","                    rightIndex = i;","                }","                else {","                    // Right vertex just crossed over the left vertex, so the left vertex should","                    // now be part of the path.","                    pts.push(portalLeft);","                    // Restart scan from portal left point.","                    // Make current left the new apex.","                    portalApex = portalLeft;","                    apexIndex = leftIndex;","                    // Reset portal","                    portalLeft = portalApex;","                    portalRight = portalApex;","                    leftIndex = apexIndex;","                    rightIndex = apexIndex;","                    // Restart scan","                    i = apexIndex;","                    continue;","                }","            }","            // Update left vertex.","            if (triarea2(portalApex, portalLeft, left) >= 0.0) {","                if (portalApex.equals(portalLeft) || triarea2(portalApex, portalRight, left) < 0.0) {","                    // Tighten the funnel.","                    portalLeft = left;","                    leftIndex = i;","                }","                else {","                    // Left vertex just crossed over the right vertex, so the right vertex should","                    // now be part of the path","                    pts.push(portalRight);","                    // Restart scan from portal right point.","                    // Make current right the new apex.","                    portalApex = portalRight;","                    apexIndex = rightIndex;","                    // Reset portal","                    portalLeft = portalApex;","                    portalRight = portalApex;","                    leftIndex = apexIndex;","                    rightIndex = apexIndex;","                    // Restart scan","                    i = apexIndex;","                    continue;","                }","            }","        }","        if (pts.length === 0 || !pts[pts.length - 1].equals(portals[portals.length - 1].left)) {","            // Append last point to path.","            pts.push(portals[portals.length - 1].left);","        }","        this.path = pts;","        return pts;","    };","    return Channel;","}());","","/**"," * Stripped down version of Phaser's Line with just the functionality needed for navmeshes."," *"," * @export"," * @class Line"," */","var Line = /** @class */ (function () {","    function Line(x1, y1, x2, y2) {","        this.start = new Vector2(x1, y1);","        this.end = new Vector2(x2, y2);","        this.left = Math.min(x1, x2);","        this.right = Math.max(x1, x2);","        this.top = Math.min(y1, y2);","        this.bottom = Math.max(y1, y2);","    }","    Line.prototype.pointOnSegment = function (x, y) {","        return (x >= this.left &&","            x <= this.right &&","            y >= this.top &&","            y <= this.bottom &&","            this.pointOnLine(x, y));","    };","    Line.prototype.pointOnLine = function (x, y) {","        // Compare slope of line start -> xy to line start -> line end","        return (x - this.left) * (this.bottom - this.top) === (this.right - this.left) * (y - this.top);","    };","    return Line;","}());","","/**"," * Stripped down version of Phaser's Polygon with just the functionality needed for navmeshes."," *"," * @export"," * @class Polygon"," */","var Polygon = /** @class */ (function () {","    function Polygon(points, closed) {","        if (closed === void 0) { closed = true; }","        this.isClosed = closed;","        this.points = points;","        this.edges = [];","        for (var i = 1; i < points.length; i++) {","            var p1 = points[i - 1];","            var p2 = points[i];","            this.edges.push(new Line(p1.x, p1.y, p2.x, p2.y));","        }","        if (this.isClosed) {","            var first = points[0];","            var last = points[points.length - 1];","            this.edges.push(new Line(first.x, first.y, last.x, last.y));","        }","    }","    Polygon.prototype.contains = function (x, y) {","        var inside = false;","        for (var i = -1, j = this.points.length - 1; ++i < this.points.length; j = i) {","            var ix = this.points[i].x;","            var iy = this.points[i].y;","            var jx = this.points[j].x;","            var jy = this.points[j].y;","            if (((iy <= y && y < jy) || (jy <= y && y < iy)) &&","                x < ((jx - ix) * (y - iy)) / (jy - iy) + ix) {","                inside = !inside;","            }","        }","        return inside;","    };","    return Polygon;","}());","","var BinaryHeap = /** @class */ (function () {","    function BinaryHeap(scoreFunction) {","        this.content = new Array();","        this.scoreFunction = scoreFunction;","    }","    BinaryHeap.prototype.push = function (element) {","        // Add the new element to the end of the array.","        this.content.push(element);","        // Allow it to sink down.","        this.sinkDown(this.content.length - 1);","    };","    BinaryHeap.prototype.pop = function () {","        // Store the first element so we can return it later.","        var result = this.content[0];","        // Get the element at the end of the array.","        var end = this.content.pop();","        if (!end)","            return;","        // If there are any elements left, put the end element at the","        // start, and let it bubble up.","        if (this.content.length > 0) {","            this.content[0] = end;","            this.bubbleUp(0);","        }","        return result;","    };","    BinaryHeap.prototype.remove = function (node) {","        var i = this.content.indexOf(node);","        // When it is found, the process seen in 'pop' is repeated","        // to fill up the hole.","        var end = this.content.pop();","        if (!end)","            return;","        if (i !== this.content.length - 1) {","            this.content[i] = end;","            if (this.scoreFunction(end) < this.scoreFunction(node)) {","                this.sinkDown(i);","            }","            else {","                this.bubbleUp(i);","            }","        }","    };","    BinaryHeap.prototype.size = function () {","        return this.content.length;","    };","    BinaryHeap.prototype.rescoreElement = function (node) {","        this.sinkDown(this.content.indexOf(node));","    };","    BinaryHeap.prototype.sinkDown = function (n) {","        // Fetch the element that has to be sunk.","        var element = this.content[n];","        // When at 0, an element can not sink any further.","        while (n > 0) {","            // Compute the parent element's index, and fetch it.","            var parentN = ((n + 1) >> 1) - 1;","            var parent = this.content[parentN];","            // Swap the elements if the parent is greater.","            if (this.scoreFunction(element) < this.scoreFunction(parent)) {","                this.content[parentN] = element;","                this.content[n] = parent;","                // Update 'n' to continue at the new position.","                n = parentN;","            }","            // Found a parent that is less, no need to sink any further.","            else {","                break;","            }","        }","    };","    BinaryHeap.prototype.bubbleUp = function (n) {","        // Look up the target element and its score.","        var length = this.content.length;","        var element = this.content[n];","        var elemScore = this.scoreFunction(element);","        while (true) {","            // Compute the indices of the child elements.","            var child2N = (n + 1) << 1;","            var child1N = child2N - 1;","            // This is used to store the new position of the element, if any.","            var swap = null;","            var child1Score = 0;","            // If the first child exists (is inside the array)...","            if (child1N < length) {","                // Look it up and compute its score.","                var child1 = this.content[child1N];","                child1Score = this.scoreFunction(child1);","                // If the score is less than our element's, we need to swap.","                if (child1Score < elemScore) {","                    swap = child1N;","                }","            }","            // Do the same checks for the other child.","            if (child2N < length) {","                var child2 = this.content[child2N];","                var child2Score = this.scoreFunction(child2);","                if (child2Score < (swap === null ? elemScore : child1Score)) {","                    swap = child2N;","                }","            }","            // If the element needs to be moved, swap it, and continue.","            if (swap !== null) {","                this.content[n] = this.content[swap];","                this.content[swap] = element;","                n = swap;","            }","            // Otherwise, we are done.","            else {","                break;","            }","        }","    };","    return BinaryHeap;","}());","","// The following implementation of the A* algorithm is from:","var AStar = /** @class */ (function () {","    function AStar() {","    }","    /**","     * Perform an A* Search on a graph given a start and end node.","     * @param {Graph} graph","     * @param {GridNode} start","     * @param {GridNode} end","     * @param {Object} [options]","     * @param {bool} [options.closest] Specifies whether to return the","     path to the closest node if the target is unreachable.","    * @param {Function} [options.heuristic] Heuristic function (see","    *          astar.heuristics).","    */","    AStar.prototype.search = function (graph, start, end, ","    // See list of heuristics: http://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html","    heuristic, closest) {","        if (closest === void 0) { closest = false; }","        graph.cleanDirty();","        var openHeap = this.getHeap();","        var closestNode = start; // set the start node to be the closest if required","        start.h = heuristic(start, end);","        graph.markDirty(start);","        openHeap.push(start);","        while (openHeap.size() > 0) {","            // Grab the lowest f(x) to process next.  Heap keeps this sorted for us.","            var currentNode = openHeap.pop();","            // never happen","            if (!currentNode)","                return [];","            // End case -- result has been found, return the traced path.","            if (currentNode === end) {","                return this.pathTo(currentNode);","            }","            // Normal case -- move currentNode from open to closed, process each of its neighbors.","            currentNode.closed = true;","            // Find all neighbors for the current node.","            var neighbors = graph.neighbors(currentNode);","            for (var i = 0, il = neighbors.length; i < il; ++i) {","                var neighbor = neighbors[i];","                if (neighbor.closed || neighbor.isWall()) {","                    // Not a valid node to process, skip to next neighbor.","                    continue;","                }","                // The g score is the shortest distance from start to current node.","                // We need to check if the path we have arrived at this neighbor is the shortest one we have seen yet.","                var gScore = currentNode.g + neighbor.getCost(currentNode);","                var beenVisited = neighbor.visited;","                if (!beenVisited || gScore < neighbor.g) {","                    // Found an optimal (so far) path to this node.  Take score for node to see how good it is.","                    neighbor.visited = true;","                    neighbor.parent = currentNode;","                    neighbor.h = neighbor.h || heuristic(neighbor, end);","                    neighbor.g = gScore;","                    neighbor.f = neighbor.g + neighbor.h;","                    graph.markDirty(neighbor);","                    if (closest) {","                        // If the neighbor is closer than the current closestNode or if it's equally close but has","                        // a cheaper path than the current closest node then it becomes the closest node","                        if (neighbor.h < closestNode.h ||","                            (neighbor.h === closestNode.h && neighbor.g < closestNode.g)) {","                            closestNode = neighbor;","                        }","                    }","                    if (!beenVisited) {","                        // Pushing to heap will put it in proper place based on the 'f' value.","                        openHeap.push(neighbor);","                    }","                    else {","                        // Already seen the node, but since it has been rescored we need to reorder it in the heap","                        openHeap.rescoreElement(neighbor);","                    }","                }","            }","        }","        if (closest) {","            return this.pathTo(closestNode);","        }","        // No result was found - empty array signifies failure to find path.","        return [];","    };","    AStar.prototype.pathTo = function (node) {","        var curr = node;","        var path = new Array();","        while (curr.parent) {","            path.unshift(curr);","            curr = curr.parent;","        }","        return path;","    };","    AStar.prototype.getHeap = function () {","        return new BinaryHeap(function (node) {","            return node.f;","        });","    };","    return AStar;","}());","","/**"," * The `NavMesh` class is the workhorse that represents a navigation mesh built from a series of"," * polygons. Once built, the mesh can be asked for a path from one point to another point. Some"," * internal terminology usage:"," * - neighbor: a polygon that shares part of an edge with another polygon"," * - portal: when two neighbor's have edges that overlap, the portal is the overlapping line segment"," * - channel: the path of polygons from starting point to end point"," * - pull the string: run the funnel algorithm on the channel so that the path hugs the edges of the"," *   channel. Equivalent to having a string snaking through a hallway and then pulling it taut."," */","var NavMesh = /** @class */ (function () {","    /**","     * @param meshPolygonPoints Array where each element is an array of point-like objects that","     * defines a polygon.","     * @param meshShrinkAmount The amount (in pixels) that the navmesh has been shrunk around","     * obstacles (a.k.a the amount obstacles have been expanded).","     */","    function NavMesh(meshPolygonPoints, meshShrinkAmount) {","        if (meshShrinkAmount === void 0) { meshShrinkAmount = 0; }","        this.meshShrinkAmount = meshShrinkAmount;","        // Convert the PolyPoints[] into NavPoly instances.","        this.navPolygons = meshPolygonPoints.map(function (polyPoints, i) { return new NavPoly(i, new Polygon(polyPoints)); });","        this.calculateNeighbors();","        // Astar graph of connections between polygons","        this.graph = new NavGraph(this.navPolygons);","    }","    /**","     * Get the NavPolys that are in this navmesh.","     */","    NavMesh.prototype.getPolygons = function () {","        return this.navPolygons;","    };","    /**","     * Cleanup method to remove references.","     */","    NavMesh.prototype.destroy = function () {","        this.graph.destroy();","        for (var _i = 0, _a = this.navPolygons; _i < _a.length; _i++) {","            var poly = _a[_i];","            poly.destroy();","        }","        this.navPolygons = [];","    };","    /**","     * Find if the given point is within any of the polygons in the mesh.","     * @param point","     */","    NavMesh.prototype.isPointInMesh = function (point) {","        return this.navPolygons.some(function (navPoly) { return navPoly.contains(point); });","    };","    /**","     * Find the closest point in the mesh to the given point. If the point is already in the mesh,","     * this will give you that point. If the point is outside of the mesh, this will attempt to","     * project this point into the mesh (up to the given maxAllowableDist). This returns an object","     * with:","     * - distance - from the given point to the mesh","     * - polygon - the one the point is closest to, or null","     * - point - the point inside the mesh, or null","     * @param point","     * @param maxAllowableDist","     */","    NavMesh.prototype.findClosestMeshPoint = function (point, maxAllowableDist) {","        if (maxAllowableDist === void 0) { maxAllowableDist = Number.POSITIVE_INFINITY; }","        var minDistance = maxAllowableDist;","        var closestPoly = null;","        var pointOnClosestPoly = null;","        for (var _i = 0, _a = this.navPolygons; _i < _a.length; _i++) {","            var navPoly = _a[_i];","            // If we are inside a poly, we've got the closest.","            if (navPoly.contains(point)) {","                minDistance = 0;","                closestPoly = navPoly;","                pointOnClosestPoly = point;","                break;","            }","            // Is the poly close enough to warrant a more accurate check? Point is definitely outside of","            // the polygon. Distance - Radius is the smallest possible distance to an edge of the poly.","            // This will underestimate distance, but that's perfectly fine.","            var r = navPoly.boundingRadius;","            var d = navPoly.centroid.distance(point);","            if (d - r < minDistance) {","                var result = this.projectPointToPolygon(point, navPoly);","                if (result.distance < minDistance) {","                    minDistance = result.distance;","                    closestPoly = navPoly;","                    pointOnClosestPoly = result.point;","                }","            }","        }","        return { distance: minDistance, polygon: closestPoly, point: pointOnClosestPoly };","    };","    /**","     * Find a path from the start point to the end point using this nav mesh.","     * @param startPoint A point-like object in the form {x, y}","     * @param endPoint A point-like object in the form {x, y}","     * @returns An array of points if a path is found, or null if no path","     */","    NavMesh.prototype.findPath = function (startPoint, endPoint) {","        var startPoly = null;","        var endPoly = null;","        var startDistance = Number.MAX_VALUE;","        var endDistance = Number.MAX_VALUE;","        var d, r;","        var startVector = new Vector2(startPoint.x, startPoint.y);","        var endVector = new Vector2(endPoint.x, endPoint.y);","        // Find the closest poly for the starting and ending point","        for (var _i = 0, _a = this.navPolygons; _i < _a.length; _i++) {","            var navPoly = _a[_i];","            r = navPoly.boundingRadius;","            // Start","            d = navPoly.centroid.distance(startVector);","            if (d <= startDistance && d <= r && navPoly.contains(startVector)) {","                startPoly = navPoly;","                startDistance = d;","            }","            // End","            d = navPoly.centroid.distance(endVector);","            if (d <= endDistance && d <= r && navPoly.contains(endVector)) {","                endPoly = navPoly;","                endDistance = d;","            }","        }","        // If the end point wasn't inside a polygon, run a more liberal check that allows a point","        // to be within meshShrinkAmount radius of a polygon","        if (!endPoly && this.meshShrinkAmount > 0) {","            for (var _b = 0, _c = this.navPolygons; _b < _c.length; _b++) {","                var navPoly = _c[_b];","                r = navPoly.boundingRadius + this.meshShrinkAmount;","                d = navPoly.centroid.distance(endVector);","                if (d <= r) {","                    var distance = this.projectPointToPolygon(endVector, navPoly).distance;","                    if (distance <= this.meshShrinkAmount && distance < endDistance) {","                        endPoly = navPoly;","                        endDistance = distance;","                    }","                }","            }","        }","        // No matching polygons locations for the end, so no path found","        // because start point is valid normally, check end point first","        if (!endPoly)","            return null;","        // Same check as above, but for the start point","        if (!startPoly && this.meshShrinkAmount > 0) {","            for (var _d = 0, _e = this.navPolygons; _d < _e.length; _d++) {","                var navPoly = _e[_d];","                // Check if point is within bounding circle to avoid extra projection calculations","                r = navPoly.boundingRadius + this.meshShrinkAmount;","                d = navPoly.centroid.distance(startVector);","                if (d <= r) {","                    // Check if projected point is within range of a polygon and is closer than the","                    // previous point","                    var distance = this.projectPointToPolygon(startVector, navPoly).distance;","                    if (distance <= this.meshShrinkAmount && distance < startDistance) {","                        startPoly = navPoly;","                        startDistance = distance;","                    }","                }","            }","        }","        // No matching polygons locations for the start, so no path found","        if (!startPoly)","            return null;","        // If the start and end polygons are the same, return a direct path","        if (startPoly === endPoly)","            return [startVector, endVector];","        // Search!","        var astarPath = new AStar().search(this.graph, startPoly, endPoly, this.graph.navHeuristic);","        // While the start and end polygons may be valid, no path between them","        if (astarPath.length === 0)","            return null;","        // jsastar drops the first point from the path, but the funnel algorithm needs it","        astarPath.unshift(startPoly);","        // We have a path, so now time for the funnel algorithm","        var channel = new Channel();","        channel.push(startVector);","        for (var i = 0; i < astarPath.length - 1; i++) {","            var navPolygon = astarPath[i];","            var nextNavPolygon = astarPath[i + 1];","            // Find the portal","            var portal = null;","            for (var i_1 = 0; i_1 < navPolygon.neighbors.length; i_1++) {","                if (navPolygon.neighbors[i_1].id === nextNavPolygon.id) {","                    portal = navPolygon.portals[i_1];","                }","            }","            if (!portal)","                throw new Error(\"Path was supposed to be found, but portal is missing!\");","            // Push the portal vertices into the channel","            channel.push(portal.start, portal.end);","        }","        channel.push(endVector);","        // Pull a string along the channel to run the funnel","        channel.stringPull();","        // Clone path, excluding duplicates","        var lastPoint = null;","        var phaserPath = new Array();","        for (var _f = 0, _g = channel.path; _f < _g.length; _f++) {","            var p = _g[_f];","            var newPoint = p.clone();","            if (!lastPoint || !newPoint.equals(lastPoint))","                phaserPath.push(newPoint);","            lastPoint = newPoint;","        }","        return phaserPath;","    };","    NavMesh.prototype.calculateNeighbors = function () {","        // Fill out the neighbor information for each navpoly","        for (var i = 0; i < this.navPolygons.length; i++) {","            var navPoly = this.navPolygons[i];","            for (var j = i + 1; j < this.navPolygons.length; j++) {","                var otherNavPoly = this.navPolygons[j];","                // Check if the other navpoly is within range to touch","                var d = navPoly.centroid.distance(otherNavPoly.centroid);","                if (d > navPoly.boundingRadius + otherNavPoly.boundingRadius)","                    continue;","                // The are in range, so check each edge pairing","                for (var _i = 0, _a = navPoly.edges; _i < _a.length; _i++) {","                    var edge = _a[_i];","                    for (var _b = 0, _c = otherNavPoly.edges; _b < _c.length; _b++) {","                        var otherEdge = _c[_b];","                        // If edges aren't collinear, not an option for connecting navpolys","                        if (!areCollinear(edge, otherEdge))","                            continue;","                        // If they are collinear, check if they overlap","                        var overlap = this.getSegmentOverlap(edge, otherEdge);","                        if (!overlap)","                            continue;","                        // Connections are symmetric!","                        navPoly.neighbors.push(otherNavPoly);","                        otherNavPoly.neighbors.push(navPoly);","                        // Calculate the portal between the two polygons - this needs to be in","                        // counter-clockwise order, relative to each polygon","                        var p1 = overlap[0], p2 = overlap[1];","                        var edgeStartAngle = navPoly.centroid.angle(edge.start);","                        var a1 = navPoly.centroid.angle(overlap[0]);","                        var a2 = navPoly.centroid.angle(overlap[1]);","                        var d1 = angleDifference(edgeStartAngle, a1);","                        var d2 = angleDifference(edgeStartAngle, a2);","                        if (d1 < d2) {","                            navPoly.portals.push(new Line(p1.x, p1.y, p2.x, p2.y));","                        }","                        else {","                            navPoly.portals.push(new Line(p2.x, p2.y, p1.x, p1.y));","                        }","                        edgeStartAngle = otherNavPoly.centroid.angle(otherEdge.start);","                        a1 = otherNavPoly.centroid.angle(overlap[0]);","                        a2 = otherNavPoly.centroid.angle(overlap[1]);","                        d1 = angleDifference(edgeStartAngle, a1);","                        d2 = angleDifference(edgeStartAngle, a2);","                        if (d1 < d2) {","                            otherNavPoly.portals.push(new Line(p1.x, p1.y, p2.x, p2.y));","                        }","                        else {","                            otherNavPoly.portals.push(new Line(p2.x, p2.y, p1.x, p1.y));","                        }","                        // Two convex polygons shouldn't be connected more than once! (Unless","                        // there are unnecessary vertices...)","                    }","                }","            }","        }","    };","    // Check two collinear line segments to see if they overlap by sorting the points.","    // Algorithm source: http://stackoverflow.com/a/17152247","    NavMesh.prototype.getSegmentOverlap = function (line1, line2) {","        var points = [","            { line: line1, point: line1.start },","            { line: line1, point: line1.end },","            { line: line2, point: line2.start },","            { line: line2, point: line2.end },","        ];","        points.sort(function (a, b) {","            if (a.point.x < b.point.x)","                return -1;","            else if (a.point.x > b.point.x)","                return 1;","            else {","                if (a.point.y < b.point.y)","                    return -1;","                else if (a.point.y > b.point.y)","                    return 1;","                else","                    return 0;","            }","        });","        // If the first two points in the array come from the same line, no overlap","        var noOverlap = points[0].line === points[1].line;","        // If the two middle points in the array are the same coordinates, then there is a","        // single point of overlap.","        var singlePointOverlap = points[1].point.equals(points[2].point);","        if (noOverlap || singlePointOverlap)","            return null;","        else","            return [points[1].point, points[2].point];","    };","    /**","     * Project a point onto a polygon in the shortest distance possible.","     *","     * @param {Phaser.Point} point The point to project","     * @param {NavPoly} navPoly The navigation polygon to test against","     * @returns {{point: Phaser.Point, distance: number}}","     */","    NavMesh.prototype.projectPointToPolygon = function (point, navPoly) {","        var closestProjection = null;","        var closestDistance = Number.MAX_VALUE;","        for (var _i = 0, _a = navPoly.edges; _i < _a.length; _i++) {","            var edge = _a[_i];","            var projectedPoint = projectPointToEdge(point, edge);","            var d = point.distance(projectedPoint);","            if (closestProjection === null || d < closestDistance) {","                closestDistance = d;","                closestProjection = projectedPoint;","            }","        }","        return { point: closestProjection, distance: closestDistance };","    };","    return NavMesh;","}());","","/**"," * This implementation is strongly inspired from CritterAI class \"Geometry\"."," */","var Geometry = /** @class */ (function () {","    function Geometry() {","    }","    /**","     * Returns TRUE if line segment AB intersects with line segment CD in any","     * manner. Either collinear or at a single point.","     * @param ax The x-value for point (ax, ay) in line segment AB.","     * @param ay The y-value for point (ax, ay) in line segment AB.","     * @param bx The x-value for point (bx, by) in line segment AB.","     * @param by The y-value for point (bx, by) in line segment AB.","     * @param cx The x-value for point (cx, cy) in line segment CD.","     * @param cy The y-value for point (cx, cy) in line segment CD.","     * @param dx The x-value for point (dx, dy) in line segment CD.","     * @param dy The y-value for point (dx, dy) in line segment CD.","     * @return TRUE if line segment AB intersects with line segment CD in any","     * manner.","     */","    Geometry.segmentsIntersect = function (ax, ay, bx, by, cx, cy, dx, dy) {","        // This is modified 2D line-line intersection/segment-segment","        // intersection test.","        var deltaABx = bx - ax;","        var deltaABy = by - ay;","        var deltaCAx = ax - cx;","        var deltaCAy = ay - cy;","        var deltaCDx = dx - cx;","        var deltaCDy = dy - cy;","        var numerator = deltaCAy * deltaCDx - deltaCAx * deltaCDy;","        var denominator = deltaABx * deltaCDy - deltaABy * deltaCDx;","        // Perform early exit tests.","        if (denominator === 0 && numerator !== 0) {","            // If numerator is zero, then the lines are colinear.","            // Since it isn't, then the lines must be parallel.","            return false;","        }","        // Lines intersect. But do the segments intersect?","        // Forcing float division on both of these via casting of the","        // denominator.","        var factorAB = numerator / denominator;","        var factorCD = (deltaCAy * deltaABx - deltaCAx * deltaABy) / denominator;","        // Determine the type of intersection","        if (factorAB >= 0.0 &&","            factorAB <= 1.0 &&","            factorCD >= 0.0 &&","            factorCD <= 1.0) {","            return true; // The two segments intersect.","        }","        // The lines intersect, but segments to not.","        return false;","    };","    /**","     * Returns the distance squared from the point to the line segment.","     *","     * Behavior is undefined if the the closest distance is outside the","     * line segment.","     *","     * @param px The x-value of point (px, py).","     * @param py The y-value of point (px, py)","     * @param ax The x-value of the line segment's vertex A.","     * @param ay The y-value of the line segment's vertex A.","     * @param bx The x-value of the line segment's vertex B.","     * @param by The y-value of the line segment's vertex B.","     * @return The distance squared from the point (px, py) to line segment AB.","     */","    Geometry.getPointSegmentDistanceSq = function (px, py, ax, ay, bx, by) {","        // Reference: http://local.wasp.uwa.edu.au/~pbourke/geometry/pointline/","        //","        // The goal of the algorithm is to find the point on line segment AB","        // that is closest to P and then calculate the distance between P","        // and that point.","        var deltaABx = bx - ax;","        var deltaABy = by - ay;","        var deltaAPx = px - ax;","        var deltaAPy = py - ay;","        var segmentABLengthSq = deltaABx * deltaABx + deltaABy * deltaABy;","        if (segmentABLengthSq === 0) {","            // AB is not a line segment. So just return","            // distanceSq from P to A","            return deltaAPx * deltaAPx + deltaAPy * deltaAPy;","        }","        var u = (deltaAPx * deltaABx + deltaAPy * deltaABy) / segmentABLengthSq;","        if (u < 0) {","            // Closest point on line AB is outside outside segment AB and","            // closer to A. So return distanceSq from P to A.","            return deltaAPx * deltaAPx + deltaAPy * deltaAPy;","        }","        else if (u > 1) {","            // Closest point on line AB is outside segment AB and closer to B.","            // So return distanceSq from P to B.","            return (px - bx) * (px - bx) + (py - by) * (py - by);","        }","        // Closest point on lineAB is inside segment AB. So find the exact","        // point on AB and calculate the distanceSq from it to P.","        // The calculation in parenthesis is the location of the point on","        // the line segment.","        var deltaX = ax + u * deltaABx - px;","        var deltaY = ay + u * deltaABy - py;","        return deltaX * deltaX + deltaY * deltaY;","    };","    return Geometry;","}());","","/**"," * A cell that holds data needed by the 1st steps of the NavMesh generation."," */","var RasterizationCell = /** @class */ (function () {","    function RasterizationCell(x, y) {","        /**","         * 0 means there is an obstacle in the cell.","         * See {@link RegionGenerator}","         */","        this.distanceToObstacle = Number.MAX_VALUE;","        this.regionID = RasterizationCell.NULL_REGION_ID;","        this.distanceToRegionCore = 0;","        /**","         * If a cell is connected to one or more external regions then the","         *  flag will be a 4 bit value where connections are recorded as","         *  follows:","         *  - bit1 = neighbor0","         *  - bit2 = neighbor1","         *  - bit3 = neighbor2","         *  - bit4 = neighbor3","         *  With the meaning of the bits as follows:","         *  - 0 = neighbor in same region.","         *  - 1 = neighbor not in same region (neighbor may be the obstacle","         *    region or a real region).","         *","         * See {@link ContourBuilder}","         */","        this.contourFlags = 0;","        this.x = x;","        this.y = y;","        this.clear();","    }","    RasterizationCell.prototype.clear = function () {","        this.distanceToObstacle = Number.MAX_VALUE;","        this.regionID = RasterizationCell.NULL_REGION_ID;","        this.distanceToRegionCore = 0;","        this.contourFlags = 0;","    };","    /** A cell that has not been assigned to any region yet */","    RasterizationCell.NULL_REGION_ID = 0;","    /**","     * A cell that contains an obstacle.","     *","     * The value is the same as NULL_REGION_ID because the cells that are","     * not assigned to any region at the end of the flooding algorithm are","     * the obstacle cells.","     */","    RasterizationCell.OBSTACLE_REGION_ID = 0;","    return RasterizationCell;","}());","","var RasterizationGrid = /** @class */ (function () {","    function RasterizationGrid(left, top, right, bottom, cellWidth, cellHeight) {","        this.regionCount = 0;","        this.cellWidth = cellWidth;","        this.cellHeight = cellHeight;","        this.originX = left - cellWidth;","        this.originY = top - cellHeight;","        var dimX = 2 + Math.ceil((right - left) / cellWidth);","        var dimY = 2 + Math.ceil((bottom - top) / cellHeight);","        this.cells = [];","        for (var y = 0; y < dimY; y++) {","            this.cells[y] = [];","            for (var x = 0; x < dimX; x++) {","                this.cells[y][x] = new RasterizationCell(x, y);","            }","        }","    }","    RasterizationGrid.prototype.clear = function () {","        for (var _i = 0, _a = this.cells; _i < _a.length; _i++) {","            var row = _a[_i];","            for (var _b = 0, row_1 = row; _b < row_1.length; _b++) {","                var cell = row_1[_b];","                cell.clear();","            }","        }","        this.regionCount = 0;","    };","    /**","     *","     * @param position the position on the scene","     * @param gridPosition the position on the grid","     * @returns the position on the grid","     */","    RasterizationGrid.prototype.convertToGridBasis = function (position, gridPosition) {","        gridPosition.x = (position.x - this.originX) / this.cellWidth;","        gridPosition.y = (position.y - this.originY) / this.cellHeight;","        return gridPosition;","    };","    /**","     *","     * @param gridPosition the position on the grid","     * @param position the position on the scene","     * @returns the position on the scene","     */","    RasterizationGrid.prototype.convertFromGridBasis = function (gridPosition, position) {","        position.x = gridPosition.x * this.cellWidth + this.originX;","        position.y = gridPosition.y * this.cellHeight + this.originY;","        return position;","    };","    RasterizationGrid.prototype.get = function (x, y) {","        return this.cells[y][x];","    };","    RasterizationGrid.prototype.getNeighbor = function (cell, direction) {","        var delta = RasterizationGrid.neighbor8Deltas[direction];","        return this.cells[cell.y + delta.y][cell.x + delta.x];","    };","    RasterizationGrid.prototype.dimY = function () {","        return this.cells.length;","    };","    RasterizationGrid.prototype.dimX = function () {","        var firstColumn = this.cells[0];","        return firstColumn ? firstColumn.length : 0;","    };","    RasterizationGrid.prototype.obstacleDistanceMax = function () {","        var max = 0;","        for (var _i = 0, _a = this.cells; _i < _a.length; _i++) {","            var cellRow = _a[_i];","            for (var _b = 0, cellRow_1 = cellRow; _b < cellRow_1.length; _b++) {","                var cell = cellRow_1[_b];","                if (cell.distanceToObstacle > max) {","                    max = cell.distanceToObstacle;","                }","            }","        }","        return max;","    };","    RasterizationGrid.neighbor4Deltas = [","        { x: -1, y: 0 },","        { x: 0, y: 1 },","        { x: 1, y: 0 },","        { x: 0, y: -1 },","    ];","    RasterizationGrid.neighbor8Deltas = [","        { x: -1, y: 0 },","        { x: 0, y: 1 },","        { x: 1, y: 0 },","        { x: 0, y: -1 },","        { x: 1, y: 1 },","        { x: -1, y: 1 },","        { x: -1, y: -1 },","        { x: 1, y: -1 },","    ];","    return RasterizationGrid;","}());","","/**"," * Builds a set of contours from the region information contained in"," * {@link RasterizationCell}. It does this by locating and \"walking\" the edges."," *"," * This implementation is strongly inspired from CritterAI class \"ContourSetBuilder\"."," * http://www.critterai.org/projects/nmgen_study/contourgen.html"," */","var ContourBuilder = /** @class */ (function () {","    function ContourBuilder() {","        // These are working lists whose content changes with each iteration","        // of the up coming loop. They represent the detailed and simple","        // contour vertices.","        // Initial sizing is arbitrary.","        this.workingRawVertices = new Array(256);","        this.workingSimplifiedVertices = new Array(64);","    }","    /**","     * Generates a contour set from the provided {@link RasterizationGrid}","     *","     * The provided field is expected to contain region information.","     * Behavior is undefined if the provided field is malformed or incomplete.","     *","     * This operation overwrites the flag fields for all cells in the","     * provided field. So the flags must be saved and restored if they are","     * important.","     *","     * @param grid A fully generated field.","     * @param threshold The maximum distance (in cells) the edge of the contour","     * may deviate from the source geometry when the rastered obstacles are","     * vectorized.","     *","     * Setting it to:","     * - 1 ensure that an aliased edge won't be split to more edges.","     * - more that 1 will reduce the number of edges but the obstacles edges","     *   will be followed with less accuracy.","     * - less that 1 might be more accurate but it may try to follow the","     *   aliasing and be a lot less accurate.","     *","     * Values under 1 can be useful in specific cases:","     * - when edges are horizontal or vertical, there is no aliasing so value","     *   near 0 can do better results.","     * - when edges are 45 multiples, aliased vertex won't be farther than","     *   sqrt(2)/2 so values over 0.71 should give good results but not","     *   necessarily better than 1.","     *","     * @return The contours generated from the field.","     */","    ContourBuilder.prototype.buildContours = function (grid, threshold) {","        var contours = new Array(grid.regionCount);","        contours.length = 0;","        var contoursByRegion = new Array(grid.regionCount);","        var discardedContours = 0;","        //  Set the flags on all cells in non-obstacle regions to indicate which","        //  edges are connected to external regions.","        //","        //  Reference: Neighbor search and nomenclature.","        //  http://www.critterai.org/projects/nmgen_study/heightfields.html#nsearch","        //","        //  If a cell has no connections to external regions or is","        //  completely surrounded by other regions (a single cell island),","        //  its flag will be zero.","        //","        //  If a cell is connected to one or more external regions then the","        //  flag will be a 4 bit value where connections are recorded as","        //  follows:","        //      bit1 = neighbor0","        //      bit2 = neighbor1","        //      bit3 = neighbor2","        //      bit4 = neighbor3","        //  With the meaning of the bits as follows:","        //      0 = neighbor in same region.","        //      1 = neighbor not in same region (neighbor may be the obstacle","        //      region or a real region).","        for (var y = 1; y < grid.dimY() - 1; y++) {","            for (var x = 1; x < grid.dimX() - 1; x++) {","                var cell = grid.get(x, y);","                // Note:  This algorithm first sets the flag bits such that","                // 1 = \"neighbor is in the same region\". At the end it inverts","                // the bits so flags are as expected.","                // Default to \"not connected to any external region\".","                cell.contourFlags = 0;","                if (cell.regionID === RasterizationCell.OBSTACLE_REGION_ID)","                    // Don't care about cells in the obstacle region.","                    continue;","                for (var direction = 0; direction < RasterizationGrid.neighbor4Deltas.length; direction++) {","                    var delta = RasterizationGrid.neighbor4Deltas[direction];","                    var neighbor = grid.get(cell.x + delta.x, cell.y + delta.y);","                    if (cell.regionID === neighbor.regionID) {","                        // Neighbor is in same region as this cell.","                        // Set the bit for this neighbor to 1 (Will be inverted later).","                        cell.contourFlags |= 1 << direction;","                    }","                }","                // Invert the bits so a bit value of 1 indicates neighbor NOT in","                // same region.","                cell.contourFlags ^= 0xf;","                if (cell.contourFlags === 0xf) {","                    // This is an island cell (All neighbors are from other regions)","                    // Get rid of flags.","                    cell.contourFlags = 0;","                    console.warn(\"Discarded contour: Island cell. Can't form  a contour. Region: \" +","                        cell.regionID);","                    discardedContours++;","                }","            }","        }","        // Loop through all cells looking for cells on the edge of a region.","        //","        // At this point, only cells with flags != 0 are edge cells that","        // are part of a region contour.","        //","        // The process of building a contour will clear the flags on all cells","        // that make up the contour to ensure they are only processed once.","        for (var y = 1; y < grid.dimY() - 1; y++) {","            for (var x = 1; x < grid.dimX() - 1; x++) {","                var cell = grid.get(x, y);","                if (cell.regionID === RasterizationCell.OBSTACLE_REGION_ID ||","                    cell.contourFlags === 0) {","                    // cell is either: Part of the obstacle region, does not","                    // represent an edge cell, or was already processed during","                    // an earlier iteration.","                    continue;","                }","                this.workingRawVertices.length = 0;","                this.workingSimplifiedVertices.length = 0;","                // The cell is part of an unprocessed region's contour.","                // Locate a direction of the cell's edge which points toward","                // another region (there is at least one).","                var startDirection = 0;","                while ((cell.contourFlags & (1 << startDirection)) === 0) {","                    startDirection++;","                }","                // We now have a cell that is part of a contour and a direction","                // that points to a different region (obstacle or real).","                // Build the contour.","                this.buildRawContours(grid, cell, startDirection, this.workingRawVertices);","                // Perform post processing on the contour in order to","                // create the final, simplified contour.","                this.generateSimplifiedContour(cell.regionID, this.workingRawVertices, this.workingSimplifiedVertices, threshold);","                // The CritterAI implementation filters polygons with less than","                // 3 vertices, but they are needed to filter vertices in the middle","                // (not on an obstacle region border).","                var contour = Array.from(this.workingSimplifiedVertices);","                contours.push(contour);","                contoursByRegion[cell.regionID] = contour;","            }","        }","        if (contours.length + discardedContours !== grid.regionCount - 1) {","            // The only valid state is one contour per region.","            //","            // The only time this should occur is if an invalid contour","            // was formed or if a region resulted in multiple","            // contours (bad region data).","            //","            // IMPORTANT: While a mismatch may not be a fatal error,","            // it should be addressed since it can result in odd,","            // hard to spot anomalies later in the pipeline.","            //","            // A known cause is if a region fully encompasses another","            // region. In such a case, two contours will be formed.","            // The normal outer contour and an inner contour.","            // The CleanNullRegionBorders algorithm protects","            // against internal encompassed obstacle regions.","            console.error(\"Contour generation failed: Detected contours does\" +","                \" not match the number of regions. Regions: \" +","                (grid.regionCount - 1) +","                \", Detected contours: \" +","                (contours.length + discardedContours) +","                \" (Actual: \" +","                contours.length +","                \", Discarded: \" +","                discardedContours +","                \")\");","            // The CritterAI implementation has more detailed logs.","            // They can be interesting for debugging.","        }","        this.filterNonObstacleVertices(contours, contoursByRegion);","        return contours;","    };","    /**","     * Search vertices that are not shared with the obstacle region and","     * remove them.","     *","     * Some contours will have no vertex left.","     *","     * @param contours","     * @param contoursByRegion Some regions may have been discarded","     * so contours index can't be used.","     */","    ContourBuilder.prototype.filterNonObstacleVertices = function (contours, contoursByRegion) {","        // This was not part of the CritterAI implementation.","        // The removed vertex is merged on the nearest of the edges other extremity","        // that is on an obstacle border.","        var commonVertexContours = new Array(5);","        var commonVertexIndexes = new Array(5);","        // Each pass only filter vertex that have an edge other extremity on an obstacle.","        // Vertex depth (in number of edges to reach an obstacle) is reduces by","        // at least one by each pass.","        var movedAnyVertex = false;","        do {","            movedAnyVertex = false;","            for (var _i = 0, contours_1 = contours; _i < contours_1.length; _i++) {","                var contour = contours_1[_i];","                for (var vertexIndex = 0; vertexIndex < contour.length; vertexIndex++) {","                    var vertex = contour[vertexIndex];","                    var nextVertex = contour[(vertexIndex + 1) % contour.length];","                    if (vertex.region !== RasterizationCell.OBSTACLE_REGION_ID &&","                        nextVertex.region !== RasterizationCell.OBSTACLE_REGION_ID) {","                        // This is a vertex in the middle. It must be removed.","                        // Search the contours around the vertex.","                        //","                        // Typically a contour point to its neighbor and it form a cycle.","                        //","                        //   \\ C /","                        //    \\ /","                        //  A  |  B","                        //     |","                        //","                        // C -> B -> A -> C","                        //","                        // There can be more than 3 contours even if it's rare.","                        commonVertexContours.length = 0;","                        commonVertexIndexes.length = 0;","                        commonVertexContours.push(contour);","                        commonVertexIndexes.push(vertexIndex);","                        var errorFound = false;","                        var commonVertex = vertex;","                        do {","                            var neighborContour = contoursByRegion[commonVertex.region];","                            if (!neighborContour) {","                                errorFound = true;","                                if (commonVertex.region !== RasterizationCell.OBSTACLE_REGION_ID) {","                                    console.warn(\"contour already discarded: \" + commonVertex.region);","                                }","                                break;","                            }","                            var foundVertex = false;","                            for (var neighborVertexIndex = 0; neighborVertexIndex < neighborContour.length; neighborVertexIndex++) {","                                var neighborVertex = neighborContour[neighborVertexIndex];","                                if (neighborVertex.x === commonVertex.x &&","                                    neighborVertex.y === commonVertex.y) {","                                    commonVertexContours.push(neighborContour);","                                    commonVertexIndexes.push(neighborVertexIndex);","                                    commonVertex = neighborVertex;","                                    foundVertex = true;","                                    break;","                                }","                            }","                            if (!foundVertex) {","                                errorFound = true;","                                console.error(\"Can't find a common vertex with a neighbor contour. There is probably a superposition.\");","                                break;","                            }","                        } while (commonVertex !== vertex);","                        if (errorFound) {","                            continue;","                        }","                        if (commonVertexContours.length < 3) {","                            console.error(\"The vertex is shared by only \" + commonVertexContours.length + \" regions.\");","                        }","                        var shorterEdgeContourIndex = -1;","                        var edgeLengthMin = Number.MAX_VALUE;","                        for (var index = 0; index < commonVertexContours.length; index++) {","                            var vertexContour = commonVertexContours[index];","                            var vertexIndex_1 = commonVertexIndexes[index];","                            var previousVertex = vertexContour[(vertexIndex_1 - 1 + vertexContour.length) %","                                vertexContour.length];","                            if (previousVertex.region === RasterizationCell.OBSTACLE_REGION_ID) {","                                var deltaX = previousVertex.x - vertex.x;","                                var deltaY = previousVertex.y - vertex.y;","                                var lengthSq = deltaX * deltaX + deltaY * deltaY;","                                if (lengthSq < edgeLengthMin) {","                                    edgeLengthMin = lengthSq;","                                    shorterEdgeContourIndex = index;","                                }","                            }","                        }","                        if (shorterEdgeContourIndex === -1) {","                            // A vertex has no neighbor on an obstacle.","                            // It will be solved in next iterations.","                            continue;","                        }","                        // Merge the vertex on the other extremity of the smallest of the 3 edges.","                        //","                        //   \\ C /","                        //    \\ /","                        //  A  |  B","                        //     |","                        //","                        // - the shortest edge is between A and B","                        // - the Y will become a V","                        // - vertices are store clockwise","                        // - there can be more than one C (it's rare)","                        // This is B","                        var shorterEdgeContour = commonVertexContours[shorterEdgeContourIndex];","                        var shorterEdgeVertexIndex = commonVertexIndexes[shorterEdgeContourIndex];","                        var shorterEdgeExtremityVertex = shorterEdgeContour[(shorterEdgeVertexIndex - 1 + shorterEdgeContour.length) %","                            shorterEdgeContour.length];","                        // This is A","                        var shorterEdgeOtherContourIndex = (shorterEdgeContourIndex + 1) % commonVertexContours.length;","                        var shorterEdgeOtherContour = commonVertexContours[shorterEdgeOtherContourIndex];","                        var shorterEdgeOtherVertexIndex = commonVertexIndexes[shorterEdgeOtherContourIndex];","                        for (var index = 0; index < commonVertexContours.length; index++) {","                            if (index === shorterEdgeContourIndex ||","                                index === shorterEdgeOtherContourIndex) {","                                continue;","                            }","                            // These are C","                            var commonVertexContour = commonVertexContours[index];","                            var commonVertexIndex = commonVertexIndexes[index];","                            // Move the vertex to an obstacle border","                            var movedVertex = commonVertexContour[commonVertexIndex];","                            movedVertex.x = shorterEdgeExtremityVertex.x;","                            movedVertex.y = shorterEdgeExtremityVertex.y;","                            movedVertex.region = RasterizationCell.NULL_REGION_ID;","                        }","                        // There is no more border between A and B,","                        // update the region from B to C.","                        shorterEdgeOtherContour[(shorterEdgeOtherVertexIndex + 1) % shorterEdgeOtherContour.length].region =","                            shorterEdgeOtherContour[shorterEdgeOtherVertexIndex].region;","                        // Remove in A and B the vertex that's been move in C.","                        shorterEdgeContour.splice(shorterEdgeVertexIndex, 1);","                        shorterEdgeOtherContour.splice(shorterEdgeOtherVertexIndex, 1);","                        movedAnyVertex = true;","                    }","                }","            }","        } while (movedAnyVertex);","        // Clean the polygons from identical vertices.","        //","        // This can happen with 2 vertices regions.","        // 2 edges are superposed and there extremity is the same.","        // One is move over the other.","        // I could observe this with a region between 2 regions","        // where one of one of these 2 regions were also encompassed.","        // A bit like a rainbow, 2 big regions: the land, the sky","        // and 2 regions for the colors.","        //","        // The vertex can't be removed during the process because","        // they hold data used by other merging.","        //","        // Some contour will have no vertex left.","        // It more efficient to let the next step ignore them.","        for (var _a = 0, contours_2 = contours; _a < contours_2.length; _a++) {","            var contour = contours_2[_a];","            for (var vertexIndex = 0; vertexIndex < contour.length; vertexIndex++) {","                var vertex = contour[vertexIndex];","                var nextVertexIndex = (vertexIndex + 1) % contour.length;","                var nextVertex = contour[nextVertexIndex];","                if (vertex.x === nextVertex.x && vertex.y === nextVertex.y) {","                    contour.splice(nextVertexIndex, 1);","                    vertexIndex--;","                }","            }","        }","    };","    /**","     * Walk around the edge of this cell's region gathering vertices that","     * represent the corners of each cell on the sides that are external facing.","     *","     * There will be two or three vertices for each edge cell:","     * Two for cells that don't represent a change in edge direction. Three","     * for cells that represent a change in edge direction.","     *","     * The output array will contain vertices ordered as follows:","     * (x, y, z, regionID) where regionID is the region (obstacle or real) that","     * this vertex is considered to be connected to.","     *","     * WARNING: Only run this operation on cells that are already known","     * to be on a region edge. The direction must also be pointing to a","     * valid edge. Otherwise behavior will be undefined.","     *","     * @param grid the grid of cells","     * @param startCell A cell that is known to be on the edge of a region","     * (part of a region contour).","     * @param startDirection The direction of the edge of the cell that is","     * known to point","     * across the region edge.","     * @param outContourVertices The list of vertices that represent the edge","     * of the region.","     */","    ContourBuilder.prototype.buildRawContours = function (grid, startCell, startDirection, outContourVertices) {","        // Flaw in Algorithm:","        //","        // This method of contour generation can result in an inappropriate","        // impassable seam between two adjacent regions in the following case:","        //","        // 1. One region connects to another region on two sides in an","        // uninterrupted manner (visualize one region wrapping in an L","        // shape around the corner of another).","        // 2. At the corner shared by the two regions, a change in height","        // occurs.","        //","        // In this case, the two regions should share a corner vertex","        // (an obtuse corner vertex for one region and an acute corner","        // vertex for the other region).","        //","        // In reality, though this algorithm will select the same (x, z)","        // coordinates for each region's corner vertex, the vertex heights","        // may differ, eventually resulting in an impassable seam.","        // It is a bit hard to describe the stepping portion of this algorithm.","        // One way to visualize it is to think of a robot sitting on the","        // floor facing a known wall. It then does the following to skirt","        // the wall:","        // 1. If there is a wall in front of it, turn clockwise in 90 degrees","        //    increments until it finds the wall is gone.","        // 2. Move forward one step.","        // 3. Turn counter-clockwise by 90 degrees.","        // 4. Repeat from step 1 until it finds itself at its original","        //    location facing its original direction.","        //","        // See also: http://www.critterai.org/projects/nmgen_study/contourgen.html#robotwalk","        var cell = startCell;","        var direction = startDirection;","        var loopCount = 0;","        do {","            // Note: The design of this loop is such that the cell variable","            // will always reference an edge cell from the same region as","            // the start cell.","            if ((cell.contourFlags & (1 << direction)) !== 0) {","                // The current direction is pointing toward an edge.","                // Get this edge's vertex.","                var delta = ContourBuilder.leftVertexOfFacingCellBorderDeltas[direction];","                var neighbor = grid.get(cell.x + RasterizationGrid.neighbor4Deltas[direction].x, cell.y + RasterizationGrid.neighbor4Deltas[direction].y);","                outContourVertices.push({","                    x: cell.x + delta.x,","                    y: cell.y + delta.y,","                    region: neighbor.regionID,","                });","                // Remove the flag for this edge. We never need to consider","                // it again since we have a vertex for this edge.","                cell.contourFlags &= ~(1 << direction);","                // Rotate in clockwise direction.","                direction = (direction + 1) & 0x3;","            }","            else {","                // The current direction does not point to an edge. So it","                // must point to a neighbor cell in the same region as the","                // current cell. Move to the neighbor and swing the search","                // direction back one increment (counterclockwise).","                // By moving the direction back one increment we guarantee we","                // don't miss any edges.","                var neighbor = grid.get(cell.x + RasterizationGrid.neighbor4Deltas[direction].x, cell.y + RasterizationGrid.neighbor4Deltas[direction].y);","                cell = neighbor;","                direction = (direction + 3) & 0x3; // Rotate counterclockwise.","            }","            // The loop limit is arbitrary. It exists only to guarantee that","            // bad input data doesn't result in an infinite loop.","            // The only down side of this loop limit is that it limits the","            // number of detectable edge vertices (the longer the region edge","            // and the higher the number of \"turns\" in a region's edge, the less","            // edge vertices can be detected for that region).","        } while (!(cell === startCell && direction === startDirection) &&","            ++loopCount < 65535);","        return outContourVertices;","    };","    /**","     * Takes a group of vertices that represent a region contour and changes","     * it in the following manner:","     * - For any edges that connect to non-obstacle regions, remove all","     * vertices except the start and end vertices for that edge (this","     * smooths the edges between non-obstacle regions into a straight line).","     * - Runs an algorithm's against the contour to follow the edge more closely.","     *","     * @param regionID The region the contour was derived from.","     * @param sourceVertices  The source vertices that represent the complex","     * contour.","     * @param outVertices The simplified contour vertices.","     * @param threshold The maximum distance the edge of the contour may deviate","     * from the source geometry.","     */","    ContourBuilder.prototype.generateSimplifiedContour = function (regionID, sourceVertices, outVertices, threshold) {","        var noConnections = true;","        for (var _i = 0, sourceVertices_1 = sourceVertices; _i < sourceVertices_1.length; _i++) {","            var sourceVertex = sourceVertices_1[_i];","            if (sourceVertex.region !== RasterizationCell.OBSTACLE_REGION_ID) {","                noConnections = false;","                break;","            }","        }","        // Seed the simplified contour with the mandatory edges","        // (At least one edge).","        if (noConnections) {","            // This contour represents an island region surrounded only by the","            // obstacle region. Seed the simplified contour with the source's","            // lower left (ll) and upper right (ur) vertices.","            var lowerLeftX = sourceVertices[0].x;","            var lowerLeftY = sourceVertices[0].y;","            var lowerLeftIndex = 0;","            var upperRightX = sourceVertices[0].x;","            var upperRightY = sourceVertices[0].y;","            var upperRightIndex = 0;","            for (var index = 0; index < sourceVertices.length; index++) {","                var sourceVertex = sourceVertices[index];","                var x = sourceVertex.x;","                var y = sourceVertex.y;","                if (x < lowerLeftX || (x === lowerLeftX && y < lowerLeftY)) {","                    lowerLeftX = x;","                    lowerLeftY = y;","                    lowerLeftIndex = index;","                }","                if (x >= upperRightX || (x === upperRightX && y > upperRightY)) {","                    upperRightX = x;","                    upperRightY = y;","                    upperRightIndex = index;","                }","            }","            // The region attribute is used to store an index locally in this function.","            // TODO Maybe there is a way to do this cleanly and keep no memory footprint.","            // Seed the simplified contour with this edge.","            outVertices.push({","                x: lowerLeftX,","                y: lowerLeftY,","                region: lowerLeftIndex,","            });","            outVertices.push({","                x: upperRightX,","                y: upperRightY,","                region: upperRightIndex,","            });","        }","        else {","            // The contour shares edges with other non-obstacle regions.","            // Seed the simplified contour with a new vertex for every","            // location where the region connection changes. These are","            // vertices that are important because they represent portals","            // to other regions.","            for (var index = 0; index < sourceVertices.length; index++) {","                var sourceVert = sourceVertices[index];","                if (sourceVert.region !==","                    sourceVertices[(index + 1) % sourceVertices.length].region) {","                    // The current vertex has a different region than the","                    // next vertex. So there is a change in vertex region.","                    outVertices.push({","                        x: sourceVert.x,","                        y: sourceVert.y,","                        region: index,","                    });","                }","            }","        }","        this.matchObstacleRegionEdges(sourceVertices, outVertices, threshold);","        if (outVertices.length < 2) {","            // It will be ignored by the triangulation.","            // It should be rare enough not to handle it now.","            console.warn(\"A region is encompassed in another region. It will be ignored.\");","        }","        // There can be polygons with only 2 vertices when a region is between","        // 2 non-obstacles regions. It's still a useful information to filter","        // vertices in the middle (not on an obstacle region border).","        // In this case, the CritterAI implementation adds a 3rd point to avoid","        // invisible polygons, but it makes it difficult to filter it later.","        // Replace the index pointers in the output list with region IDs.","        for (var _a = 0, outVertices_1 = outVertices; _a < outVertices_1.length; _a++) {","            var outVertex = outVertices_1[_a];","            outVertex.region = sourceVertices[outVertex.region].region;","        }","    };","    /**","     * Applies an algorithm to contours which results in obstacle-region edges","     * following the original detail source geometry edge more closely.","     * http://www.critterai.org/projects/nmgen_study/contourgen.html#nulledgesimple","     *","     * Adds vertices from the source list to the result list such that","     * if any obstacle region vertices are compared against the result list,","     * none of the vertices will be further from the obstacle region edges than","     * the allowed threshold.","     *","     * Only obstacle-region edges are operated on. All other edges are","     * ignored.","     *","     * The result vertices is expected to be seeded with at least two","     * source vertices.","     *","     * @param sourceVertices","     * @param inoutResultVertices","     * @param threshold The maximum distance the edge of the contour may deviate","     * from the source geometry.","     */","    ContourBuilder.prototype.matchObstacleRegionEdges = function (sourceVertices, inoutResultVertices, threshold) {","        // This implementation is strongly inspired from CritterAI class \"MatchNullRegionEdges\".","        // Loop through all edges in this contour.","        //","        // NOTE: The simplifiedVertCount in the loop condition","        // increases over iterations. That is what keeps the loop going beyond","        // the initial vertex count.","        var resultIndexA = 0;","        while (resultIndexA < inoutResultVertices.length) {","            var resultIndexB = (resultIndexA + 1) % inoutResultVertices.length;","            // The line segment's beginning vertex.","            var ax = inoutResultVertices[resultIndexA].x;","            var az = inoutResultVertices[resultIndexA].y;","            var sourceIndexA = inoutResultVertices[resultIndexA].region;","            // The line segment's ending vertex.","            var bx = inoutResultVertices[resultIndexB].x;","            var bz = inoutResultVertices[resultIndexB].y;","            var sourceIndexB = inoutResultVertices[resultIndexB].region;","            // The source index of the next vertex to test (the vertex just","            // after the current vertex in the source vertex list).","            var testedSourceIndex = (sourceIndexA + 1) % sourceVertices.length;","            var maxDeviation = 0;","            // Default to no index. No new vert to add.","            var toInsertSourceIndex = -1;","            if (sourceVertices[testedSourceIndex].region ===","                RasterizationCell.OBSTACLE_REGION_ID) {","                // This test vertex is part of a obstacle region edge.","                // Loop through the source vertices until the end vertex","                // is found, searching for the vertex that is farthest from","                // the line segment formed by the begin/end vertices.","                //","                // Visualizations:","                // http://www.critterai.org/projects/nmgen_study/contourgen.html#nulledgesimple","                while (testedSourceIndex !== sourceIndexB) {","                    var deviation = Geometry.getPointSegmentDistanceSq(sourceVertices[testedSourceIndex].x, sourceVertices[testedSourceIndex].y, ax, az, bx, bz);","                    if (deviation > maxDeviation) {","                        // A new maximum deviation was detected.","                        maxDeviation = deviation;","                        toInsertSourceIndex = testedSourceIndex;","                    }","                    // Move to the next vertex.","                    testedSourceIndex = (testedSourceIndex + 1) % sourceVertices.length;","                }","            }","            if (toInsertSourceIndex !== -1 && maxDeviation > threshold * threshold) {","                // A vertex was found that is further than allowed from the","                // current edge. Add this vertex to the contour.","                inoutResultVertices.splice(resultIndexA + 1, 0, {","                    x: sourceVertices[toInsertSourceIndex].x,","                    y: sourceVertices[toInsertSourceIndex].y,","                    region: toInsertSourceIndex,","                });","                // Not incrementing the vertex since we need to test the edge","                // formed by vertA  and this this new vertex on the next","                // iteration of the loop.","            }","            // This edge segment does not need to be altered. Move to","            // the next vertex.","            else","                resultIndexA++;","        }","    };","    ContourBuilder.leftVertexOfFacingCellBorderDeltas = [","        { x: 0, y: 1 },","        { x: 1, y: 1 },","        { x: 1, y: 0 },","        { x: 0, y: 0 },","    ];","    return ContourBuilder;","}());","","/**"," * Builds convex polygons from the provided polygons."," *"," * This implementation is strongly inspired from CritterAI class \"PolyMeshFieldBuilder\"."," * http://www.critterai.org/projects/nmgen_study/polygen.html"," */","var ConvexPolygonGenerator = /** @class */ (function () {","    function ConvexPolygonGenerator() {","    }","    /**","     * Builds convex polygons from the provided polygons.","     * @param concavePolygons The content is manipulated during the operation","     * and it will be left in an undefined state at the end of","     * the operation.","     * @param maxVerticesPerPolygon cap the vertex number in return polygons.","     * @return convex polygons.","     */","    ConvexPolygonGenerator.prototype.splitToConvexPolygons = function (concavePolygons, maxVerticesPerPolygon) {","        // The maximum possible number of polygons assuming that all will","        // be triangles.","        var maxPossiblePolygons = 0;","        // The maximum vertices found in a single contour.","        var maxVerticesPerContour = 0;","        for (var _i = 0, concavePolygons_1 = concavePolygons; _i < concavePolygons_1.length; _i++) {","            var contour = concavePolygons_1[_i];","            var count = contour.length;","            maxPossiblePolygons += count - 2;","            maxVerticesPerContour = Math.max(maxVerticesPerContour, count);","        }","        // Each list is initialized to a size that will minimize resizing.","        var convexPolygons = new Array(maxPossiblePolygons);","        convexPolygons.length = 0;","        // Various working variables.","        // (Values are meaningless outside of the iteration)","        var workingContourFlags = new Array(maxVerticesPerContour);","        workingContourFlags.length = 0;","        var workingPolygons = new Array(maxVerticesPerContour + 1);","        workingPolygons.length = 0;","        var workingMergeInfo = {","            lengthSq: -1,","            polygonAVertexIndex: -1,","            polygonBVertexIndex: -1,","        };","        var workingMergedPolygon = new Array(maxVerticesPerPolygon);","        workingMergedPolygon.length = 0;","        var _loop_1 = function (contour) {","            if (contour.length < 3) {","                return \"continue\";","            }","            // Initialize the working polygon array.","            workingPolygons.length = 0;","            // Triangulate the contour.","            var foundAnyTriangle = false;","            this_1.triangulate(contour, workingContourFlags, function (p1, p2, p3) {","                var workingPolygon = new Array(maxVerticesPerPolygon);","                workingPolygon.length = 0;","                workingPolygon.push(p1);","                workingPolygon.push(p2);","                workingPolygon.push(p3);","                workingPolygons.push(workingPolygon);","                foundAnyTriangle = true;","            });","            if (!foundAnyTriangle) {","                /*","                    * Failure of the triangulation.","                    * This is known to occur if the source polygon is","                    * self-intersecting or the source region contains internal","                    * holes. In both cases, the problem is likely due to bad","                    * region formation.","                    */","                console.error(\"Polygon generation failure: Could not triangulate contour.\");","                console.error(\"contour:\" +","                    contour.map(function (point) { return point.x + \" \" + point.y; }).join(\" ; \"));","                return \"continue\";","            }","            if (maxVerticesPerPolygon > 3) {","                // Merging of triangles into larger polygons is permitted.","                // Continue until no polygons can be found to merge.","                // http://www.critterai.org/nmgen_polygen#mergepolys","                while (true) {","                    var longestMergeEdge = -1;","                    var bestPolygonA = [];","                    var polygonAVertexIndex = -1; // Start of the shared edge.","                    var bestPolygonB = [];","                    var polygonBVertexIndex = -1; // Start of the shared edge.","                    var bestPolygonBIndex = -1;","                    // Loop through all but the last polygon looking for the","                    // best polygons to merge in this iteration.","                    for (var indexA = 0; indexA < workingPolygons.length - 1; indexA++) {","                        var polygonA = workingPolygons[indexA];","                        for (var indexB = indexA + 1; indexB < workingPolygons.length; indexB++) {","                            var polygonB = workingPolygons[indexB];","                            // Can polyB merge with polyA?","                            this_1.getPolyMergeInfo(polygonA, polygonB, maxVerticesPerPolygon, workingMergeInfo);","                            if (workingMergeInfo.lengthSq > longestMergeEdge) {","                                // polyB has the longest shared edge with","                                // polyA found so far. Save the merge","                                // information.","                                longestMergeEdge = workingMergeInfo.lengthSq;","                                bestPolygonA = polygonA;","                                polygonAVertexIndex = workingMergeInfo.polygonAVertexIndex;","                                bestPolygonB = polygonB;","                                polygonBVertexIndex = workingMergeInfo.polygonBVertexIndex;","                                bestPolygonBIndex = indexB;","                            }","                        }","                    }","                    if (longestMergeEdge <= 0)","                        // No valid merges found during this iteration.","                        break;","                    // Found polygons to merge. Perform the merge.","                    /*","                        * Fill the mergedPoly array.","                        * Start the vertex at the end of polygon A's shared edge.","                        * Add all vertices until looping back to the vertex just","                        * before the start of the shared edge. Repeat for","                        * polygon B.","                        *","                        * Duplicate vertices are avoided, while ensuring we get","                        * all vertices, since each loop  drops the vertex that","                        * starts its polygon's shared edge and:","                        *","                        * PolyAStartVert == PolyBEndVert and","                        * PolyAEndVert == PolyBStartVert.","                        */","                    var vertCountA = bestPolygonA.length;","                    var vertCountB = bestPolygonB.length;","                    workingMergedPolygon.length = 0;","                    for (var i = 0; i < vertCountA - 1; i++)","                        workingMergedPolygon.push(bestPolygonA[(polygonAVertexIndex + 1 + i) % vertCountA]);","                    for (var i = 0; i < vertCountB - 1; i++)","                        workingMergedPolygon.push(bestPolygonB[(polygonBVertexIndex + 1 + i) % vertCountB]);","                    // Copy the merged polygon over the top of polygon A.","                    bestPolygonA.length = 0;","                    Array.prototype.push.apply(bestPolygonA, workingMergedPolygon);","                    // Remove polygon B","                    workingPolygons.splice(bestPolygonBIndex, 1);","                }","            }","            // Polygon creation for this contour is complete.","            // Add polygons to the global polygon array","            Array.prototype.push.apply(convexPolygons, workingPolygons);","        };","        var this_1 = this;","        // Split every concave polygon into convex polygons.","        for (var _a = 0, concavePolygons_2 = concavePolygons; _a < concavePolygons_2.length; _a++) {","            var contour = concavePolygons_2[_a];","            _loop_1(contour);","        }","        // The original implementation builds polygon adjacency information.","        // but the library for the pathfinding already does it.","        return convexPolygons;","    };","    /**","     * Checks two polygons to see if they can be merged. If a merge is","     * allowed, provides data via the outResult argument (see {@link PolyMergeResult}).","     *","     * @param polygonA The polygon A","     * @param polygonB The polygon B","     * @param maxVerticesPerPolygon cap the vertex number in return polygons.","     * @param outResult contains merge information.","     */","    ConvexPolygonGenerator.prototype.getPolyMergeInfo = function (polygonA, polygonB, maxVerticesPerPolygon, outResult) {","        outResult.lengthSq = -1; // Default to invalid merge","        outResult.polygonAVertexIndex = -1;","        outResult.polygonBVertexIndex = -1;","        var vertexCountA = polygonA.length;","        var vertexCountB = polygonB.length;","        // If the merged polygon would would have to many vertices, do not","        // merge. Subtracting two since to take into account the effect of","        // a merge.","        if (vertexCountA + vertexCountB - 2 > maxVerticesPerPolygon)","            return;","        // Check if the polygons share an edge.","        for (var indexA = 0; indexA < vertexCountA; indexA++) {","            // Get the vertex indices for the polygonA edge","            var vertexA = polygonA[indexA];","            var nextVertexA = polygonA[(indexA + 1) % vertexCountA];","            // Search polygonB for matches.","            for (var indexB = 0; indexB < vertexCountB; indexB++) {","                // Get the vertex indices for the polygonB edge.","                var vertexB = polygonB[indexB];","                var nextVertexB = polygonB[(indexB + 1) % vertexCountB];","                // === can be used because vertices comme from the same concave polygon.","                if (vertexA === nextVertexB && nextVertexA === vertexB) {","                    // The vertex indices for this edge are the same and","                    // sequenced in opposite order. So the edge is shared.","                    outResult.polygonAVertexIndex = indexA;","                    outResult.polygonBVertexIndex = indexB;","                }","            }","        }","        if (outResult.polygonAVertexIndex === -1)","            // No common edge, cannot merge.","            return;","        // Check to see if the merged polygon would be convex.","        //","        // Gets the vertices near the section where the merge would occur.","        // Do they form a concave section?  If so, the merge is invalid.","        //","        // Note that the following algorithm is only valid for clockwise","        // wrapped convex polygons.","        var sharedVertMinus = polygonA[(outResult.polygonAVertexIndex - 1 + vertexCountA) % vertexCountA];","        var sharedVert = polygonA[outResult.polygonAVertexIndex];","        var sharedVertPlus = polygonB[(outResult.polygonBVertexIndex + 2) % vertexCountB];","        if (!ConvexPolygonGenerator.isLeft(sharedVert.x, sharedVert.y, sharedVertMinus.x, sharedVertMinus.y, sharedVertPlus.x, sharedVertPlus.y)) {","            // The shared vertex (center) is not to the left of segment","            // vertMinus->vertPlus. For a clockwise wrapped polygon, this","            // indicates a concave section. Merged polygon would be concave.","            // Invalid merge.","            return;","        }","        sharedVertMinus =","            polygonB[(outResult.polygonBVertexIndex - 1 + vertexCountB) % vertexCountB];","        sharedVert = polygonB[outResult.polygonBVertexIndex];","        sharedVertPlus =","            polygonA[(outResult.polygonAVertexIndex + 2) % vertexCountA];","        if (!ConvexPolygonGenerator.isLeft(sharedVert.x, sharedVert.y, sharedVertMinus.x, sharedVertMinus.y, sharedVertPlus.x, sharedVertPlus.y)) {","            // The shared vertex (center) is not to the left of segment","            // vertMinus->vertPlus. For a clockwise wrapped polygon, this","            // indicates a concave section. Merged polygon would be concave.","            // Invalid merge.","            return;","        }","        // Get the vertex indices that form the shared edge.","        sharedVertMinus = polygonA[outResult.polygonAVertexIndex];","        sharedVert = polygonA[(outResult.polygonAVertexIndex + 1) % vertexCountA];","        // Store the lengthSq of the shared edge.","        var deltaX = sharedVertMinus.x - sharedVert.x;","        var deltaZ = sharedVertMinus.y - sharedVert.y;","        outResult.lengthSq = deltaX * deltaX + deltaZ * deltaZ;","    };","    /**","     * Attempts to triangulate a polygon.","     *","     * @param vertices the polygon to be triangulate.","     * The content is manipulated during the operation","     * and it will be left in an undefined state at the end of","     * the operation.","     * @param vertexFlags only used internally","     * @param outTriangles is called for each triangle derived","     * from the original polygon.","     * @return The number of triangles generated. Or, if triangulation","     * failed, a negative number.","     */","    ConvexPolygonGenerator.prototype.triangulate = function (vertices, vertexFlags, outTriangles) {","        // Terminology, concepts and such:","        //","        // This algorithm loops around the edges of a polygon looking for","        // new internal edges to add that will partition the polygon into a","        // new valid triangle internal to the starting polygon. During each","        // iteration the shortest potential new edge is selected to form that","        // iteration's new triangle.","        //","        // Triangles will only be formed if a single new edge will create","        // a triangle. Two new edges will never be added during a single","        // iteration. This means that the triangulated portions of the","        // original polygon will only contain triangles and the only","        // non-triangle polygon will exist in the untriangulated portion","        // of the original polygon.","        //","        // \"Partition edge\" refers to a potential new edge that will form a","        // new valid triangle.","        //","        // \"Center\" vertex refers to the vertex in a potential new triangle","        // which, if the triangle is formed, will be external to the","        // remaining untriangulated portion of the polygon. Since it","        // is now external to the polygon, it can't be used to form any","        // new triangles.","        //","        // Some documentation refers to \"iPlus2\" even though the variable is","        // not in scope or does not exist for that section of code. For","        // documentation purposes, iPlus2 refers to the 2nd vertex after the","        // primary vertex.","        // E.g.: i, iPlus1, and iPlus2.","        //","        // Visualizations: http://www.critterai.org/projects/nmgen_study/polygen.html#triangulation","        // Loop through all vertices, flagging all indices that represent","        // a center vertex of a valid new triangle.","        vertexFlags.length = vertices.length;","        for (var i = 0; i < vertices.length; i++) {","            var iPlus1 = (i + 1) % vertices.length;","            var iPlus2 = (i + 2) % vertices.length;","            // A triangle formed by i, iPlus1, and iPlus2 will result","            // in a valid internal triangle.","            // Flag the center vertex (iPlus1) to indicate a valid triangle","            // location.","            vertexFlags[iPlus1] = ConvexPolygonGenerator.isValidPartition(i, iPlus2, vertices);","        }","        // Loop through the vertices creating triangles. When there is only a","        // single triangle left,  the operation is complete.","        //","        // When a valid triangle is formed, remove its center vertex. So for","        // each loop, a single vertex will be removed.","        //","        // At the start of each iteration the indices list is in the following","        // state:","        // - Represents a simple polygon representing the un-triangulated","        //   portion of the original polygon.","        // - All valid center vertices are flagged.","        while (vertices.length > 3) {","            // Find the shortest new valid edge.","            // NOTE: i and iPlus1 are defined in two different scopes in","            // this section. So be careful.","            // Loop through all indices in the remaining polygon.","            var minLengthSq = Number.MAX_VALUE;","            var minLengthSqVertexIndex = -1;","            for (var i_1 = 0; i_1 < vertices.length; i_1++) {","                if (vertexFlags[(i_1 + 1) % vertices.length]) {","                    // Indices i, iPlus1, and iPlus2 are known to form a","                    // valid triangle.","                    var vert = vertices[i_1];","                    var vertPlus2 = vertices[(i_1 + 2) % vertices.length];","                    // Determine the length of the partition edge.","                    // (i -> iPlus2)","                    var deltaX = vertPlus2.x - vert.x;","                    var deltaY = vertPlus2.y - vert.y;","                    var lengthSq = deltaX * deltaX + deltaY * deltaY;","                    if (lengthSq < minLengthSq) {","                        minLengthSq = lengthSq;","                        minLengthSqVertexIndex = i_1;","                    }","                }","            }","            if (minLengthSqVertexIndex === -1)","                // Could not find a new triangle. Triangulation failed.","                // This happens if there are three or more vertices","                // left, but none of them are flagged as being a","                // potential center vertex.","                return;","            var i = minLengthSqVertexIndex;","            var iPlus1 = (i + 1) % vertices.length;","            // Add the new triangle to the output.","            outTriangles(vertices[i], vertices[iPlus1], vertices[(i + 2) % vertices.length]);","            // iPlus1, the \"center\" vert in the new triangle, is now external","            // to the untriangulated portion of the polygon. Remove it from","            // the vertices list since it cannot be a member of any new","            // triangles.","            vertices.splice(iPlus1, 1);","            vertexFlags.splice(iPlus1, 1);","            if (iPlus1 === 0 || iPlus1 >= vertices.length) {","                // The vertex removal has invalidated iPlus1 and/or i. So","                // force a wrap, fixing the indices so they reference the","                // correct indices again. This only occurs when the new","                // triangle is formed across the wrap location of the polygon.","                // Case 1: i = 14, iPlus1 = 15, iPlus2 = 0","                // Case 2: i = 15, iPlus1 = 0, iPlus2 = 1;","                i = vertices.length - 1;","                iPlus1 = 0;","            }","            // At this point i and iPlus1 refer to the two indices from a","            // successful triangulation that will be part of another new","            // triangle. We now need to re-check these indices to see if they","            // can now be the center index in a potential new partition.","            vertexFlags[i] = ConvexPolygonGenerator.isValidPartition((i - 1 + vertices.length) % vertices.length, iPlus1, vertices);","            vertexFlags[iPlus1] = ConvexPolygonGenerator.isValidPartition(i, (i + 2) % vertices.length, vertices);","        }","        // Only 3 vertices remain.","        // Add their triangle to the output list.","        outTriangles(vertices[0], vertices[1], vertices[2]);","    };","    /**","     * Check if the line segment formed by vertex A and vertex B will","     * form a valid partition of the polygon.","     *","     * I.e. the line segment AB is internal to the polygon and will not","     * cross existing line segments.","     *","     * Assumptions:","     * - The vertices arguments define a valid simple polygon","     * with vertices wrapped clockwise.","     * - indexA != indexB","     *","     * Behavior is undefined if the arguments to not meet these","     * assumptions","     *","     * @param indexA the index of the vertex that will form the segment AB.","     * @param indexB the index of the vertex that will form the segment AB.","     * @param vertices a polygon wrapped clockwise.","     * @return true if the line segment formed by vertex A and vertex B will","     * form a valid partition of the polygon.","     */","    ConvexPolygonGenerator.isValidPartition = function (indexA, indexB, vertices) {","        //  First check whether the segment AB lies within the internal","        //  angle formed at A (this is the faster check).","        //  If it does, then perform the more costly check.","        return (ConvexPolygonGenerator.liesWithinInternalAngle(indexA, indexB, vertices) &&","            !ConvexPolygonGenerator.hasIllegalEdgeIntersection(indexA, indexB, vertices));","    };","    /**","     * Check if vertex B lies within the internal angle of the polygon","     * at vertex A.","     *","     * Vertex B does not have to be within the polygon border. It just has","     * be be within the area encompassed by the internal angle formed at","     * vertex A.","     *","     * This operation is a fast way of determining whether a line segment","     * can possibly form a valid polygon partition. If this test returns","     * FALSE, then more expensive checks can be skipped.","     *","     * Visualizations: http://www.critterai.org/projects/nmgen_study/polygen.html#anglecheck","     *","     * Special case:","     * FALSE is returned if vertex B lies directly on either of the rays","     * cast from vertex A along its associated polygon edges. So the test","     * on vertex B is exclusive of the polygon edges.","     *","     * Assumptions:","     * - The vertices and indices arguments define a valid simple polygon","     * with vertices wrapped clockwise.","     * -indexA != indexB","     *","     * Behavior is undefined if the arguments to not meet these","     * assumptions","     *","     * @param indexA the index of the vertex that will form the segment AB.","     * @param indexB the index of the vertex that will form the segment AB.","     * @param vertices a polygon wrapped clockwise.","     * @return true if vertex B lies within the internal angle of","     * the polygon at vertex A.","     */","    ConvexPolygonGenerator.liesWithinInternalAngle = function (indexA, indexB, vertices) {","        // Get pointers to the main vertices being tested.","        var vertexA = vertices[indexA];","        var vertexB = vertices[indexB];","        // Get pointers to the vertices just before and just after vertA.","        var vertexAMinus = vertices[(indexA - 1 + vertices.length) % vertices.length];","        var vertexAPlus = vertices[(indexA + 1) % vertices.length];","        // First, find which of the two angles formed by the line segments","        //  AMinus->A->APlus is internal to (pointing towards) the polygon.","        // Then test to see if B lies within the area formed by that angle.","        // TRUE if A is left of or on line AMinus->APlus","        if (ConvexPolygonGenerator.isLeftOrCollinear(vertexA.x, vertexA.y, vertexAMinus.x, vertexAMinus.y, vertexAPlus.x, vertexAPlus.y))","            // The angle internal to the polygon is <= 180 degrees","            // (non-reflex angle).","            // Test to see if B lies within this angle.","            return (ConvexPolygonGenerator.isLeft(","            // TRUE if B is left of line A->AMinus","            vertexB.x, vertexB.y, vertexA.x, vertexA.y, vertexAMinus.x, vertexAMinus.y) &&","                // TRUE if B is right of line A->APlus","                ConvexPolygonGenerator.isRight(vertexB.x, vertexB.y, vertexA.x, vertexA.y, vertexAPlus.x, vertexAPlus.y));","        // The angle internal to the polygon is > 180 degrees (reflex angle).","        // Test to see if B lies within the external (<= 180 degree) angle and","        // flip the result. (If B lies within the external angle, it can't","        // lie within the internal angle)","        return !(","        // TRUE if B is left of or on line A->APlus","        (ConvexPolygonGenerator.isLeftOrCollinear(vertexB.x, vertexB.y, vertexA.x, vertexA.y, vertexAPlus.x, vertexAPlus.y) &&","            // TRUE if B is right of or on line A->AMinus","            ConvexPolygonGenerator.isRightOrCollinear(vertexB.x, vertexB.y, vertexA.x, vertexA.y, vertexAMinus.x, vertexAMinus.y)));","    };","    /**","     * Check if the line segment AB intersects any edges not already","     * connected to one of the two vertices.","     *","     * Assumptions:","     * - The vertices and indices arguments define a valid simple polygon","     * with vertices wrapped clockwise.","     * - indexA != indexB","     *","     * Behavior is undefined if the arguments to not meet these","     * assumptions","     *","     * @param indexA the index of the vertex that will form the segment AB.","     * @param indexB the index of the vertex that will form the segment AB.","     * @param vertices a polygon wrapped clockwise.","     * @return true if the line segment AB intersects any edges not already","     * connected to one of the two vertices.","     */","    ConvexPolygonGenerator.hasIllegalEdgeIntersection = function (indexA, indexB, vertices) {","        // Get pointers to the primary vertices being tested.","        var vertexA = vertices[indexA];","        var vertexB = vertices[indexB];","        // Loop through the polygon edges.","        for (var edgeBeginIndex = 0; edgeBeginIndex < vertices.length; edgeBeginIndex++) {","            var edgeEndIndex = (edgeBeginIndex + 1) % vertices.length;","            if (edgeBeginIndex === indexA ||","                edgeBeginIndex === indexB ||","                edgeEndIndex === indexA ||","                edgeEndIndex === indexB) {","                continue;","            }","            // Neither of the test indices are endpoints of this edge.","            // Get this edge's vertices.","            var edgeBegin = vertices[edgeBeginIndex];","            var edgeEnd = vertices[edgeEndIndex];","            if ((edgeBegin.x === vertexA.x && edgeBegin.y === vertexA.y) ||","                (edgeBegin.x === vertexB.x && edgeBegin.y === vertexB.y) ||","                (edgeEnd.x === vertexA.x && edgeEnd.y === vertexA.y) ||","                (edgeEnd.x === vertexB.x && edgeEnd.y === vertexB.y)) {","                // One of the test vertices is co-located","                // with one of the endpoints of this edge (this is a","                // test of the actual position of the vertices rather than","                // simply the index check performed earlier).","                // Skip this edge.","                continue;","            }","            // This edge is not connected to either of the test vertices.","            // If line segment AB intersects  with this edge, then the","            // intersection is illegal.","            // I.e. New edges cannot cross existing edges.","            if (Geometry.segmentsIntersect(vertexA.x, vertexA.y, vertexB.x, vertexB.y, edgeBegin.x, edgeBegin.y, edgeEnd.x, edgeEnd.y)) {","                return true;","            }","        }","        return false;","    };","    /**","     * Check if point P is to the left of line AB when looking","     * from A to B.","     * @param px The x-value of the point to test.","     * @param py The y-value of the point to test.","     * @param ax The x-value of the point (ax, ay) that is point A on line AB.","     * @param ay The y-value of the point (ax, ay) that is point A on line AB.","     * @param bx The x-value of the point (bx, by) that is point B on line AB.","     * @param by The y-value of the point (bx, by) that is point B on line AB.","     * @return TRUE if point P is to the left of line AB when looking","     * from A to B.","     */","    ConvexPolygonGenerator.isLeft = function (px, py, ax, ay, bx, by) {","        return ConvexPolygonGenerator.getSignedAreaX2(ax, ay, px, py, bx, by) < 0;","    };","    /**","     * Check if point P is to the left of line AB when looking","     * from A to B or is collinear with line AB.","     * @param px The x-value of the point to test.","     * @param py The y-value of the point to test.","     * @param ax The x-value of the point (ax, ay) that is point A on line AB.","     * @param ay The y-value of the point (ax, ay) that is point A on line AB.","     * @param bx The x-value of the point (bx, by) that is point B on line AB.","     * @param by The y-value of the point (bx, by) that is point B on line AB.","     * @return TRUE if point P is to the left of line AB when looking","     * from A to B, or is collinear with line AB.","     */","    ConvexPolygonGenerator.isLeftOrCollinear = function (px, py, ax, ay, bx, by) {","        return ConvexPolygonGenerator.getSignedAreaX2(ax, ay, px, py, bx, by) <= 0;","    };","    /**","     * Check if point P is to the right of line AB when looking","     * from A to B.","     * @param px The x-value of the point to test.","     * @param py The y-value of the point to test.","     * @param ax The x-value of the point (ax, ay) that is point A on line AB.","     * @param ay The y-value of the point (ax, ay) that is point A on line AB.","     * @param bx The x-value of the point (bx, by) that is point B on line AB.","     * @param by The y-value of the point (bx, by) that is point B on line AB.","     * @return TRUE if point P is to the right of line AB when looking","     * from A to B.","     */","    ConvexPolygonGenerator.isRight = function (px, py, ax, ay, bx, by) {","        return ConvexPolygonGenerator.getSignedAreaX2(ax, ay, px, py, bx, by) > 0;","    };","    /**","     * Check if point P is to the right of or on line AB when looking","     * from A to B.","     * @param px The x-value of the point to test.","     * @param py The y-value of the point to test.","     * @param ax The x-value of the point (ax, ay) that is point A on line AB.","     * @param ay The y-value of the point (ax, ay) that is point A on line AB.","     * @param bx The x-value of the point (bx, by) that is point B on line AB.","     * @param by The y-value of the point (bx, by) that is point B on line AB.","     * @return TRUE if point P is to the right of or on line AB when looking","     * from A to B.","     */","    ConvexPolygonGenerator.isRightOrCollinear = function (px, py, ax, ay, bx, by) {","        return ConvexPolygonGenerator.getSignedAreaX2(ax, ay, px, py, bx, by) >= 0;","    };","    /**","     * The absolute value of the returned value is two times the area of the","     * triangle defined by points (A, B, C).","     *","     * A positive value indicates:","     * - Counterclockwise wrapping of the points.","     * - Point B lies to the right of line AC, looking from A to C.","     *","     * A negative value indicates:","     * - Clockwise wrapping of the points.<","     * - Point B lies to the left of line AC, looking from A to C.","     *","     * A value of zero indicates that all points are collinear or","     * represent the same point.","     *","     * This is a fast operation.","     *","     * @param ax The x-value for point (ax, ay) for vertex A of the triangle.","     * @param ay The y-value for point (ax, ay) for vertex A of the triangle.","     * @param bx The x-value for point (bx, by) for vertex B of the triangle.","     * @param by The y-value for point (bx, by) for vertex B of the triangle.","     * @param cx The x-value for point (cx, cy) for vertex C of the triangle.","     * @param cy The y-value for point (cx, cy) for vertex C of the triangle.","     * @return The signed value of two times the area of the triangle defined","     * by the points (A, B, C).","     */","    ConvexPolygonGenerator.getSignedAreaX2 = function (ax, ay, bx, by, cx, cy) {","        // References:","        // http://softsurfer.com/Archive/algorithm_0101/algorithm_0101.htm#Modern%20Triangles","        // http://mathworld.wolfram.com/TriangleArea.html (Search for \"signed\")","        return (bx - ax) * (cy - ay) - (cx - ax) * (by - ay);","    };","    return ConvexPolygonGenerator;","}());","","var GridCoordinateConverter = /** @class */ (function () {","    function GridCoordinateConverter() {","    }","    /**","     *","     * @param gridPosition the position on the grid","     * @param position the position on the scene","     * @param scaleY for isometry","     * @returns the position on the scene","     */","    GridCoordinateConverter.prototype.convertFromGridBasis = function (grid, polygons) {","        // point can be shared so them must be copied to be scaled.","        return polygons.map(function (polygon) {","            return polygon.map(function (point) { return grid.convertFromGridBasis(point, { x: 0, y: 0 }); });","        });","    };","    return GridCoordinateConverter;","}());","","/**"," * It rasterizes obstacles on a grid."," *"," * It flags cells as obstacle to be used by {@link RegionGenerator}."," */","var ObstacleRasterizer = /** @class */ (function () {","    function ObstacleRasterizer() {","        this.workingNodes = new Array(8);","        this.gridBasisIterable = new GridBasisIterable();","    }","    /**","     * Rasterize obstacles on a grid.","     * @param grid","     * @param obstacles","     */","    ObstacleRasterizer.prototype.rasterizeObstacles = function (grid, obstacles) {","        var obstaclesItr = obstacles[Symbol.iterator]();","        for (var next = obstaclesItr.next(); !next.done; next = obstaclesItr.next()) {","            var obstacle = next.value;","            this.gridBasisIterable.set(grid, obstacle);","            var vertices = this.gridBasisIterable;","            var minX = Number.MAX_VALUE;","            var maxX = -Number.MAX_VALUE;","            var minY = Number.MAX_VALUE;","            var maxY = -Number.MAX_VALUE;","            var verticesItr = vertices[Symbol.iterator]();","            for (var next_1 = verticesItr.next(); !next_1.done; next_1 = verticesItr.next()) {","                var vertex = next_1.value;","                minX = Math.min(minX, vertex.x);","                maxX = Math.max(maxX, vertex.x);","                minY = Math.min(minY, vertex.y);","                maxY = Math.max(maxY, vertex.y);","            }","            minX = Math.max(Math.floor(minX), 0);","            maxX = Math.min(Math.ceil(maxX), grid.dimX());","            minY = Math.max(Math.floor(minY), 0);","            maxY = Math.min(Math.ceil(maxY), grid.dimY());","            this.fillPolygon(vertices, minX, maxX, minY, maxY, function (x, y) { return (grid.get(x, y).distanceToObstacle = 0); });","        }","    };","    ObstacleRasterizer.prototype.fillPolygon = function (vertices, minX, maxX, minY, maxY, fill) {","        // The following implementation of the scan-line polygon fill algorithm","        // is strongly inspired from:","        // https://alienryderflex.com/polygon_fill/","        // The original implementation was under this license:","        // public-domain code by Darel Rex Finley, 2007","        // This implementation differ with the following:","        // - it handles float vertices","        //   so it focus on pixels center","        // - it is conservative to thin vertical or horizontal polygons","        var fillAnyPixels = false;","        this.scanY(vertices, minX, maxX, minY, maxY, function (pixelY, minX, maxX) {","            for (var pixelX = minX; pixelX < maxX; pixelX++) {","                fillAnyPixels = true;","                fill(pixelX, pixelY);","            }","        });","        if (fillAnyPixels) {","            return;","        }","        this.scanY(vertices, minX, maxX, minY, maxY, function (pixelY, minX, maxX) {","            // conserve thin (less than one cell large) horizontal polygons","            if (minX === maxX) {","                fill(minX, pixelY);","            }","        });","        this.scanX(vertices, minX, maxX, minY, maxY, function (pixelX, minY, maxY) {","            for (var pixelY = minY; pixelY < maxY; pixelY++) {","                fill(pixelX, pixelY);","            }","            // conserve thin (less than one cell large) vertical polygons","            if (minY === maxY) {","                fill(pixelX, minY);","            }","        });","    };","    ObstacleRasterizer.prototype.scanY = function (vertices, minX, maxX, minY, maxY, checkAndFillY) {","        var workingNodes = this.workingNodes;","        //  Loop through the rows of the image.","        for (var pixelY = minY; pixelY < maxY; pixelY++) {","            var pixelCenterY = pixelY + 0.5;","            //  Build a list of nodes.","            workingNodes.length = 0;","            //let j = vertices.length - 1;","            var verticesItr = vertices[Symbol.iterator]();","            var next = verticesItr.next();","            var vertex = next.value;","            // The iterator always return the same instance.","            // It must be copied to be save for later.","            var firstVertexX = vertex.x;","            var firstVertexY = vertex.y;","            while (!next.done) {","                var previousVertexX = vertex.x;","                var previousVertexY = vertex.y;","                next = verticesItr.next();","                if (next.done) {","                    vertex.x = firstVertexX;","                    vertex.y = firstVertexY;","                }","                else {","                    vertex = next.value;","                }","                if ((vertex.y <= pixelCenterY && pixelCenterY < previousVertexY) ||","                    (previousVertexY < pixelCenterY && pixelCenterY <= vertex.y)) {","                    workingNodes.push(Math.round(vertex.x +","                        ((pixelCenterY - vertex.y) / (previousVertexY - vertex.y)) *","                            (previousVertexX - vertex.x)));","                }","            }","            //  Sort the nodes, via a simple Bubble sort.","            {","                var i = 0;","                while (i < workingNodes.length - 1) {","                    if (workingNodes[i] > workingNodes[i + 1]) {","                        var swap = workingNodes[i];","                        workingNodes[i] = workingNodes[i + 1];","                        workingNodes[i + 1] = swap;","                        if (i > 0)","                            i--;","                    }","                    else {","                        i++;","                    }","                }","            }","            //  Fill the pixels between node pairs.","            for (var i = 0; i < workingNodes.length; i += 2) {","                if (workingNodes[i] >= maxX) {","                    break;","                }","                if (workingNodes[i + 1] <= minX) {","                    continue;","                }","                if (workingNodes[i] < minX) {","                    workingNodes[i] = minX;","                }","                if (workingNodes[i + 1] > maxX) {","                    workingNodes[i + 1] = maxX;","                }","                checkAndFillY(pixelY, workingNodes[i], workingNodes[i + 1]);","            }","        }","    };","    ObstacleRasterizer.prototype.scanX = function (vertices, minX, maxX, minY, maxY, checkAndFillX) {","        var workingNodes = this.workingNodes;","        //  Loop through the columns of the image.","        for (var pixelX = minX; pixelX < maxX; pixelX++) {","            var pixelCenterX = pixelX + 0.5;","            //  Build a list of nodes.","            workingNodes.length = 0;","            var verticesItr = vertices[Symbol.iterator]();","            var next = verticesItr.next();","            var vertex = next.value;","            // The iterator always return the same instance.","            // It must be copied to be save for later.","            var firstVertexX = vertex.x;","            var firstVertexY = vertex.y;","            while (!next.done) {","                var previousVertexX = vertex.x;","                var previousVertexY = vertex.y;","                next = verticesItr.next();","                if (next.done) {","                    vertex.x = firstVertexX;","                    vertex.y = firstVertexY;","                }","                else {","                    vertex = next.value;","                }","                if ((vertex.x < pixelCenterX && pixelCenterX < previousVertexX) ||","                    (previousVertexX < pixelCenterX && pixelCenterX < vertex.x)) {","                    workingNodes.push(Math.round(vertex.y +","                        ((pixelCenterX - vertex.x) / (previousVertexX - vertex.x)) *","                            (previousVertexY - vertex.y)));","                }","            }","            //  Sort the nodes, via a simple Bubble sort.","            {","                var i = 0;","                while (i < workingNodes.length - 1) {","                    if (workingNodes[i] > workingNodes[i + 1]) {","                        var swap = workingNodes[i];","                        workingNodes[i] = workingNodes[i + 1];","                        workingNodes[i + 1] = swap;","                        if (i > 0)","                            i--;","                    }","                    else {","                        i++;","                    }","                }","            }","            //  Fill the pixels between node pairs.","            for (var i = 0; i < workingNodes.length; i += 2) {","                if (workingNodes[i] >= maxY) {","                    break;","                }","                if (workingNodes[i + 1] <= minY) {","                    continue;","                }","                if (workingNodes[i] < minY) {","                    workingNodes[i] = minY;","                }","                if (workingNodes[i + 1] > maxY) {","                    workingNodes[i + 1] = maxY;","                }","                checkAndFillX(pixelX, workingNodes[i], workingNodes[i + 1]);","            }","        }","    };","    return ObstacleRasterizer;","}());","/**"," * Iterable that converts coordinates to the grid."," *"," * This is an allocation free iterable"," * that can only do one iteration at a time."," */","var GridBasisIterable = /** @class */ (function () {","    function GridBasisIterable() {","        this.grid = null;","        this.sceneVertices = [];","        this.verticesItr = this.sceneVertices[Symbol.iterator]();","        this.result = {","            value: { x: 0, y: 0 },","            done: false,","        };","    }","    GridBasisIterable.prototype.set = function (grid, sceneVertices) {","        this.grid = grid;","        this.sceneVertices = sceneVertices;","    };","    GridBasisIterable.prototype[Symbol.iterator] = function () {","        this.verticesItr = this.sceneVertices[Symbol.iterator]();","        return this;","    };","    GridBasisIterable.prototype.next = function () {","        var next = this.verticesItr.next();","        if (next.done) {","            return next;","        }","        this.grid.convertToGridBasis(next.value, this.result.value);","        return this.result;","    };","    return GridBasisIterable;","}());","","/**"," * Build cohesive regions from the non-obstacle space. It uses the data"," * from the obstacles rasterization {@link ObstacleRasterizer}."," *"," * This implementation is strongly inspired from CritterAI class \"OpenHeightfieldBuilder\"."," *"," * Introduction to Height Fields: http://www.critterai.org/projects/nmgen_study/heightfields.html"," *"," * Region Generation: http://www.critterai.org/projects/nmgen_study/regiongen.html"," */","var RegionGenerator = /** @class */ (function () {","    function RegionGenerator() {","        this.obstacleRegionBordersCleaner = new ObstacleRegionBordersCleaner();","        this.floodedCells = new Array(1024);","        this.workingStack = new Array(1024);","    }","    //TODO implement the smoothing pass on the distance field?","    /**","     * Groups cells into cohesive regions using an watershed based algorithm.","     *","     * This operation depends on neighbor and distance field information.","     * So {@link RegionGenerator.generateDistanceField} operations must be","     * run before this operation.","     *","     * @param grid A field with cell distance information fully generated.","     * @param obstacleCellPadding a padding in cells to apply around the","     * obstacles.","     */","    RegionGenerator.prototype.generateRegions = function (grid, obstacleCellPadding) {","        // Watershed Algorithm","        //","        // Reference: http://en.wikipedia.org/wiki/Watershed_%28algorithm%29","        // A good visualization:","        // http://artis.imag.fr/Publications/2003/HDS03/ (PDF)","        //","        // Summary:","        //","        // This algorithm utilizes the cell.distanceToObstacle value, which","        // is generated by the generateDistanceField() operation.","        //","        // Using the watershed analogy, the cells which are furthest from","        // a border (highest distance to border) represent the lowest points","        // in the watershed. A border cell represents the highest possible","        // water level.","        //","        // The main loop iterates, starting at the lowest point in the","        // watershed, then incrementing with each loop until the highest","        // allowed water level is reached. This slowly \"floods\" the cells","        // starting at the lowest points.","        //","        // During each iteration of the loop, cells that are below the","        // current water level are located and an attempt is made to either","        // add them to exiting regions or create new regions from them.","        //","        // During the region expansion phase, if a newly flooded cell","        // borders on an existing region, it is usually added to the region.","        //","        // Any newly flooded cell that survives the region expansion phase","        // is used as a seed for a new region.","        //","        // At the end of the main loop, a final region expansion is","        // performed which should catch any stray cells that escaped region","        // assignment during the main loop.","        // Represents the minimum distance to an obstacle that is considered","        // traversable. I.e. Can't traverse cells closer than this distance","        // to a border. This provides a way of artificially capping the","        // height to which watershed flooding can occur.","        // I.e. Don't let the algorithm flood all the way to the actual border.","        //","        // We add the minimum border distance to take into account the","        // blurring algorithm which can result in a border cell having a","        // border distance > 0.","        var distanceMin = obstacleCellPadding * 2;","        // TODO: EVAL: Figure out why this iteration limit is needed","        // (todo from the CritterAI sources).","        var expandIterations = 4 + distanceMin * 2;","        // Zero is reserved for the obstacle-region. So initializing to 1.","        var nextRegionID = 1;","        var floodedCells = this.floodedCells;","        // Search until the current distance reaches the minimum allowed","        // distance.","        //","        // Note: This loop will not necessarily complete all region","        // assignments. This is OK since a final region assignment step","        // occurs after the loop iteration is complete.","        for (","        // This value represents the current distance from the border which","        // is to be searched. The search starts at the maximum distance then","        // moves toward zero (toward borders).","        //","        // This number will always be divisible by 2.","        var distance = grid.obstacleDistanceMax() & ~1; distance > distanceMin; distance = Math.max(distance - 2, 0)) {","            // Find all cells that are at or below the current \"water level\"","            // and are not already assigned to a region. Add these cells to","            // the flooded cell list for processing.","            floodedCells.length = 0;","            for (var y = 1; y < grid.dimY() - 1; y++) {","                for (var x = 1; x < grid.dimX() - 1; x++) {","                    var cell = grid.get(x, y);","                    if (cell.regionID === RasterizationCell.NULL_REGION_ID &&","                        cell.distanceToObstacle >= distance) {","                        // The cell is not already assigned a region and is","                        // below the current \"water level\". So the cell can be","                        // considered for region assignment.","                        floodedCells.push(cell);","                    }","                }","            }","            if (nextRegionID > 1) {","                // At least one region has already been created, so first","                // try to  put the newly flooded cells into existing regions.","                if (distance > 0) {","                    this.expandRegions(grid, floodedCells, expandIterations);","                }","                else {","                    this.expandRegions(grid, floodedCells, -1);","                }","            }","            // Create new regions for all cells that could not be added to","            // existing regions.","            for (var _i = 0, floodedCells_1 = floodedCells; _i < floodedCells_1.length; _i++) {","                var floodedCell = floodedCells_1[_i];","                if (!floodedCell ||","                    floodedCell.regionID !== RasterizationCell.NULL_REGION_ID) {","                    // This cell was assigned to a newly created region","                    // during an earlier iteration of this loop.","                    // So it can be skipped.","                    continue;","                }","                // Fill to slightly more than the current \"water level\".","                // This improves efficiency of the algorithm.","                // And it is necessary with the conservative expansion to ensure that","                // more than one cell is added initially to a new regions otherwise","                // no cell could be added to it later because of the conservative","                // constraint.","                var fillTo = Math.max(distance - 2, distanceMin + 1, 1);","                if (this.floodNewRegion(grid, floodedCell, fillTo, nextRegionID)) {","                    nextRegionID++;","                }","            }","        }","        // Find all cells that haven't been assigned regions by the main loop","        // (up to the minimum distance).","        floodedCells.length = 0;","        for (var y = 1; y < grid.dimY() - 1; y++) {","            for (var x = 1; x < grid.dimX() - 1; x++) {","                var cell = grid.get(x, y);","                if (cell.distanceToObstacle > distanceMin &&","                    cell.regionID === RasterizationCell.NULL_REGION_ID) {","                    // Not a border or obstacle region cell. Should be in a region.","                    floodedCells.push(cell);","                }","            }","        }","        // Perform a final expansion of existing regions.","        // Allow more iterations than normal for this last expansion.","        if (distanceMin > 0) {","            this.expandRegions(grid, floodedCells, expandIterations * 8);","        }","        else {","            this.expandRegions(grid, floodedCells, -1);","        }","        grid.regionCount = nextRegionID;","        this.obstacleRegionBordersCleaner.fixObstacleRegion(grid);","        //TODO Also port FilterOutSmallRegions?","        // The algorithm to remove vertices in the middle (added at the end of","        // ContourBuilder.buildContours) may already filter them and contour are","        // faster to process than cells.","    };","    /**","     * Attempts to find the most appropriate regions to attach cells to.","     *","     * Any cells successfully attached to a region will have their list","     * entry set to null. So any non-null entries in the list will be cells","     * for which a region could not be determined.","     *","     * @param grid","     * @param inoutCells As input, the list of cells available for formation","     * of new regions. As output, the cells that could not be assigned","     * to new regions.","     * @param maxIterations If set to -1, will iterate through completion.","     */","    RegionGenerator.prototype.expandRegions = function (grid, inoutCells, iterationMax) {","        if (inoutCells.length === 0)","            return;","        var skipped = 0;","        for (var iteration = 0; (iteration < iterationMax || iterationMax === -1) &&","            // All cells have either been processed or could not be","            // processed during the last cycle.","            skipped < inoutCells.length; iteration++) {","            // The number of cells in the working list that have been","            // successfully processed or could not be processed successfully","            // for some reason.","            // This value controls when iteration ends.","            skipped = 0;","            for (var index = 0; index < inoutCells.length; index++) {","                var cell = inoutCells[index];","                if (cell === null) {","                    // The cell originally at this index location has","                    // already been successfully assigned a region. Nothing","                    // else to do with it.","                    skipped++;","                    continue;","                }","                // Default to unassigned.","                var cellRegion = RasterizationCell.NULL_REGION_ID;","                var regionCenterDist = Number.MAX_VALUE;","                for (var _i = 0, _a = RasterizationGrid.neighbor4Deltas; _i < _a.length; _i++) {","                    var delta = _a[_i];","                    var neighbor = grid.get(cell.x + delta.x, cell.y + delta.y);","                    if (neighbor.regionID !== RasterizationCell.NULL_REGION_ID) {","                        if (neighbor.distanceToRegionCore + 2 < regionCenterDist) {","                            // This neighbor is closer to its region core","                            // than previously detected neighbors.","                            // Conservative expansion constraint:","                            // Check to ensure that this neighbor has","                            // at least two other neighbors in its region.","                            // This makes sure that adding this cell to","                            // this neighbor's  region will not result","                            // in a single width line of cells.","                            var sameRegionCount = 0;","                            for (var neighborDirection = 0; neighborDirection < 4; neighborDirection++) {","                                var nnCell = grid.getNeighbor(neighbor, neighborDirection);","                                // There is a diagonal-neighbor","                                if (nnCell.regionID === neighbor.regionID) {","                                    // This neighbor has a neighbor in","                                    // the same region.","                                    sameRegionCount++;","                                }","                            }","                            if (sameRegionCount > 1) {","                                cellRegion = neighbor.regionID;","                                regionCenterDist = neighbor.distanceToRegionCore + 2;","                            }","                        }","                    }","                }","                if (cellRegion !== RasterizationCell.NULL_REGION_ID) {","                    // Found a suitable region for this cell to belong to.","                    // Mark this index as having been processed.","                    inoutCells[index] = null;","                    cell.regionID = cellRegion;","                    cell.distanceToRegionCore = regionCenterDist;","                }","                else {","                    // Could not find an existing region for this cell.","                    skipped++;","                }","            }","        }","    };","    /**","     * Creates a new region surrounding a cell, adding neighbor cells to the","     * new region as appropriate.","     *","     * The new region creation will fail if the root cell is on the","     * border of an existing region.","     *","     * All cells added to the new region as part of this process become","     * \"core\" cells with a distance to region core of zero.","     *","     * @param grid","     * @param rootCell The cell used to seed the new region.","     * @param fillToDist The watershed distance to flood to.","     * @param regionID The region ID to use for the new region","     * (if creation is successful).","     * @return true if a new region was created.","     */","    RegionGenerator.prototype.floodNewRegion = function (grid, rootCell, fillToDist, regionID) {","        var workingStack = this.workingStack;","        workingStack.length = 0;","        workingStack.push(rootCell);","        rootCell.regionID = regionID;","        rootCell.distanceToRegionCore = 0;","        var regionSize = 0;","        var cell;","        while ((cell = workingStack.pop())) {","            // Check regions of neighbor cells.","            //","            // If any neighbor is found to have a region assigned, then","            // the current cell can't be in the new region","            // (want standard flooding algorithm to handle deciding which","            // region this cell should go in).","            //","            // Up to 8 neighbors are checked.","            //","            // Neighbor searches:","            // http://www.critterai.org/projects/nmgen_study/heightfields.html#nsearch","            var isOnRegionBorder = false;","            for (var _i = 0, _a = RasterizationGrid.neighbor8Deltas; _i < _a.length; _i++) {","                var delta = _a[_i];","                var neighbor = grid.get(cell.x + delta.x, cell.y + delta.y);","                isOnRegionBorder =","                    neighbor.regionID !== RasterizationCell.NULL_REGION_ID &&","                        neighbor.regionID !== regionID;","                if (isOnRegionBorder)","                    break;","            }","            if (isOnRegionBorder) {","                cell.regionID = RasterizationCell.NULL_REGION_ID;","                continue;","            }","            regionSize++;","            // If got this far, we know the current cell is part of the new","            // region. Now check its neighbors to see if they should be","            // assigned to this new region.","            for (var _b = 0, _c = RasterizationGrid.neighbor4Deltas; _b < _c.length; _b++) {","                var delta = _c[_b];","                var neighbor = grid.get(cell.x + delta.x, cell.y + delta.y);","                if (neighbor.distanceToObstacle >= fillToDist &&","                    neighbor.regionID === RasterizationCell.NULL_REGION_ID) {","                    neighbor.regionID = regionID;","                    neighbor.distanceToRegionCore = 0;","                    workingStack.push(neighbor);","                }","            }","        }","        return regionSize > 0;","    };","    /**","     * Generates distance field information.","     * The {@link RasterizationCell.distanceToObstacle} information is generated","     * for all cells in the field.","     *","     * All distance values are relative and do not represent explicit","     * distance values (such as grid unit distance). The algorithm which is","     * used results in an approximation only. It is not exhaustive.","     *","     * The data generated by this operation is required by","     * {@link RegionGenerator.generateRegions}.","     *","     * @param grid A field with cells obstacle information already generated.","     */","    RegionGenerator.prototype.generateDistanceField = function (grid) {","        // close borders","        for (var x = 0; x < grid.dimX(); x++) {","            var leftCell = grid.get(x, 0);","            leftCell.distanceToObstacle = 0;","            var rightCell = grid.get(x, grid.dimY() - 1);","            rightCell.distanceToObstacle = 0;","        }","        for (var y = 1; y < grid.dimY() - 1; y++) {","            var topCell = grid.get(0, y);","            topCell.distanceToObstacle = 0;","            var bottomCell = grid.get(grid.dimX() - 1, y);","            bottomCell.distanceToObstacle = 0;","        }","        // The next two phases basically check the neighbors of a cell and","        // set the cell's distance field to be slightly greater than the","        // neighbor with the lowest border distance. Distance is increased","        // slightly more for diagonal-neighbors than for axis-neighbors.","        // 1st pass","        // During this pass, the following neighbors are checked:","        // (-1, 0) (-1, -1) (0, -1) (1, -1)","        for (var y = 1; y < grid.dimY() - 1; y++) {","            for (var x = 1; x < grid.dimX() - 1; x++) {","                var cell = grid.get(x, y);","                for (var _i = 0, _a = RegionGenerator.firstPassDeltas; _i < _a.length; _i++) {","                    var delta = _a[_i];","                    var distanceByNeighbor = grid.get(x + delta.x, y + delta.y).distanceToObstacle +","                        delta.distance;","                    if (cell.distanceToObstacle > distanceByNeighbor) {","                        cell.distanceToObstacle = distanceByNeighbor;","                    }","                }","            }","        }","        // 2nd pass","        // During this pass, the following neighbors are checked:","        //   (1, 0) (1, 1) (0, 1) (-1, 1)","        //","        // Besides checking different neighbors, this pass performs its","        // grid search in reverse order.","        for (var y = grid.dimY() - 2; y >= 1; y--) {","            for (var x = grid.dimX() - 2; x >= 1; x--) {","                var cell = grid.get(x, y);","                for (var _b = 0, _c = RegionGenerator.secondPassDeltas; _b < _c.length; _b++) {","                    var delta = _c[_b];","                    var distanceByNeighbor = grid.get(x + delta.x, y + delta.y).distanceToObstacle +","                        delta.distance;","                    if (cell.distanceToObstacle > distanceByNeighbor) {","                        cell.distanceToObstacle = distanceByNeighbor;","                    }","                }","            }","        }","    };","    RegionGenerator.firstPassDeltas = [","        { x: -1, y: 0, distance: 2 },","        { x: -1, y: -1, distance: 3 },","        { x: 0, y: -1, distance: 2 },","        { x: 1, y: -1, distance: 3 },","    ];","    RegionGenerator.secondPassDeltas = [","        { x: 1, y: 0, distance: 2 },","        { x: 1, y: 1, distance: 3 },","        { x: 0, y: 1, distance: 2 },","        { x: -1, y: 1, distance: 3 },","    ];","    return RegionGenerator;","}());","/**"," * Implements three algorithms that clean up issues that can"," * develop around obstacle region boarders."," *"," * - Detect and fix encompassed obstacle regions:"," *"," * If a obstacle region is found that is fully encompassed by a single"," * region, then the region will be split into two regions at the"," * obstacle region border."," *"," * - Detect and fix \"short wrapping\" of obstacle regions:"," *"," * Regions can sometimes wrap slightly around the corner of a obstacle region"," * in a manner that eventually results in the formation of self-intersecting"," * polygons."," *"," * Example: Before the algorithm is applied:"," * http://www.critterai.org/projects/nmgen_study/media/images/ohfg_08_cornerwrapbefore.jpg\""," *"," * Example: After the algorithm is applied:"," * http://www.critterai.org/projects/nmgen_study/media/images/ohfg_09_cornerwrapafter.jpg"," *"," * - Detect and fix incomplete obstacle region connections:"," *"," * If a region touches obstacle region only diagonally, then contour detection"," * algorithms may not properly detect the obstacle region connection. This can"," * adversely effect other algorithms in the pipeline."," *"," * Example: Before algorithm is applied:"," *"," *     b b a a a a"," *     b b a a a a"," *     a a x x x x"," *     a a x x x x"," *"," * Example: After algorithm is applied:"," *"," *     b b a a a a"," *     b b b a a a <-- Cell transferred to region B."," *     a a x x x x"," *     a a x x x x"," *"," *"," * Region Generation: http://www.critterai.org/projects/nmgen_study/regiongen.html"," */","var ObstacleRegionBordersCleaner = /** @class */ (function () {","    function ObstacleRegionBordersCleaner() {","        this.workingUpLeftOpenCells = new Array(512);","        this.workingDownRightOpenCells = new Array(512);","        this.workingOpenCells = new Array(512);","    }","    /**","     * This operation utilizes {@link RasterizationCell.contourFlags}. It","     * expects the value to be zero on entry, and re-zero's the value","     * on exit.","     *","     * @param grid a grid with fully built regions.","     */","    ObstacleRegionBordersCleaner.prototype.fixObstacleRegion = function (grid) {","        var workingUpLeftOpenCells = this.workingUpLeftOpenCells;","        workingUpLeftOpenCells.length = 0;","        var workingDownRightOpenCells = this.workingDownRightOpenCells;","        workingDownRightOpenCells.length = 0;","        var workingOpenCells = this.workingOpenCells;","        workingOpenCells.length = 0;","        var extremeCells = [","            null,","            null,","        ];","        var nextRegionID = grid.regionCount;","        // Iterate over the cells, trying to find obstacle region borders.","        for (var y = 1; y < grid.dimY() - 1; y++) {","            for (var x = 1; x < grid.dimX() - 1; x++) {","                var cell = grid.get(x, y);","                if (cell.contourFlags !== 0)","                    // Cell was processed in a previous iteration.","                    // Ignore it.","                    continue;","                cell.contourFlags = 1;","                var workingCell = null;","                var edgeDirection = -1;","                if (cell.regionID !== RasterizationCell.OBSTACLE_REGION_ID) {","                    // Not interested in this cell.","                    continue;","                }","                // This is a obstacle region cell. See if it","                // connects to a cell in a non-obstacle region.","                edgeDirection = this.getNonNullBorderDirection(grid, cell);","                if (edgeDirection === -1)","                    // This cell is not a border cell. Ignore it.","                    continue;","                // This is a border cell. Step into the non-null","                // region and swing the direction around 180 degrees.","                workingCell = grid.getNeighbor(cell, edgeDirection);","                edgeDirection = (edgeDirection + 2) & 0x3;","                // Process the obstacle region contour. Detect and fix","                // local issues. Determine if the region is","                // fully encompassed by a single non-obstacle region.","                var isEncompassedNullRegion = this.processNullRegion(grid, workingCell, edgeDirection, extremeCells);","                if (isEncompassedNullRegion) {","                    // This cell is part of a group of obstacle region cells","                    // that is encompassed within a single non-obstacle region.","                    // This is not permitted. Need to fix it.","                    this.partialFloodRegion(grid, extremeCells[0], extremeCells[1], nextRegionID);","                    nextRegionID++;","                }","            }","        }","        grid.regionCount = nextRegionID;","        // Clear all flags.","        for (var y = 1; y < grid.dimY() - 1; y++) {","            for (var x = 1; x < grid.dimX() - 1; x++) {","                var cell = grid.get(x, y);","                cell.contourFlags = 0;","            }","        }","    };","    /**","     * Partially flood a region away from the specified direction.","     *","     * {@link RasterizationCell.contourFlags}","     * is set to zero for all flooded cells.","     *","     * @param grid","     * @param startCell The cell to start the flood from.","     * @param borderDirection  The hard border for flooding. No","     * cells in this direction from the startCell will be flooded.","     * @param newRegionID The region id to assign the flooded","     * cells to.","     */","    ObstacleRegionBordersCleaner.prototype.partialFloodRegion = function (grid, upLeftCell, downRightCell, newRegionID) {","        var upLeftOpenCells = this.workingUpLeftOpenCells;","        var downRightOpenCells = this.workingDownRightOpenCells;","        var workingOpenCells = this.workingOpenCells;","        // The implementation differs from CritterAI to avoid non-contiguous","        // sections. Instead of brushing in one direction, it floods from","        // 2 extremities of the encompassed obstacle region.","        var regionID = upLeftCell.regionID;","        if (regionID === newRegionID) {","            // avoid infinity loop","            console.error(\"Can't create a new region with an ID that already exist.\");","            return;","        }","        // The 1st flooding set a new the regionID","        upLeftCell.regionID = newRegionID;","        upLeftCell.distanceToRegionCore = 0; // This information is lost.","        upLeftOpenCells.length = 0;","        upLeftOpenCells.push(upLeftCell);","        // The 2nd flooding keep the regionID and mark the cell as visited.","        downRightCell.contourFlags = 2;","        downRightCell.distanceToRegionCore = 0; // This information is lost.","        downRightOpenCells.length = 0;","        downRightOpenCells.push(downRightCell);","        var swap;","        workingOpenCells.length = 0;","        while (upLeftOpenCells.length !== 0 || downRightOpenCells.length !== 0) {","            for (var _i = 0, upLeftOpenCells_1 = upLeftOpenCells; _i < upLeftOpenCells_1.length; _i++) {","                var cell = upLeftOpenCells_1[_i];","                for (var direction = 0; direction < 4; direction++) {","                    var neighbor = grid.getNeighbor(cell, direction);","                    if (neighbor.regionID !== regionID || neighbor.contourFlags === 2) {","                        continue;","                    }","                    // Transfer the neighbor to the new region.","                    neighbor.regionID = newRegionID;","                    neighbor.distanceToRegionCore = 0; // This information is lost.","                    workingOpenCells.push(neighbor);","                }","            }","            // This allows to flood the nearest cells first without needing lifo queue.","            // But a queue would take less memory.","            swap = upLeftOpenCells;","            upLeftOpenCells = workingOpenCells;","            workingOpenCells = swap;","            workingOpenCells.length = 0;","            for (var _a = 0, downRightOpenCells_1 = downRightOpenCells; _a < downRightOpenCells_1.length; _a++) {","                var cell = downRightOpenCells_1[_a];","                for (var direction = 0; direction < 4; direction++) {","                    var neighbor = grid.getNeighbor(cell, direction);","                    if (neighbor.regionID !== regionID || neighbor.contourFlags === 2) {","                        continue;","                    }","                    // Keep the neighbor to the current region.","                    neighbor.contourFlags = 2;","                    neighbor.distanceToRegionCore = 0; // This information is lost.","                    workingOpenCells.push(neighbor);","                }","            }","            swap = downRightOpenCells;","            downRightOpenCells = workingOpenCells;","            workingOpenCells = swap;","            workingOpenCells.length = 0;","        }","    };","    /**","     * Detects and fixes bad cell configurations in the vicinity of a","     * obstacle region contour (See class description for details).","     * @param grid","     * @param startCell A cell in a non-obstacle region that borders a null","     * region.","     * @param startDirection The direction of the obstacle region border.","     * @return TRUE if the start cell's region completely encompasses","     * the obstacle region.","     */","    ObstacleRegionBordersCleaner.prototype.processNullRegion = function (grid, startCell, startDirection, extremeCells) {","        // This algorithm traverses the contour. As it does so, it detects","        // and fixes various known dangerous cell configurations.","        //","        // Traversing the contour:  A good way to  visualize it is to think","        // of a robot sitting on the floor facing  a known wall. It then","        // does the following to skirt the wall:","        // 1. If there is a wall in front of it, turn clockwise in 90 degrees","        //    increments until it finds the wall is gone.","        // 2. Move forward one step.","        // 3. Turn counter-clockwise by 90 degrees.","        // 4. Repeat from step 1 until it finds itself at its original","        //    location facing its original direction.","        //","        // See also: http://www.critterai.org/projects/nmgen_study/regiongen.html#robotwalk","        //","        // As the traversal occurs, the number of acute (90 degree) and","        // obtuse (270 degree) corners are monitored. If a complete contour is","        // detected and (obtuse corners > acute corners), then the null","        // region is inside the contour. Otherwise the obstacle region is","        // outside the contour, which we don't care about.","        var borderRegionID = startCell.regionID;","        // Prepare for loop.","        var cell = startCell;","        var neighbor = null;","        var direction = startDirection;","        var upLeftCell = cell;","        var downRightCell = cell;","        // Initialize monitoring variables.","        var loopCount = 0;","        var acuteCornerCount = 0;","        var obtuseCornerCount = 0;","        var stepsWithoutBorder = 0;","        var borderSeenLastLoop = false;","        var isBorder = true; // Initial value doesn't matter.","        // Assume a single region is connected to the obstacle region","        // until proven otherwise.","        var hasSingleConnection = true;","        // The loop limit exists for the sole reason of preventing","        // an infinite loop in case of bad input data.","        // It is set to a very high value because there is no way of","        // definitively determining a safe smaller value. Setting","        // the value too low can result in rescanning a contour","        // multiple times, killing performance.","        while (++loopCount < 1 << 30) {","            // Get the cell across the border.","            neighbor = grid.getNeighbor(cell, direction);","            // Detect which type of edge this direction points across.","            if (neighbor === null) {","                // It points across a obstacle region border edge.","                isBorder = true;","            }","            else {","                // We never need to perform contour detection","                // on this cell again. So mark it as processed.","                neighbor.contourFlags = 1;","                if (neighbor.regionID === RasterizationCell.OBSTACLE_REGION_ID) {","                    // It points across a obstacle region border edge.","                    isBorder = true;","                }","                else {","                    // This isn't a obstacle region border.","                    isBorder = false;","                    if (neighbor.regionID !== borderRegionID)","                        // It points across a border to a non-obstacle region.","                        // This means the current contour can't","                        // represent a fully encompassed obstacle region.","                        hasSingleConnection = false;","                }","            }","            // Process the border.","            if (isBorder) {","                // It is a border edge.","                if (borderSeenLastLoop) {","                    // A border was detected during the last loop as well.","                    // Two detections in a row indicates we passed an acute","                    // (inner) corner.","                    //","                    //     a x","                    //     x x","                    acuteCornerCount++;","                }","                else if (stepsWithoutBorder > 1) {","                    // We have moved at least two cells before detecting","                    // a border. This indicates we passed an obtuse","                    // (outer) corner.","                    //","                    //     a a","                    //     a x","                    obtuseCornerCount++;","                    stepsWithoutBorder = 0;","                    // Detect and fix cell configuration issue around this","                    // corner.","                    if (this.processOuterCorner(grid, cell, direction))","                        // A change was made and it resulted in the","                        // corner area having multiple region connections.","                        hasSingleConnection = false;","                }","                direction = (direction + 1) & 0x3; // Rotate in clockwise direction.","                borderSeenLastLoop = true;","                stepsWithoutBorder = 0;","            }","            else {","                // Not a obstacle region border.","                // Move to the neighbor and swing the search direction back","                // one increment (counterclockwise). By moving the direction","                // back one increment we guarantee we don't miss any edges.","                cell = neighbor;","                direction = (direction + 3) & 0x3; // Rotate counterclockwise direction.","                borderSeenLastLoop = false;","                stepsWithoutBorder++;","                if (cell.x < upLeftCell.x ||","                    (cell.x === upLeftCell.x && cell.y < upLeftCell.y)) {","                    upLeftCell = cell;","                }","                if (cell.x > downRightCell.x ||","                    (cell.x === downRightCell.x && cell.y > downRightCell.y)) {","                    downRightCell = cell;","                }","            }","            if (startCell === cell && startDirection === direction) {","                extremeCells[0] = upLeftCell;","                extremeCells[1] = downRightCell;","                // Have returned to the original cell and direction.","                // The search is complete.","                // Is the obstacle region inside the contour?","                return hasSingleConnection && obtuseCornerCount > acuteCornerCount;","            }","        }","        // If got here then the obstacle region boarder is too large to be fully","        // explored. So it can't be encompassed.","        return false;","    };","    /**","     * Detects and fixes cell configuration issues in the vicinity","     * of obtuse (outer) obstacle region corners.","     * @param grid","     * @param referenceCell The cell in a non-obstacle region that is","     * just past the outer corner.","     * @param borderDirection The direction of the obstacle region border.","     * @return TRUE if more than one region connects to the obstacle region","     * in the vicinity of the corner (this may or may not be due to","     * a change made by this operation).","     */","    ObstacleRegionBordersCleaner.prototype.processOuterCorner = function (grid, referenceCell, borderDirection) {","        var hasMultiRegions = false;","        // Get the previous two cells along the border.","        var backOne = grid.getNeighbor(referenceCell, (borderDirection + 3) & 0x3);","        var backTwo = grid.getNeighbor(backOne, borderDirection);","        var testCell;","        if (backOne.regionID !== referenceCell.regionID &&","            // This differ from the CritterAI implementation.","            // To filter vertices in the middle, this must be avoided too:","            //     a x","            //     b c","            backTwo.regionID !== backOne.regionID) {","            // Dangerous corner configuration.","            //","            //     a x","            //     b a","            //","            // Need to change to one of the following configurations:","            //","            //     b x        a x","            //     b a        b b","            //","            // Reason: During contour detection this type of configuration can","            // result in the region connection being detected as a","            // region-region portal, when it is not. The region connection","            // is actually interrupted by the obstacle region.","            //","            // This configuration has been demonstrated to result in","            // two regions being improperly merged to encompass an","            // internal obstacle region.","            //","            // Example:","            //","            //     a a x x x a","            //     a a x x a a","            //     b b a a a a","            //     b b a a a a","            //","            // During contour and connection detection for region b, at no","            // point will the obstacle region be detected. It will appear","            // as if a clean a-b portal exists.","            //","            // An investigation into fixing this issue via updates to the","            // watershed or contour detection algorithms did not turn","            // up a better way of resolving this issue.","            hasMultiRegions = true;","            // Determine how many connections backTwo has to backOne's region.","            testCell = grid.getNeighbor(backOne, (borderDirection + 3) & 0x3);","            var backTwoConnections = 0;","            if (testCell.regionID === backOne.regionID) {","                backTwoConnections++;","                testCell = grid.getNeighbor(testCell, borderDirection);","                if (testCell.regionID === backOne.regionID)","                    backTwoConnections++;","            }","            // Determine how many connections the reference cell has","            // to backOne's region.","            var referenceConnections = 0;","            testCell = grid.getNeighbor(backOne, (borderDirection + 2) & 0x3);","            if (testCell.regionID === backOne.regionID) {","                referenceConnections++;","                testCell = grid.getNeighbor(testCell, (borderDirection + 2) & 0x3);","                if (testCell.regionID === backOne.regionID)","                    backTwoConnections++;","            }","            // Change the region of the cell that has the most connections","            // to the target region.","            if (referenceConnections > backTwoConnections)","                referenceCell.regionID = backOne.regionID;","            else","                backTwo.regionID = backOne.regionID;","        }","        else if (backOne.regionID === referenceCell.regionID &&","            backTwo.regionID === referenceCell.regionID) {","            // Potential dangerous short wrap.","            //","            //  a x","            //  a a","            //","            //  Example of actual problem configuration:","            //","            //  b b x x","            //  b a x x <- Short wrap.","            //  b a a a","            //","            //  In the above case, the short wrap around the corner of the","            //  obstacle region has been demonstrated to cause self-intersecting","            //  polygons during polygon formation.","            //","            //  This algorithm detects whether or not one (and only one)","            //  of the axis neighbors of the corner should be re-assigned to","            //  a more appropriate region.","            //","            //  In the above example, the following configuration is more","            //  appropriate:","            //","            //  b b x x","            //  b b x x <- Change to this row.","            //  b a a a","            // Check to see if backTwo should be in a different region.","            var selectedRegion = this.selectedRegionID(grid, backTwo, (borderDirection + 1) & 0x3, (borderDirection + 2) & 0x3);","            if (selectedRegion === backTwo.regionID) {","                // backTwo should not be re-assigned. How about","                // the reference cell?","                selectedRegion = this.selectedRegionID(grid, referenceCell, borderDirection, (borderDirection + 3) & 0x3);","                if (selectedRegion !== referenceCell.regionID) {","                    // The reference cell should be reassigned","                    // to a new region.","                    referenceCell.regionID = selectedRegion;","                    hasMultiRegions = true;","                }","            }","            else {","                // backTwo should be re-assigned to a new region.","                backTwo.regionID = selectedRegion;","                hasMultiRegions = true;","            }","        }","        else","            hasMultiRegions = true;","        // No dangerous configurations detected. But definitely","        // has a change in regions at the corner. We know this","        // because one of the previous checks looked for a single","        // region for all wrap cells.","        return hasMultiRegions;","    };","    /**","     * Checks the cell to see if it should be reassigned to a new region.","     *","     * @param grid","     * @param referenceCell A cell on one side of an obstacle region contour's","     * outer corner. It is expected that the all cells that wrap the","     * corner are in the same region.","     * @param borderDirection  The direction of the obstacle region border.","     * @param cornerDirection The direction of the outer corner from the","     * reference cell.","     * @return The region the cell should be a member of. May be the","     * region the cell is currently a member of.","     */","    ObstacleRegionBordersCleaner.prototype.selectedRegionID = function (grid, referenceCell, borderDirection, cornerDirection) {","        // Initial example state:","        //","        // a - Known region.","        // x - Null region.","        // u - Unknown, not checked yet.","        //","        //     u u u","        //     u a x","        //     u a a","        // The only possible alternate region id is from","        // the cell that is opposite the border. So check it first.","        var regionID = grid.getNeighbor(referenceCell, (borderDirection + 2) & 0x3)","            .regionID;","        if (regionID === referenceCell.regionID ||","            regionID === RasterizationCell.OBSTACLE_REGION_ID)","            // The region away from the border is either a obstacle region","            // or the same region. So we keep the current region.","            //","            //     u u u      u u u","            //     a a x  or  x a x  <-- Potentially bad, but stuck with it.","            //     u a a      u a a","            return referenceCell.regionID;","        // Candidate region for re-assignment.","        var potentialRegion = regionID;","        // Next we check the region opposite from the corner direction.","        // If it is the current region, then we definitely can't","        // change the region id without risk of splitting the region.","        regionID = grid.getNeighbor(referenceCell, (cornerDirection + 2) & 0x3)","            .regionID;","        if (regionID === referenceCell.regionID ||","            regionID === RasterizationCell.OBSTACLE_REGION_ID)","            // The region opposite from the corner direction is","            // either a obstacle region or the same region. So we","            // keep the current region.","            //","            //     u a u      u x u","            //     b a x  or  b a x","            //     u a a      u a a","            return referenceCell.regionID;","        // We have checked the early exit special cases. Now a generalized","        // brute count is performed.","        //","        // Priority is given to the potential region. Here is why:","        // (Highly unlikely worst case scenario)","        //","        //     c c c    c c c","        //     b a x -> b b x  Select b even though b count == a count.","        //     b a a    b a a","        // Neighbors in potential region.","        // We know this will have a minimum value of 1.","        var potentialCount = 0;","        // Neighbors in the cell's current region.","        // We know this will have a minimum value of 2.","        var currentCount = 0;","        // Maximum edge case:","        //","        //     b b b","        //     b a x","        //     b a a","        //","        // The maximum edge case for region A can't exist. It","        // is filtered out during one of the earlier special cases","        // handlers.","        //","        // Other cases may exist if more regions are involved.","        // Such cases will tend to favor the current region.","        for (var direction = 0; direction < 8; direction++) {","            var regionID_1 = grid.getNeighbor(referenceCell, direction).regionID;","            if (regionID_1 === referenceCell.regionID)","                currentCount++;","            else if (regionID_1 === potentialRegion)","                potentialCount++;","        }","        return potentialCount < currentCount","            ? referenceCell.regionID","            : potentialRegion;","    };","    /**","     * Returns the direction of the first neighbor in a non-obstacle region.","     * @param grid","     * @param cell The cell to check.","     * @return The direction of the first neighbor in a non-obstacle region, or","     * -1 if all neighbors are in the obstacle region.","     */","    ObstacleRegionBordersCleaner.prototype.getNonNullBorderDirection = function (grid, cell) {","        // Search axis-neighbors.","        for (var direction = 0; direction < RasterizationGrid.neighbor4Deltas.length; direction++) {","            var delta = RasterizationGrid.neighbor4Deltas[direction];","            var neighbor = grid.get(cell.x + delta.x, cell.y + delta.y);","            if (neighbor.regionID !== RasterizationCell.OBSTACLE_REGION_ID)","                // The neighbor is a obstacle region.","                return direction;","        }","        // All neighbors are in a non-obstacle region.","        return -1;","    };","    return ObstacleRegionBordersCleaner;","}());","","// This implementation is strongly inspired from a Java one","// by Stephen A. Pratt:","// http://www.critterai.org/projects/nmgen_study/","//","// Most of the comments were written by him and were adapted to fit this implementation.","// This implementation differs a bit from the original:","// - it's only 2D instead of 3D","// - it has less features (see TODO) and might have lesser performance","// - it uses objects for points instead of pointer-like in arrays of numbers","// - the rasterization comes from other sources because of the 2d focus","// - partialFloodRegion was rewritten to fix an issue","// - filterNonObstacleVertices was added","//","// The Java implementation was also inspired from Recast that can be found here:","// https://github.com/recastnavigation/recastnavigation","var NavMeshGenerator = /** @class */ (function () {","    function NavMeshGenerator(areaLeftBound, areaTopBound, areaRightBound, areaBottomBound, rasterizationCellSize, isometricRatio) {","        if (isometricRatio === void 0) { isometricRatio = 1; }","        this.grid = new RasterizationGrid(areaLeftBound, areaTopBound, areaRightBound, areaBottomBound, rasterizationCellSize, ","        // make cells square in the world","        rasterizationCellSize / isometricRatio);","        this.isometricRatio = isometricRatio;","        this.obstacleRasterizer = new ObstacleRasterizer();","        this.regionGenerator = new RegionGenerator();","        this.contourBuilder = new ContourBuilder();","        this.convexPolygonGenerator = new ConvexPolygonGenerator();","        this.gridCoordinateConverter = new GridCoordinateConverter();","    }","    NavMeshGenerator.prototype.buildNavMesh = function (obstacles, obstacleCellPadding) {","        var _this = this;","        this.grid.clear();","        this.obstacleRasterizer.rasterizeObstacles(this.grid, obstacles);","        this.regionGenerator.generateDistanceField(this.grid);","        this.regionGenerator.generateRegions(this.grid, obstacleCellPadding);","        // It's probably not a good idea to expose the vectorization threshold.","        // As stated in the parameter documentation, the value 1 gives good","        // results in any situations.","        var threshold = 1;","        var contours = this.contourBuilder.buildContours(this.grid, threshold);","        var meshField = this.convexPolygonGenerator.splitToConvexPolygons(contours, 16);","        var scaledMeshField = this.gridCoordinateConverter.convertFromGridBasis(this.grid, meshField);","        if (this.isometricRatio != 1) {","            // Rescale the mesh to have the same unit length on the 2 axis for the pathfinding.","            scaledMeshField.forEach(function (polygon) {","                return polygon.forEach(function (point) {","                    point.y *= _this.isometricRatio;","                });","            });","        }","        return scaledMeshField;","    };","    return NavMeshGenerator;","}());","","/*","GDevelop - NavMesh Pathfinding Behavior Extension","    */","/**"," * PathfindingObstaclesManager manages the common objects shared by objects having a"," * pathfinding behavior: In particular, the obstacles behaviors are required to declare"," * themselves (see `PathfindingObstaclesManager.addObstacle`) to the manager of their associated scene"," * (see `NavMeshPathfindingRuntimeBehavior.obstaclesManagers`)."," */","var NavMeshPathfindingObstaclesManager = /** @class */ (function () {","    function NavMeshPathfindingObstaclesManager(instanceContainer, configuration) {","        /**","         * The navigation meshes by moving object size","         * (rounded on _cellSize)","         */","        this._navMeshes = new Map();","        /**","         * Used while NavMeshes update is disabled to remember to do the update","         * when it's enable back.","         */","        this._navMeshesAreUpToDate = true;","        /**","         * This allows to continue finding paths with the old NavMeshes while","         * moving obstacles.","         */","        this._navMeshesUpdateIsEnabled = true;","        var viewpoint = configuration._getViewpoint();","        if (viewpoint === 'Isometry 2:1 (26.565)') {","            configuration._setIsometricRatio(2);","        }","        else if (viewpoint === 'True Isometry (30)') {","            configuration._setIsometricRatio(Math.sqrt(3));","        }","        else {","            configuration._setIsometricRatio(1);","        }","        if (configuration._getCellSize() <= 0) {","            configuration._setCellSize(10);","        }","        if (configuration._getAreaLeftBound() === 0 &&","            configuration._getAreaTopBound() === 0 &&","            configuration._getAreaRightBound() === 0 &&","            configuration._getAreaBottomBound() === 0) {","            var game = instanceContainer.getGame();","            configuration._setAreaLeftBound(0);","            configuration._setAreaTopBound(0);","            configuration._setAreaRightBound(game.getGameResolutionWidth());","            configuration._setAreaBottomBound(game.getGameResolutionHeight());","        }","        this.configuration = configuration;","        this._obstacles = new Set();","        this._polygonIterableAdapter = new PolygonIterableAdapter();","        this._navMeshGenerator = new NavMeshGenerator(configuration._getAreaLeftBound(), configuration._getAreaTopBound(), configuration._getAreaRightBound(), configuration._getAreaBottomBound(), configuration._getCellSize(), ","        // make cells square in the world","        configuration._getIsometricRatio());","    }","    /**","     * Get the obstacles manager of a scene.","     */","    NavMeshPathfindingObstaclesManager.getManager = function (instanceContainer) {","        // @ts-ignore","        return instanceContainer.navMeshPathfindingObstaclesManager;","    };","    NavMeshPathfindingObstaclesManager.getManagerOrCreate = function (instanceContainer, configuration) {","        // @ts-ignore","        if (!instanceContainer.navMeshPathfindingObstaclesManager) {","            // Create the shared manager if necessary.","            // @ts-ignore","            instanceContainer.navMeshPathfindingObstaclesManager = new NavMeshPathfindingObstaclesManager(instanceContainer, configuration);","        }","        // @ts-ignore","        return instanceContainer.navMeshPathfindingObstaclesManager;","    };","    NavMeshPathfindingObstaclesManager.prototype.setNavMeshesUpdateEnabled = function (navMeshesUpdateIsEnabled) {","        this._navMeshesUpdateIsEnabled = navMeshesUpdateIsEnabled;","        if (navMeshesUpdateIsEnabled && !this._navMeshesAreUpToDate) {","            this._navMeshes.clear();","            this._navMeshesAreUpToDate = true;","        }","    };","    /**","     * Add a obstacle to the list of existing obstacles.","     */","    NavMeshPathfindingObstaclesManager.prototype.addObstacle = function (pathfindingObstacleBehavior) {","        this._obstacles.add(pathfindingObstacleBehavior.behavior.owner);","        this.invalidateNavMesh();","    };","    /**","     * Remove a obstacle from the list of existing obstacles. Be sure that the obstacle was","     * added before.","     */","    NavMeshPathfindingObstaclesManager.prototype.removeObstacle = function (pathfindingObstacleBehavior) {","        this._obstacles.delete(pathfindingObstacleBehavior.behavior.owner);","        this.invalidateNavMesh();","    };","    NavMeshPathfindingObstaclesManager.prototype.invalidateNavMesh = function () {","        if (this._navMeshesUpdateIsEnabled) {","            this._navMeshes.clear();","            this._navMeshesAreUpToDate = true;","        }","        else {","            this._navMeshesAreUpToDate = false;","        }","    };","    NavMeshPathfindingObstaclesManager.prototype.getNavMesh = function (obstacleCellPadding) {","        var navMesh = this._navMeshes.get(obstacleCellPadding);","        if (!navMesh) {","            var navMeshPolygons = this._navMeshGenerator.buildNavMesh(this._getVerticesIterable(this._obstacles), obstacleCellPadding);","            navMesh = new NavMesh(navMeshPolygons);","            this._navMeshes.set(obstacleCellPadding, navMesh);","        }","        return navMesh;","    };","    NavMeshPathfindingObstaclesManager.prototype._getVerticesIterable = function (objects) {","        this._polygonIterableAdapter.set(objects);","        return this._polygonIterableAdapter;","    };","    return NavMeshPathfindingObstaclesManager;","}());","/**"," * Iterable that adapts `RuntimeObject` to `Iterable<{x: float y: float}>`."," *"," * This is an allocation free iterable"," * that can only do one iteration at a time."," */","var PolygonIterableAdapter = /** @class */ (function () {","    function PolygonIterableAdapter() {","        this.objects = [];","        this.objectsItr = this.objects[Symbol.iterator]();","        this.polygonsItr = [][Symbol.iterator]();","        this.pointIterableAdapter = new PointIterableAdapter();","        this.result = {","            value: this.pointIterableAdapter,","            done: false,","        };","    }","    PolygonIterableAdapter.prototype.set = function (objects) {","        this.objects = objects;","    };","    PolygonIterableAdapter.prototype[Symbol.iterator] = function () {","        this.objectsItr = this.objects[Symbol.iterator]();","        this.polygonsItr = [][Symbol.iterator]();","        return this;","    };","    PolygonIterableAdapter.prototype.next = function () {","        var polygonNext = this.polygonsItr.next();","        while (polygonNext.done) {","            var objectNext = this.objectsItr.next();","            if (objectNext.done) {","                // IteratorReturnResult<gdjs.RuntimeObject> require a defined value","                // even though the spec state otherwise.","                // So, this class can't be typed as an iterable.","                this.result.value = undefined;","                this.result.done = true;","                return this.result;","            }","            this.polygonsItr = objectNext.value.getHitBoxes().values();","            polygonNext = this.polygonsItr.next();","        }","        this.pointIterableAdapter.set(polygonNext.value.vertices);","        this.result.value = this.pointIterableAdapter;","        this.result.done = false;","        return this.result;","    };","    return PolygonIterableAdapter;","}());","/**"," * Iterable that adapts coordinates from `[int, int]` to `{x: int, y: int}`."," *"," * This is an allocation free iterable"," * that can only do one iteration at a time."," */","var PointIterableAdapter = /** @class */ (function () {","    function PointIterableAdapter() {","        this.vertices = [];","        this.verticesItr = this.vertices[Symbol.iterator]();","        this.result = {","            value: { x: 0, y: 0 },","            done: false,","        };","    }","    PointIterableAdapter.prototype.set = function (vertices) {","        this.vertices = vertices;","    };","    PointIterableAdapter.prototype[Symbol.iterator] = function () {","        this.verticesItr = this.vertices[Symbol.iterator]();","        return this;","    };","    PointIterableAdapter.prototype.next = function () {","        var next = this.verticesItr.next();","        if (next.done) {","            return next;","        }","        this.result.value.x = next.value[0];","        this.result.value.y = next.value[1];","        return this.result;","    };","    return PointIterableAdapter;","}());","","/*","GDevelop - NavMesh Pathfinding Behavior Extension","    */","/**"," * NavMeshPathfindingRuntimeBehavior represents a behavior allowing objects to"," * follow a path computed to avoid obstacles."," */","var NavMeshRenderer = /** @class */ (function () {","    function NavMeshRenderer() {","        /** Used to draw traces for debugging */","        this._lastUsedObstacleCellPadding = null;","    }","    NavMeshRenderer.prototype.setLastUsedObstacleCellPadding = function (lastUsedObstacleCellPadding) {","        this._lastUsedObstacleCellPadding = lastUsedObstacleCellPadding;","    };","    NavMeshRenderer.prototype.render = function (instanceContainer, shapePainter) {","        if (this._lastUsedObstacleCellPadding === null) {","            return;","        }","        var manager = NavMeshPathfindingObstaclesManager.getManager(instanceContainer);","        if (!manager) {","            return;","        }","        var isometricRatio = manager.configuration._getIsometricRatio();","        // TODO find a way to rebuild drawing only when necessary.","        // Draw the navigation mesh on a shape painter object for debugging purpose","        var navMesh = manager.getNavMesh(this._lastUsedObstacleCellPadding);","        for (var _i = 0, _a = navMesh.getPolygons(); _i < _a.length; _i++) {","            var navPoly = _a[_i];","            var polygon = navPoly.getPoints();","            if (polygon.length === 0)","                continue;","            for (var index = 1; index < polygon.length; index++) {","                // It helps to spot vertices with 180 between edges.","                shapePainter.drawCircle(polygon[index].x, polygon[index].y / isometricRatio, 3);","            }","        }","        for (var _b = 0, _c = navMesh.getPolygons(); _b < _c.length; _b++) {","            var navPoly = _c[_b];","            var polygon = navPoly.getPoints();","            if (polygon.length === 0)","                continue;","            shapePainter.beginFillPath(polygon[0].x, polygon[0].y / isometricRatio);","            for (var index = 1; index < polygon.length; index++) {","                shapePainter.drawPathLineTo(polygon[index].x, polygon[index].y / isometricRatio);","            }","            shapePainter.closePath();","            shapePainter.endFillPath();","        }","    };","    return NavMeshRenderer;","}());","","/**"," * NavMeshPathfindingRuntimeBehavior represents a behavior allowing objects to"," * follow a path computed to avoid obstacles."," */","var PathFollower = /** @class */ (function () {","    function PathFollower(configuration) {","        // Attributes used for traveling on the path:","        this._path = [];","        this._speed = 0;","        this._distanceOnSegment = 0;","        this._totalSegmentDistance = 0;","        this._currentSegment = 0;","        this._movementAngle = 0;","        this.configuration = configuration;","    }","    PathFollower.prototype.setSpeed = function (speed) {","        this._speed = speed;","    };","    PathFollower.prototype.getSpeed = function () {","        return this._speed;","    };","    PathFollower.prototype.getMovementAngle = function () {","        return this._movementAngle;","    };","    PathFollower.prototype.movementAngleIsAround = function (degreeAngle, tolerance) {","        return (Math.abs(gdjs.evtTools.common.angleDifference(this._movementAngle, degreeAngle)) <= tolerance);","    };","    PathFollower.prototype.getNodeX = function (index) {","        if (index < this._path.length) {","            return this._path[index][0];","        }","        return 0;","    };","    PathFollower.prototype.getNodeY = function (index) {","        if (index < this._path.length) {","            return this._path[index][1];","        }","        return 0;","    };","    PathFollower.prototype.getNextNodeIndex = function () {","        return Math.min(this._currentSegment + 1, this._path.length - 1);","    };","    PathFollower.prototype.getNodeCount = function () {","        return this._path.length;","    };","    PathFollower.prototype.getNextNodeX = function () {","        if (this._path.length === 0) {","            return 0;","        }","        var nextIndex = Math.min(this._currentSegment + 1, this._path.length - 1);","        return this._path[nextIndex][0];","    };","    PathFollower.prototype.getNextNodeY = function () {","        if (this._path.length === 0) {","            return 0;","        }","        var nextIndex = Math.min(this._currentSegment + 1, this._path.length - 1);","        return this._path[nextIndex][1];","    };","    PathFollower.prototype.getPreviousNodeX = function () {","        if (this._path.length === 0) {","            return 0;","        }","        var previousIndex = Math.min(this._currentSegment, this._path.length - 1);","        return this._path[previousIndex][0];","    };","    PathFollower.prototype.getPreviousNodeY = function () {","        if (this._path.length === 0) {","            return 0;","        }","        var previousIndex = Math.min(this._currentSegment, this._path.length - 1);","        return this._path[previousIndex][1];","    };","    PathFollower.prototype.getDestinationX = function () {","        if (this._path.length === 0) {","            return 0;","        }","        return this._path[this._path.length - 1][0];","    };","    PathFollower.prototype.getDestinationY = function () {","        if (this._path.length === 0) {","            return 0;","        }","        return (this._path[this._path.length - 1][1]);","    };","    /**","     * Return true if the object reached its destination.","     */","    PathFollower.prototype.destinationReached = function () {","        return this._currentSegment >= this._path.length - 1;","    };","    /**","     * Compute and move on the path to the specified destination.","     */","    PathFollower.prototype.setPath = function (path) {","        this._path = path;","        this._enterSegment(0);","    };","    PathFollower.prototype._enterSegment = function (segmentNumber) {","        if (this._path.length === 0) {","            return;","        }","        this._currentSegment = segmentNumber;","        if (this._currentSegment < this._path.length - 1) {","            var pathX = this._path[this._currentSegment + 1][0] -","                this._path[this._currentSegment][0];","            var pathY = this._path[this._currentSegment + 1][1] -","                this._path[this._currentSegment][1];","            this._totalSegmentDistance = Math.sqrt(pathX * pathX + pathY * pathY);","            this._distanceOnSegment = 0;","            this._movementAngle =","                (gdjs.toDegrees(Math.atan2(pathY, pathX)) + 360) % 360;","        }","        else {","            this._speed = 0;","        }","    };","    PathFollower.prototype.isMoving = function () {","        return !(this._path.length === 0 || this.destinationReached());","    };","    PathFollower.prototype.step = function (timeDelta) {","        if (this._path.length === 0 || this.destinationReached()) {","            return;","        }","        // Update the speed of the object","        var previousSpeed = this._speed;","        var maxSpeed = this.configuration._getMaxSpeed();","        if (this._speed !== maxSpeed) {","            this._speed += this.configuration._getAcceleration() * timeDelta;","            if (this._speed > maxSpeed) {","                this._speed = maxSpeed;","            }","        }","        // Update the time on the segment and change segment if needed","        // Use a Verlet integration to be frame rate independent.","        this._distanceOnSegment +=","            ((this._speed + previousSpeed) / 2) * timeDelta;","        var remainingDistanceOnSegment = this._totalSegmentDistance - this._distanceOnSegment;","        if (remainingDistanceOnSegment <= 0 &&","            this._currentSegment < this._path.length) {","            this._enterSegment(this._currentSegment + 1);","            this._distanceOnSegment = -remainingDistanceOnSegment;","        }","    };","    PathFollower.prototype.getX = function () {","        return this._currentSegment < this._path.length - 1 ? gdjs.evtTools.common.lerp(this._path[this._currentSegment][0], this._path[this._currentSegment + 1][0], this._distanceOnSegment / this._totalSegmentDistance) : this._path[this._path.length - 1][0];","    };","    PathFollower.prototype.getY = function () {","        return this._currentSegment < this._path.length - 1 ? gdjs.evtTools.common.lerp(this._path[this._currentSegment][1], this._path[this._currentSegment + 1][1], this._distanceOnSegment / this._totalSegmentDistance) : this._path[this._path.length - 1][1];","    };","    return PathFollower;","}());","","/**"," * NavMeshPathfindingRuntimeBehavior represents a behavior allowing objects to"," * follow a path computed to avoid obstacles."," */","var NavMeshPathfindingBehavior = /** @class */ (function () {","    function NavMeshPathfindingBehavior(behavior) {","        // Attributes used for traveling on the path:","        this._pathFound = false;","        this.behavior = behavior;","        this.pathFollower = new PathFollower(behavior);","        this.navMeshRenderer = new NavMeshRenderer();","    }","    /**","     * Return true if the latest call to moveTo succeeded.","     */","    NavMeshPathfindingBehavior.prototype.pathFound = function () {","        return this._pathFound;","    };","    /**","     * Compute and move on the path to the specified destination.","     */","    NavMeshPathfindingBehavior.prototype.moveTo = function (instanceContainer, x, y) {","        var owner = this.behavior.owner;","        var manager = NavMeshPathfindingObstaclesManager.getManager(instanceContainer);","        if (!manager) {","            this._pathFound = true;","            this.pathFollower.setPath([[owner.getX(), owner.getY()], [x, y]]);","            return;","        }","        var isometricRatio = manager.configuration._getIsometricRatio();","        var cellSize = manager.configuration._getCellSize();","        var collisionShape = this.behavior._getCollisionShape();","        var extraBorder = this.behavior._getExtraBorder();","        var radiusSqMax = 0;","        if (collisionShape !== 'Dot at center') {","            var centerX = owner.getCenterXInScene();","            var centerY = owner.getCenterYInScene();","            for (var _i = 0, _a = owner.getHitBoxes(); _i < _a.length; _i++) {","                var hitBox = _a[_i];","                for (var _b = 0, _c = hitBox.vertices; _b < _c.length; _b++) {","                    var vertex = _c[_b];","                    var deltaX = vertex[0] - centerX;","                    // to have the same unit on x and y","                    var deltaY = (vertex[1] - centerY) * isometricRatio;","                    var radiusSq = deltaX * deltaX + deltaY * deltaY;","                    radiusSqMax = Math.max(radiusSq, radiusSqMax);","                }","            }","        }","        // Round to avoid to flicker between 2 NavMesh","        // because of trigonometry rounding errors.","        // Round the padding on cellSize to avoid almost identical NavMesh","        var obstacleCellPadding = Math.max(0, Math.round((Math.sqrt(radiusSqMax) + extraBorder) / cellSize));","        this.navMeshRenderer.setLastUsedObstacleCellPadding(obstacleCellPadding);","        var navMesh = manager.getNavMesh(obstacleCellPadding);","        // TODO avoid the path allocation","        var path = navMesh.findPath({","            x: owner.getX(),","            y: owner.getY() * isometricRatio,","        }, { x: x, y: y * isometricRatio }) || [];","        this._pathFound = path.length > 0;","        this.pathFollower.setPath(path.map(function (_a) {","            var x = _a.x, y = _a.y;","            return [x, y];","        }));","    };","    NavMeshPathfindingBehavior.prototype.doStepPreEvents = function (instanceContainer) {","        if (this.pathFollower.destinationReached()) {","            return;","        }","        var manager = NavMeshPathfindingObstaclesManager.getManager(instanceContainer);","        if (!manager) {","            return;","        }","        var isometricRatio = manager.configuration._getIsometricRatio();","        var owner = this.behavior.owner;","        var angleOffset = this.behavior._getAngleOffset();","        var angularMaxSpeed = this.behavior._getMaxSpeed();","        var rotateObject = this.behavior._getRotateObject();","        var timeDelta = owner.getElapsedTime(instanceContainer) / 1000;","        this.pathFollower.step(timeDelta);","        // Position object on the segment and update its angle","        var movementAngle = this.pathFollower.getMovementAngle();","        if (rotateObject &&","            owner.getAngle() !== movementAngle + angleOffset) {","            owner.rotateTowardAngle(movementAngle + angleOffset, angularMaxSpeed, instanceContainer);","        }","        owner.setX(this.pathFollower.getX());","        // In case of isometry, convert coords back in screen.","        owner.setY(this.pathFollower.getY() / isometricRatio);","    };","    return NavMeshPathfindingBehavior;","}());","","/*","GDevelop - NavMesh Pathfinding Behavior Extension","    */","/**"," * NavMeshPathfindingObstacleRuntimeBehavior represents a behavior allowing objects to be"," * considered as a obstacle by objects having Pathfinding Behavior."," */","var NavMeshPathfindingObstacleBehavior = /** @class */ (function () {","    function NavMeshPathfindingObstacleBehavior(instanceContainer, behavior) {","        this._oldX = 0;","        this._oldY = 0;","        this._oldWidth = 0;","        this._oldHeight = 0;","        this._registeredInManager = false;","        this.behavior = behavior;","        this._manager = NavMeshPathfindingObstaclesManager.getManagerOrCreate(instanceContainer, ","        // @ts-ignore","        behavior._sharedData);","        //Note that we can't use getX(), getWidth()... of owner here:","        //The owner is not yet fully constructed.","    }","    NavMeshPathfindingObstacleBehavior.prototype.onDestroy = function () {","        if (this._manager && this._registeredInManager) {","            this._manager.removeObstacle(this);","        }","    };","    NavMeshPathfindingObstacleBehavior.prototype.doStepPreEvents = function (instanceContainer) {","        var owner = this.behavior.owner;","        //Make sure the obstacle is or is not in the obstacles manager.","        if (!this.behavior.activated() && this._registeredInManager) {","            this._manager.removeObstacle(this);","            this._registeredInManager = false;","        }","        else {","            if (this.behavior.activated() && !this._registeredInManager) {","                this._manager.addObstacle(this);","                this._registeredInManager = true;","            }","        }","        //Track changes in size or position","        if (this._oldX !== owner.getX() ||","            this._oldY !== owner.getY() ||","            this._oldWidth !== owner.getWidth() ||","            this._oldHeight !== owner.getHeight()) {","            if (this._registeredInManager) {","                this._manager.removeObstacle(this);","                this._manager.addObstacle(this);","            }","            this._oldX = owner.getX();","            this._oldY = owner.getY();","            this._oldWidth = owner.getWidth();","            this._oldHeight = owner.getHeight();","        }","    };","    NavMeshPathfindingObstacleBehavior.prototype.doStepPostEvents = function (instanceContainer) { };","    NavMeshPathfindingObstacleBehavior.prototype.onActivate = function () {","        if (this._registeredInManager) {","            return;","        }","        this._manager.addObstacle(this);","        this._registeredInManager = true;","    };","    NavMeshPathfindingObstacleBehavior.prototype.onDeActivate = function () {","        if (!this._registeredInManager) {","            return;","        }","        this._manager.removeObstacle(this);","        this._registeredInManager = false;","    };","    return NavMeshPathfindingObstacleBehavior;","}());","","gdjs.__NavMeshPathfinding = {","    NavMeshPathfindingBehavior,","    NavMeshPathfindingObstacleBehavior,","}",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"parameters":[],"objectGroups":[]}],"eventsBasedBehaviors":[{"description":"Move objects to a target in straight lines while avoiding all objects that are flagged as obstacles.","fullName":"Navigation mesh pathfinding (experimental)","name":"NavMeshPathfindingBehavior","objectType":"","eventsFunctions":[{"fullName":"","functionType":"Action","name":"onCreated","sentence":"","events":[{"type":"BuiltinCommonInstructions::Comment","color":{"b":109,"g":230,"r":255,"textB":0,"textG":0,"textR":0},"comment":"Initiate and attach properties as objects variables"},{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"NavMeshPathfinding::DefineJavaScript"},"parameters":["",""]}]},{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["const object = objects[0];\r","const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");\r","const behavior = object.getBehavior(behaviorName);\r","behavior.__NavMeshPathfinding = behavior.__NavMeshPathfinding || {};\r","behavior.__NavMeshPathfinding.pathfinding = new gdjs.__NavMeshPathfinding.NavMeshPathfindingBehavior(behavior);\r",""],"parameterObjects":"Object","useStrict":true,"eventsSheetExpanded":true}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"NavMeshPathfinding::NavMeshPathfindingBehavior","type":"behavior"}],"objectGroups":[]},{"fullName":"","functionType":"Action","name":"doStepPreEvents","sentence":"","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["const object = objects[0];\r","const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");\r","const behavior = object.getBehavior(behaviorName);\r","\r","behavior.__NavMeshPathfinding.pathfinding.doStepPreEvents(runtimeScene);\r",""],"parameterObjects":"Object","useStrict":true,"eventsSheetExpanded":true}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"NavMeshPathfinding::NavMeshPathfindingBehavior","type":"behavior"}],"objectGroups":[]},{"description":"Move the object to a position.","fullName":"Move to a position","functionType":"Action","group":"Movement on the path (navigation mesh)","name":"SetDestination","sentence":"Move _PARAM0_ to _PARAM2_;_PARAM3_","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["const object = objects[0];","const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");","const behavior = object.getBehavior(behaviorName);","","const destinationX = eventsFunctionContext.getArgument(\"DestinationX\");","const destinationY = eventsFunctionContext.getArgument(\"DestinationY\");","","behavior.__NavMeshPathfinding.pathfinding.moveTo(runtimeScene, destinationX, destinationY);",""],"parameterObjects":"Object","useStrict":true,"eventsSheetExpanded":true}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"NavMeshPathfinding::NavMeshPathfindingBehavior","type":"behavior"},{"description":"Destination X position","name":"DestinationX","type":"expression"},{"description":"Destination Y position","name":"DestinationY","type":"expression"}],"objectGroups":[]},{"description":"Check if the object is moving on a path.","fullName":"Is moving","functionType":"Condition","group":"Movement on the path (navigation mesh)","name":"IsMoving","sentence":"_PARAM0_ is moving on a path","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["const object = objects[0];","const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");","const behavior = object.getBehavior(behaviorName);","","eventsFunctionContext.returnValue = behavior.__NavMeshPathfinding.pathfinding.pathFollower.isMoving();",""],"parameterObjects":"Object","useStrict":true,"eventsSheetExpanded":false}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"NavMeshPathfinding::NavMeshPathfindingBehavior","type":"behavior"}],"objectGroups":[]},{"description":"Check if a path has been found.","fullName":"Path found","functionType":"Condition","group":"Movement on the path (navigation mesh)","name":"PathFound","sentence":"A path has been found for _PARAM0_","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["const object = objects[0];","const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");","const behavior = object.getBehavior(behaviorName);","","eventsFunctionContext.returnValue = behavior.__NavMeshPathfinding.pathfinding.pathFound();",""],"parameterObjects":"Object","useStrict":true,"eventsSheetExpanded":false}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"NavMeshPathfinding::NavMeshPathfindingBehavior","type":"behavior"}],"objectGroups":[]},{"description":"Check if the destination was reached.","fullName":"Destination reached","functionType":"Condition","group":"Movement on the path (navigation mesh)","name":"DestinationReached","sentence":"_PARAM0_ reached its destination","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["const object = objects[0];","const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");","const behavior = object.getBehavior(behaviorName);","","eventsFunctionContext.returnValue = behavior.__NavMeshPathfinding.pathfinding.pathFollower.destinationReached();",""],"parameterObjects":"Object","useStrict":true,"eventsSheetExpanded":false}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"NavMeshPathfinding::NavMeshPathfindingBehavior","type":"behavior"}],"objectGroups":[]},{"description":"Get the number of waypoints on the path.","fullName":"Waypoint count","functionType":"Expression","group":"Movement on the path (navigation mesh)","name":"NodeCount","sentence":"","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["const object = objects[0];","const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");","const behavior = object.getBehavior(behaviorName);","","eventsFunctionContext.returnValue = behavior.__NavMeshPathfinding.pathfinding.pathFollower.getNodeCount();",""],"parameterObjects":"Object","useStrict":true,"eventsSheetExpanded":false}],"expressionType":{"type":"expression"},"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"NavMeshPathfinding::NavMeshPathfindingBehavior","type":"behavior"}],"objectGroups":[]},{"description":"Return a waypoint X position.","fullName":"Waypoint X position","functionType":"Expression","group":"Movement on the path (navigation mesh)","name":"NodeX","sentence":"","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["const object = objects[0];","const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");","const behavior = object.getBehavior(behaviorName);","","const nodeIndex = eventsFunctionContext.getArgument(\"NodeIndex\");","","eventsFunctionContext.returnValue = behavior.__NavMeshPathfinding.pathfinding.pathFollower.getNodeX(nodeIndex);",""],"parameterObjects":"Object","useStrict":true,"eventsSheetExpanded":false}],"expressionType":{"type":"expression"},"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"NavMeshPathfinding::NavMeshPathfindingBehavior","type":"behavior"},{"description":"Node index (start at 0)","name":"NodeIndex","type":"expression"}],"objectGroups":[]},{"description":"Return a waypoint Y position.","fullName":"Waypoint Y position","functionType":"Expression","group":"Movement on the path (navigation mesh)","name":"NodeY","sentence":"","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["const object = objects[0];","const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");","const behavior = object.getBehavior(behaviorName);","","const nodeIndex = eventsFunctionContext.getArgument(\"NodeIndex\");","","eventsFunctionContext.returnValue = behavior.__NavMeshPathfinding.pathfinding.pathFollower.getNodeY(nodeIndex);",""],"parameterObjects":"Object","useStrict":true,"eventsSheetExpanded":false}],"expressionType":{"type":"expression"},"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"NavMeshPathfinding::NavMeshPathfindingBehavior","type":"behavior"},{"description":"Node index (start at 0)","name":"NodeIndex","type":"expression"}],"objectGroups":[]},{"description":"Return the index of the next waypoint to reach.","fullName":"Index of the next waypoint","functionType":"Expression","group":"Movement on the path (navigation mesh)","name":"NextNodeIndex","sentence":"","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["const object = objects[0];","const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");","const behavior = object.getBehavior(behaviorName);","","eventsFunctionContext.returnValue = behavior.__NavMeshPathfinding.pathfinding.pathFollower.getNextNodeIndex();",""],"parameterObjects":"Object","useStrict":true,"eventsSheetExpanded":false}],"expressionType":{"type":"expression"},"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"NavMeshPathfinding::NavMeshPathfindingBehavior","type":"behavior"}],"objectGroups":[]},{"description":"Return the next waypoint X position.","fullName":"Next waypoint X position","functionType":"Expression","group":"Movement on the path (navigation mesh)","name":"NextNodeX","sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetReturnNumber"},"parameters":["Object.Behavior::NodeX(Object.Behavior::NextNodeIndex())"]}]}],"expressionType":{"type":"expression"},"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"NavMeshPathfinding::NavMeshPathfindingBehavior","type":"behavior"}],"objectGroups":[]},{"description":"Return the next waypoint Y position.","fullName":"Next waypoint Y position","functionType":"Expression","group":"Movement on the path (navigation mesh)","name":"NextNodeY","sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetReturnNumber"},"parameters":["Object.Behavior::NodeY(Object.Behavior::NextNodeIndex())"]}]}],"expressionType":{"type":"expression"},"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"NavMeshPathfinding::NavMeshPathfindingBehavior","type":"behavior"}],"objectGroups":[]},{"description":"Return the previous waypoint X position.","fullName":"Previous waypoint X position","functionType":"Expression","group":"Movement on the path (navigation mesh)","name":"PreviousNodeX","sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetReturnNumber"},"parameters":["Object.Behavior::NodeX(Object.Behavior::NextNodeIndex() - 1)"]}]}],"expressionType":{"type":"expression"},"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"NavMeshPathfinding::NavMeshPathfindingBehavior","type":"behavior"}],"objectGroups":[]},{"description":"Return the previous waypoint Y position.","fullName":"Previous waypoint Y position","functionType":"Expression","group":"Movement on the path (navigation mesh)","name":"PreviousNodeY","sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetReturnNumber"},"parameters":["Object.Behavior::NodeY(Object.Behavior::NextNodeIndex() - 1)"]}]}],"expressionType":{"type":"expression"},"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"NavMeshPathfinding::NavMeshPathfindingBehavior","type":"behavior"}],"objectGroups":[]},{"description":"Return the destination X position.","fullName":"Destination X position","functionType":"Expression","group":"Movement on the path (navigation mesh)","name":"DestinationX","sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetReturnNumber"},"parameters":["Object.Behavior::NodeX(Object.Behavior::NodeCount() - 1)"]}]}],"expressionType":{"type":"expression"},"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"NavMeshPathfinding::NavMeshPathfindingBehavior","type":"behavior"}],"objectGroups":[]},{"description":"Return the destination Y position.","fullName":"Destination Y position","functionType":"Expression","group":"Movement on the path (navigation mesh)","name":"DestinationY","sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetReturnNumber"},"parameters":["Object.Behavior::NodeY(Object.Behavior::NodeCount() - 1)"]}]}],"expressionType":{"type":"expression"},"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"NavMeshPathfinding::NavMeshPathfindingBehavior","type":"behavior"}],"objectGroups":[]},{"description":"Return the angle of movement of an object on its path.","fullName":"Angle of movement on its path","functionType":"Expression","group":"Movement on the path (navigation mesh)","name":"MovementAngle","sentence":"","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["const object = objects[0];","const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");","const behavior = object.getBehavior(behaviorName);","","const angle = eventsFunctionContext.getArgument(\"Angle\");","const tolerance = eventsFunctionContext.getArgument(\"Tolerance\");","","eventsFunctionContext.returnValue = behavior.__NavMeshPathfinding.pathfinding.pathFollower.getMovementAngle(angle, tolerance);",""],"parameterObjects":"Object","useStrict":true,"eventsSheetExpanded":false}],"expressionType":{"type":"expression"},"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"NavMeshPathfinding::NavMeshPathfindingBehavior","type":"behavior"}],"objectGroups":[]},{"description":"Compare the angle of movement of an object on its path.","fullName":"Angle of movement on its path","functionType":"Condition","group":"Movement on the path (navigation mesh)","name":"MovementAngleIsAround","sentence":"Angle of movement of _PARAM0_ is _PARAM2_ (tolerance: _PARAM3_ degrees)","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"BuiltinCommonInstructions::CompareNumbers"},"parameters":["AngleDifference(Angle, Object.Behavior::MovementAngle())","<","Tolerance"]}],"actions":[{"type":{"value":"SetReturnBoolean"},"parameters":["True"]}]}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"NavMeshPathfinding::NavMeshPathfindingBehavior","type":"behavior"},{"description":"Angle (in degrees)","name":"Angle","type":"expression"},{"description":"Tolerance (in degrees)","name":"Tolerance","type":"expression"}],"objectGroups":[]},{"description":"the number of waypoints on the path.","fullName":"Speed on the path","functionType":"ExpressionAndCondition","group":"Movement on the path (navigation mesh)","name":"Speed","sentence":"the speed on the path","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["const object = objects[0];","const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");","const behavior = object.getBehavior(behaviorName);","","eventsFunctionContext.returnValue = behavior.__NavMeshPathfinding.pathfinding.pathFollower.getSpeed();",""],"parameterObjects":"Object","useStrict":true,"eventsSheetExpanded":false}],"expressionType":{"type":"expression"},"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"NavMeshPathfinding::NavMeshPathfindingBehavior","type":"behavior"}],"objectGroups":[]},{"description":"Draw the navigation mesh used for the object.","fullName":"Draw navigation mesh","functionType":"Action","group":"Debug","name":"DrawNavMesh","sentence":"Draw the navigation mesh used for _PARAM0_ on _PARAM2_","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["const object = objects[0];","const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");","const behavior = object.getBehavior(behaviorName);","","const shapePainters = eventsFunctionContext.getObjects(\"ShapePainter\");","","for (const shapePainter of shapePainters) {","    behavior.__NavMeshPathfinding.pathfinding.navMeshRenderer.render(runtimeScene, shapePainter);","}",""],"parameterObjects":"Object","useStrict":true,"eventsSheetExpanded":true}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"NavMeshPathfinding::NavMeshPathfindingBehavior","type":"behavior"},{"description":"Shape painter","name":"ShapePainter","supplementaryInformation":"PrimitiveDrawing::Drawer","type":"objectList"}],"objectGroups":[]},{"description":"the acceleration of the object.","fullName":"Acceleration","functionType":"ExpressionAndCondition","group":"Pathfinding configuration (navigation mesh)","name":"Acceleration","sentence":"the acceleration","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetReturnNumber"},"parameters":["Acceleration"]}]}],"expressionType":{"type":"expression"},"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"NavMeshPathfinding::NavMeshPathfindingBehavior","type":"behavior"}],"objectGroups":[]},{"fullName":"","functionType":"ActionWithOperator","getterName":"Acceleration","name":"SetAcceleration","sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"NavMeshPathfinding::NavMeshPathfindingBehavior::SetPropertyAcceleration"},"parameters":["Object","Behavior","=","Value"]}]}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"NavMeshPathfinding::NavMeshPathfindingBehavior","type":"behavior"}],"objectGroups":[]},{"description":"the maximum speed of the object.","fullName":"Maximum speed","functionType":"ExpressionAndCondition","group":"Pathfinding configuration (navigation mesh)","name":"MaxSpeed","sentence":"the maximum speed","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetReturnNumber"},"parameters":["MaxSpeed"]}]}],"expressionType":{"type":"expression"},"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"NavMeshPathfinding::NavMeshPathfindingBehavior","type":"behavior"}],"objectGroups":[]},{"fullName":"","functionType":"ActionWithOperator","getterName":"MaxSpeed","name":"SetMaxSpeed","sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"NavMeshPathfinding::NavMeshPathfindingBehavior::SetPropertyMaxSpeed"},"parameters":["Object","Behavior","=","Value"]}]}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"NavMeshPathfinding::NavMeshPathfindingBehavior","type":"behavior"}],"objectGroups":[]},{"description":"the rotation speed of the object.","fullName":"Rotation speed","functionType":"ExpressionAndCondition","group":"Pathfinding configuration (navigation mesh)","name":"AngularMaxSpeed","sentence":"the rotation speed","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetReturnNumber"},"parameters":["AngularMaxSpeed"]}]}],"expressionType":{"type":"expression"},"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"NavMeshPathfinding::NavMeshPathfindingBehavior","type":"behavior"}],"objectGroups":[]},{"fullName":"","functionType":"ActionWithOperator","getterName":"AngularMaxSpeed","name":"SetAngularMaxSpeed","sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"NavMeshPathfinding::NavMeshPathfindingBehavior::SetPropertyAngularMaxSpeed"},"parameters":["Object","Behavior","=","Value"]}]}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"NavMeshPathfinding::NavMeshPathfindingBehavior","type":"behavior"}],"objectGroups":[]},{"description":"the angle offset of the object.","fullName":"Angle offset","functionType":"ExpressionAndCondition","group":"Pathfinding configuration (navigation mesh)","name":"AngleOffset","sentence":"the angle offset","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetReturnNumber"},"parameters":["AngleOffset"]}]}],"expressionType":{"type":"expression"},"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"NavMeshPathfinding::NavMeshPathfindingBehavior","type":"behavior"}],"objectGroups":[]},{"fullName":"","functionType":"ActionWithOperator","getterName":"AngleOffset","name":"SetAngleOffset","sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"NavMeshPathfinding::NavMeshPathfindingBehavior::SetPropertyAngleOffset"},"parameters":["Object","Behavior","=","Value"]}]}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"NavMeshPathfinding::NavMeshPathfindingBehavior","type":"behavior"}],"objectGroups":[]},{"description":"the extra border size of the object.","fullName":"Extra border size","functionType":"ExpressionAndCondition","group":"Pathfinding configuration (navigation mesh)","name":"ExtraBorder","sentence":"the extra border size","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetReturnNumber"},"parameters":["ExtraBorder"]}]}],"expressionType":{"type":"expression"},"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"NavMeshPathfinding::NavMeshPathfindingBehavior","type":"behavior"}],"objectGroups":[]},{"fullName":"","functionType":"ActionWithOperator","getterName":"ExtraBorder","name":"SetExtraBorder","sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"NavMeshPathfinding::NavMeshPathfindingBehavior::SetPropertyExtraBorder"},"parameters":["Object","Behavior","=","Value"]}]}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"NavMeshPathfinding::NavMeshPathfindingBehavior","type":"behavior"}],"objectGroups":[]},{"description":"the collision shape of the object.","fullName":"Collision shape","functionType":"ExpressionAndCondition","group":"Pathfinding configuration (navigation mesh)","name":"CollisionShape","sentence":"the collision shape","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetReturnString"},"parameters":["CollisionShape"]}]}],"expressionType":{"supplementaryInformation":"[\"Bounding disk\",\"Dot at center\"]","type":"stringWithSelector"},"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"NavMeshPathfinding::NavMeshPathfindingBehavior","type":"behavior"}],"objectGroups":[]},{"fullName":"","functionType":"ActionWithOperator","getterName":"CollisionShape","name":"SetCollisionShape","sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"NavMeshPathfinding::NavMeshPathfindingBehavior::SetPropertyCollisionShape"},"parameters":["Object","Behavior","=","Value"]}]}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"NavMeshPathfinding::NavMeshPathfindingBehavior","type":"behavior"}],"objectGroups":[]},{"description":"Check if the object should rotate when following its path.","fullName":"Rotate object","functionType":"Condition","group":"Pathfinding configuration (navigation mesh)","name":"RotateObject","sentence":"_PARAM0_ rotate when following its path","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"NavMeshPathfinding::NavMeshPathfindingBehavior::PropertyRotateObject"},"parameters":["Object","Behavior"]}],"actions":[{"type":{"value":"SetReturnBoolean"},"parameters":["True"]}]}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"NavMeshPathfinding::NavMeshPathfindingBehavior","type":"behavior"}],"objectGroups":[]},{"description":"Enable or disable the rotation of the object when following its path.","fullName":"Rotate object","functionType":"Action","getterName":"RotateObject","group":"Pathfinding configuration (navigation mesh)","name":"SetRotateObject","sentence":"Enable the rotation of _PARAM0_ on the path: _PARAM2_","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"GetArgumentAsBoolean"},"parameters":["\"Value\""]}],"actions":[{"type":{"value":"NavMeshPathfinding::NavMeshPathfindingBehavior::SetPropertyRotateObject"},"parameters":["Object","Behavior","yes"]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"inverted":true,"value":"GetArgumentAsBoolean"},"parameters":["\"Value\""]}],"actions":[{"type":{"value":"NavMeshPathfinding::NavMeshPathfindingBehavior::SetPropertyRotateObject"},"parameters":["Object","Behavior","no"]}]}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"NavMeshPathfinding::NavMeshPathfindingBehavior","type":"behavior"},{"description":"Rotate object","name":"Value","type":"yesorno"}],"objectGroups":[]}],"propertyDescriptors":[{"value":"400","type":"Number","label":"Acceleration","description":"","group":"","extraInformation":[],"name":"Acceleration"},{"value":"200","type":"Number","label":"Maximum speed","description":"","group":"","extraInformation":[],"name":"MaxSpeed"},{"value":"180","type":"Number","label":"Rotation speed","description":"","group":"Rotation","extraInformation":[],"name":"AngularMaxSpeed"},{"value":"","type":"Boolean","label":"Rotate object","description":"","group":"Rotation","extraInformation":[],"name":"RotateObject"},{"value":"0","type":"Number","label":"Angle offset","description":"","group":"Rotation","extraInformation":[],"name":"AngleOffset"},{"value":"Bounding disk","type":"Choice","label":"Collision shape","description":"","group":"Collision","extraInformation":["Bounding disk","Dot at center"],"name":"CollisionShape"},{"value":"0","type":"Number","label":"Extra border size","description":"","group":"Collision","extraInformation":[],"name":"ExtraBorder"}],"sharedPropertyDescriptors":[]},{"description":"Flag objects as being an obstacle for pathfinding.","fullName":"Obstacle for navigation mesh pathfinding (experimental)","name":"NavMeshPathfindingObstacleBehavior","objectType":"","eventsFunctions":[{"fullName":"","functionType":"Action","name":"onCreated","sentence":"","events":[{"type":"BuiltinCommonInstructions::Comment","color":{"b":109,"g":230,"r":255,"textB":0,"textG":0,"textR":0},"comment":"Initiate and attach properties as objects variables"},{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"NavMeshPathfinding::DefineJavaScript"},"parameters":["",""]}]},{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["const object = objects[0];\r","const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");\r","const behavior = object.getBehavior(behaviorName);\r","behavior.__NavMeshPathfinding = behavior.__NavMeshPathfinding || {};\r","behavior.__NavMeshPathfinding.obstacle =\r","    new gdjs.__NavMeshPathfinding.NavMeshPathfindingObstacleBehavior(\r","        runtimeScene, behavior);\r",""],"parameterObjects":"Object","useStrict":true,"eventsSheetExpanded":true}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"NavMeshPathfinding::NavMeshPathfindingObstacleBehavior","type":"behavior"}],"objectGroups":[]},{"fullName":"","functionType":"Action","name":"doStepPreEvents","sentence":"","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["const object = objects[0];\r","const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");\r","const behavior = object.getBehavior(behaviorName);\r","\r","behavior.__NavMeshPathfinding.obstacle.doStepPreEvents(runtimeScene);"],"parameterObjects":"Object","useStrict":true,"eventsSheetExpanded":true}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"NavMeshPathfinding::NavMeshPathfindingObstacleBehavior","type":"behavior"}],"objectGroups":[]},{"fullName":"","functionType":"Action","name":"onDeActivate","sentence":"","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["const object = objects[0];\r","const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");\r","const behavior = object.getBehavior(behaviorName);\r","\r","behavior.__NavMeshPathfinding.obstacle.onDeActivate();"],"parameterObjects":"Object","useStrict":true,"eventsSheetExpanded":true}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"NavMeshPathfinding::NavMeshPathfindingObstacleBehavior","type":"behavior"}],"objectGroups":[]},{"fullName":"","functionType":"Action","name":"onActivate","sentence":"","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["const object = objects[0];\r","const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");\r","const behavior = object.getBehavior(behaviorName);\r","\r","behavior.__NavMeshPathfinding.obstacle.onActivate();"],"parameterObjects":"Object","useStrict":true,"eventsSheetExpanded":true}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"NavMeshPathfinding::NavMeshPathfindingObstacleBehavior","type":"behavior"}],"objectGroups":[]},{"fullName":"","functionType":"Action","name":"onDestroy","sentence":"","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["const object = objects[0];\r","const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");\r","const behavior = object.getBehavior(behaviorName);\r","\r","behavior.__NavMeshPathfinding.obstacle.onDestroy();"],"parameterObjects":"Object","useStrict":true,"eventsSheetExpanded":true}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"NavMeshPathfinding::NavMeshPathfindingObstacleBehavior","type":"behavior"}],"objectGroups":[]},{"description":"the cell size for obstacle collision mask rasterization. While an object is needed, this will apply to all objects using the behavior.","fullName":"Cell size","functionType":"ExpressionAndCondition","group":"Navigation mesh configuration","name":"CellSize","sentence":"the cell size","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetReturnNumber"},"parameters":["Object.Behavior::SharedPropertyCellSize()"]}]}],"expressionType":{"type":"expression"},"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"NavMeshPathfinding::NavMeshPathfindingObstacleBehavior","type":"behavior"}],"objectGroups":[]},{"fullName":"","functionType":"ActionWithOperator","getterName":"CellSize","name":"SetCellSize","sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"NavMeshPathfinding::NavMeshPathfindingObstacleBehavior::SetSharedPropertyCellSize"},"parameters":["Object","Behavior","=","Value"]},{"type":{"value":"NavMeshPathfinding::NavMeshPathfindingObstacleBehavior::InvalidateNavMesh"},"parameters":["Object","Behavior",""]}]}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"NavMeshPathfinding::NavMeshPathfindingObstacleBehavior","type":"behavior"}],"objectGroups":[]},{"description":"the area left bound. The left bound of the area where objects can go in the scene. While an object is needed, this will apply to all objects using the behavior.","fullName":"Area left bound","functionType":"ExpressionAndCondition","group":"Navigation mesh configuration","name":"AreaLeftBound","sentence":"the area left bound","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetReturnNumber"},"parameters":["Object.Behavior::SharedPropertyAreaLeftBound()"]}]}],"expressionType":{"type":"expression"},"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"NavMeshPathfinding::NavMeshPathfindingObstacleBehavior","type":"behavior"}],"objectGroups":[]},{"fullName":"","functionType":"ActionWithOperator","getterName":"AreaLeftBound","name":"SetAreaLeftBound","sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"NavMeshPathfinding::NavMeshPathfindingObstacleBehavior::SetSharedPropertyAreaLeftBound"},"parameters":["Object","Behavior","=","Value"]},{"type":{"value":"NavMeshPathfinding::NavMeshPathfindingObstacleBehavior::InvalidateNavMesh"},"parameters":["Object","Behavior",""]}]}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"NavMeshPathfinding::NavMeshPathfindingObstacleBehavior","type":"behavior"}],"objectGroups":[]},{"description":"the area top bound. The top bound of the area where objects can go in the scene. While an object is needed, this will apply to all objects using the behavior.","fullName":"Area top bound","functionType":"ExpressionAndCondition","group":"Navigation mesh configuration","name":"AreaTopBound","sentence":"the area top bound","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetReturnNumber"},"parameters":["Object.Behavior::SharedPropertyAreaTopBound()"]}]}],"expressionType":{"type":"expression"},"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"NavMeshPathfinding::NavMeshPathfindingObstacleBehavior","type":"behavior"}],"objectGroups":[]},{"fullName":"","functionType":"ActionWithOperator","getterName":"AreaTopBound","name":"SetAreaTopBound","sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"NavMeshPathfinding::NavMeshPathfindingObstacleBehavior::SetSharedPropertyAreaTopBound"},"parameters":["Object","Behavior","=","Value"]},{"type":{"value":"NavMeshPathfinding::NavMeshPathfindingObstacleBehavior::InvalidateNavMesh"},"parameters":["Object","Behavior",""]}]}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"NavMeshPathfinding::NavMeshPathfindingObstacleBehavior","type":"behavior"}],"objectGroups":[]},{"description":"the area right bound. The right bound of the area where objects can go in the scene (default to the game resolution). While an object is needed, this will apply to all objects using the behavior.","fullName":"Area right bound","functionType":"ExpressionAndCondition","group":"Navigation mesh configuration","name":"AreaRightBound","sentence":"the area right bound","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetReturnNumber"},"parameters":["Object.Behavior::SharedPropertyAreaRightBound()"]}]}],"expressionType":{"type":"expression"},"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"NavMeshPathfinding::NavMeshPathfindingObstacleBehavior","type":"behavior"}],"objectGroups":[]},{"fullName":"","functionType":"ActionWithOperator","getterName":"AreaRightBound","name":"SetAreaRightBound","sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"NavMeshPathfinding::NavMeshPathfindingObstacleBehavior::SetSharedPropertyAreaRightBound"},"parameters":["Object","Behavior","=","Value"]},{"type":{"value":"NavMeshPathfinding::NavMeshPathfindingObstacleBehavior::InvalidateNavMesh"},"parameters":["Object","Behavior",""]}]}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"NavMeshPathfinding::NavMeshPathfindingObstacleBehavior","type":"behavior"}],"objectGroups":[]},{"description":"the area bottom bound. The bottom bound of the area where objects can go in the scene (default to the game resolution). While an object is needed, this will apply to all objects using the behavior.","fullName":"Area bottom bound","functionType":"ExpressionAndCondition","group":"Navigation mesh configuration","name":"AreaBottomBound","sentence":"the area bottom bound","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetReturnNumber"},"parameters":["Object.Behavior::SharedPropertyAreaBottomBound()"]}]}],"expressionType":{"type":"expression"},"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"NavMeshPathfinding::NavMeshPathfindingObstacleBehavior","type":"behavior"}],"objectGroups":[]},{"fullName":"","functionType":"ActionWithOperator","getterName":"AreaBottomBound","name":"SetAreaBottomBound","sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"NavMeshPathfinding::NavMeshPathfindingObstacleBehavior::SetSharedPropertyAreaBottomBound"},"parameters":["Object","Behavior","=","Value"]},{"type":{"value":"NavMeshPathfinding::NavMeshPathfindingObstacleBehavior::InvalidateNavMesh"},"parameters":["Object","Behavior",""]}]}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"NavMeshPathfinding::NavMeshPathfindingObstacleBehavior","type":"behavior"}],"objectGroups":[]},{"description":"Invalidate navigation mesh.","fullName":"Invalidate navigation mesh","functionType":"Action","name":"InvalidateNavMesh","private":true,"sentence":"Invalidate navigation mesh","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["const object = objects[0];","const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");","const behavior = object.getBehavior(behaviorName);","","eventsFunctionContext.returnValue = behavior.__NavMeshPathfinding.obstacle._manager.invalidateNavMesh();",""],"parameterObjects":"Object","useStrict":true,"eventsSheetExpanded":false}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"NavMeshPathfinding::NavMeshPathfindingObstacleBehavior","type":"behavior"}],"objectGroups":[]}],"propertyDescriptors":[],"sharedPropertyDescriptors":[{"value":"Top-Down","type":"Choice","label":"Viewpoint","description":"","group":"","extraInformation":["Top-Down","Isometry 2:1 (26.565)","True Isometry (30)"],"name":"Viewpoint"},{"value":"10","type":"Number","label":"Cell size","description":"Cell size for obstacle collision mask rasterization.","group":"","extraInformation":[],"name":"CellSize"},{"value":"0","type":"Number","label":"Area left bound","description":"The left bound of the area where objects can go in the scene.","group":"","extraInformation":[],"name":"AreaLeftBound"},{"value":"0","type":"Number","label":"Area top bound","description":"The top bound of the area where objects can go in the scene.","group":"","extraInformation":[],"name":"AreaTopBound"},{"value":"0","type":"Number","label":"Area right bound","description":"The right bound of the area where objects can go in the scene (default to the game resolution).","group":"","extraInformation":[],"name":"AreaRightBound"},{"value":"0","type":"Number","label":"Area bottom bound","description":"The bottom bound of the area where objects can go in the scene (default to the game resolution).","group":"","extraInformation":[],"name":"AreaBottomBound"},{"value":"","type":"Number","label":"","description":"","group":"","extraInformation":[],"hidden":true,"name":"IsometricRatio"}]},{"description":"Change the animation according to the movement direction.","fullName":"Navigation mesh pathfinding animator","name":"NavMeshPathfindingAnimator","objectType":"","eventsFunctions":[{"fullName":"","functionType":"Action","name":"onActivate","sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"NavMeshPathfinding::NavMeshPathfindingAnimator::SetAnimationDirection"},"parameters":["Object","Behavior","Object.Behavior::Direction()",""]}]}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"NavMeshPathfinding::NavMeshPathfindingAnimator","type":"behavior"}],"objectGroups":[]},{"fullName":"","functionType":"Action","name":"doStepPostEvents","sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"NavMeshPathfinding::NavMeshPathfindingBehavior::Speed"},"parameters":["Object","NavMeshPathfinding","=","0",""]}],"actions":[{"type":{"value":"AnimatableCapability::AnimatableBehavior::PauseAnimation"},"parameters":["Object","Animation"]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"NavMeshPathfinding::NavMeshPathfindingBehavior::Speed"},"parameters":["Object","NavMeshPathfinding",">","0",""]}],"actions":[{"type":{"value":"AnimatableCapability::AnimatableBehavior::PlayAnimation"},"parameters":["Object","Animation"]}],"events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"NavMeshPathfinding::NavMeshPathfindingAnimator::PropertyIsScalingAnimation"},"parameters":["Object","Behavior"]}],"actions":[{"type":{"value":"NavMeshPathfinding::NavMeshPathfindingAnimator::SetAnimationSpeedScale"},"parameters":["Object","Behavior",""]}]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetNumberVariable"},"parameters":["NewAnimationDirection","=","Object.Behavior::Direction()"]}],"events":[{"type":"BuiltinCommonInstructions::Comment","color":{"b":109,"g":230,"r":255,"textB":0,"textG":0,"textR":0},"comment":"Use a small margin is used to avoid to flicker between 2 directions."},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"BuiltinCommonInstructions::CompareNumbers"},"parameters":["abs(Object.Behavior::DirectionDifference(NewAnimationDirection, AnimationDirection))",">","0.5 + 0.03125"]}],"actions":[{"type":{"value":"NavMeshPathfinding::NavMeshPathfindingAnimator::SetAnimationDirection"},"parameters":["Object","Behavior","NewAnimationDirection",""]}]}],"variables":[{"folded":true,"name":"NewAnimationDirection","type":"number","value":0.0}]}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"NavMeshPathfinding::NavMeshPathfindingAnimator","type":"behavior"}],"objectGroups":[]},{"description":"the animation name of the object.","fullName":"Animation name","functionType":"ExpressionAndCondition","name":"AnimationName","sentence":"the animation name","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetReturnString"},"parameters":["AnimationName"]}]}],"expressionType":{"type":"string"},"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"NavMeshPathfinding::NavMeshPathfindingAnimator","type":"behavior"}],"objectGroups":[]},{"fullName":"","functionType":"ActionWithOperator","getterName":"AnimationName","name":"SetAnimationName","sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"NavMeshPathfinding::NavMeshPathfindingAnimator::PropertyAnimationName"},"parameters":["Object","Behavior","!=","Value"]}],"actions":[{"type":{"value":"NavMeshPathfinding::NavMeshPathfindingAnimator::SetPropertyAnimationName"},"parameters":["Object","Behavior","=","Value"]},{"type":{"value":"AnimatableCapability::AnimatableBehavior::SetName"},"parameters":["Object","Animation","=","AnimationName + ToString(AnimationDirection)"]}]}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"NavMeshPathfinding::NavMeshPathfindingAnimator","type":"behavior"}],"objectGroups":[]},{"description":"Check if the animation is scaled according to speed.","fullName":"Scale animation according to speed","functionType":"Condition","name":"IsScalingAnimation","sentence":"_PARAM0_ animation is scaled according to speed","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"NavMeshPathfinding::NavMeshPathfindingAnimator::PropertyIsScalingAnimation"},"parameters":["Object","Behavior"]}],"actions":[{"type":{"value":"SetReturnBoolean"},"parameters":["True"]}]}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"NavMeshPathfinding::NavMeshPathfindingAnimator","type":"behavior"}],"objectGroups":[]},{"description":"Change whether the animation is scaled according to speed or not.","fullName":"Scale animation according to speed","functionType":"Action","name":"SetIsScalingAnimation","sentence":"Scale the animation of _PARAM0_ according to speed: _PARAM2_","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"inverted":true,"value":"GetArgumentAsBoolean"},"parameters":["\"Value\""]}],"actions":[{"type":{"value":"NavMeshPathfinding::NavMeshPathfindingAnimator::SetPropertyIsScalingAnimation"},"parameters":["Object","Behavior","no"]},{"type":{"value":"AnimatableCapability::AnimatableBehavior::SetSpeedScale"},"parameters":["Object","Animation","=","1"]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"GetArgumentAsBoolean"},"parameters":["\"Value\""]}],"actions":[{"type":{"value":"NavMeshPathfinding::NavMeshPathfindingAnimator::SetPropertyIsScalingAnimation"},"parameters":["Object","Behavior","yes"]},{"type":{"value":"NavMeshPathfinding::NavMeshPathfindingAnimator::SetAnimationSpeedScale"},"parameters":["Object","Behavior",""]}]}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"NavMeshPathfinding::NavMeshPathfindingAnimator","type":"behavior"},{"defaultValue":"yes","description":"IsScalingAnimation","name":"Value","optional":true,"type":"yesorno"}],"objectGroups":[]},{"description":"Change the animation speed scale according to the object speed.","fullName":"Animation speed scale","functionType":"Action","name":"SetAnimationSpeedScale","private":true,"sentence":"Change the animation speed scale according to _PARAM0_ speed","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"AnimatableCapability::AnimatableBehavior::SetSpeedScale"},"parameters":["Object","Animation","=","Object.NavMeshPathfinding::Speed() / Object.NavMeshPathfinding::MaxSpeed()"]}]}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"NavMeshPathfinding::NavMeshPathfindingAnimator","type":"behavior"}],"objectGroups":[]},{"description":"Return the object movement direction.","fullName":"Direction","functionType":"Expression","name":"Direction","private":true,"sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetReturnNumber"},"parameters":["(Object.NavMeshPathfinding::MovementAngle() + AngleOffset) * DirectionCount / 360"]}]}],"expressionType":{"type":"expression"},"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"NavMeshPathfinding::NavMeshPathfindingAnimator","type":"behavior"}],"objectGroups":[]},{"description":"Return the difference between 2 directions.","fullName":"Direction dirrerence","functionType":"Expression","name":"DirectionDifference","private":true,"sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetReturnNumber"},"parameters":["mod(mod(Direction - OtherDirection, DirectionCount) + DirectionCount / 2, DirectionCount) - DirectionCount / 2"]}]}],"expressionType":{"type":"expression"},"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"NavMeshPathfinding::NavMeshPathfindingAnimator","type":"behavior"},{"description":"Direction","name":"Direction","type":"expression"},{"description":"Other direction","name":"OtherDirection","type":"expression"}],"objectGroups":[]},{"description":"Change the animation direction of the object.","fullName":"Animation direction","functionType":"Action","name":"SetAnimationDirection","private":true,"sentence":"Change the animation direction of _PARAM0_ to _PARAM2_","events":[{"type":"BuiltinCommonInstructions::Comment","color":{"b":109,"g":230,"r":255,"textB":0,"textG":0,"textR":0},"comment":"Change the animation but keep the current frame number."},{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"NavMeshPathfinding::NavMeshPathfindingAnimator::SetPropertyAnimationDirection"},"parameters":["Object","Behavior","=","mod(mod(round(Value), DirectionCount) + DirectionCount, DirectionCount)"]},{"type":{"value":"SetNumberVariable"},"parameters":["AnimationElapsedTime","=","Object.Animation::ElapsedTime()"]},{"type":{"value":"AnimatableCapability::AnimatableBehavior::SetName"},"parameters":["Object","Animation","=","AnimationName + ToString(AnimationDirection)"]},{"type":{"value":"AnimatableCapability::AnimatableBehavior::SetElapsedTime"},"parameters":["Object","Animation","=","AnimationElapsedTime"]}],"variables":[{"folded":true,"name":"AnimationElapsedTime","type":"number","value":0.0}]}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"NavMeshPathfinding::NavMeshPathfindingAnimator","type":"behavior"},{"description":"Value","name":"Value","type":"expression"}],"objectGroups":[]}],"propertyDescriptors":[{"value":"","type":"Behavior","label":"Animatable capability","description":"","group":"","extraInformation":["AnimatableCapability::AnimatableBehavior"],"name":"Animation"},{"value":"","type":"Behavior","label":"Navigation mesh pathfinding","description":"","group":"","extraInformation":["NavMeshPathfinding::NavMeshPathfindingBehavior"],"name":"NavMeshPathfinding"},{"value":"true","type":"Boolean","label":"Scale animation according to speed","description":"","group":"Animation","extraInformation":[],"name":"IsScalingAnimation"},{"value":"Walk","type":"String","label":"Animation name","description":"Animations must be called \"Walk0\", \"Walk1\"... for left, down...","group":"Animation","extraInformation":[],"name":"AnimationName"},{"value":"8","type":"Number","unit":"Dimensionless","label":"Number of directions","description":"","group":"Direction","extraInformation":[],"name":"DirectionCount"},{"value":"0","type":"Number","unit":"DegreeAngle","label":"Angle offset","description":"Set to 90, \"Walk0\" becomes the animation for down.","group":"Direction","extraInformation":[],"name":"AngleOffset"},{"value":"0","type":"Number","label":"","description":"","group":"","extraInformation":[],"hidden":true,"name":"AnimationDirection"}],"sharedPropertyDescriptors":[]}],"eventsBasedObjects":[]},{"author":"jack, DHsoftware, @Bouh","category":"User interface","extensionNamespace":"","fullName":"Iframe","helpPath":"","iconUrl":"data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiBpZD0ibWRpLWlmcmFtZS1hcnJheS1vdXRsaW5lIiB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCI+PHBhdGggZD0iTTIxIDJIM0MxLjkgMiAxIDIuOSAxIDRWMjBDMSAyMS4xIDEuOSAyMiAzIDIySDIxQzIyLjEgMjIgMjMgMjEuMSAyMyAyMFY0QzIzIDIuOSAyMi4xIDIgMjEgMk0yMSAyMEgzVjZIMjFWMjBNNiA4VjE4SDEwVjE2SDhWMTBIMTBWOEg2TTE2IDE2SDE0VjE4SDE4VjhIMTRWMTBIMTZWMTYiIC8+PC9zdmc+","name":"Iframe","previewIconUrl":"https://resources.gdevelop-app.com/assets/Icons/iframe-array-outline.svg","shortDescription":"Create or delete an iframe to embed websites.","version":"1.0.0","description":["This extension allows you to set up and create Iframes to show websites on your game.","","New action in this extension:","- Create an iFrame","- Delete an iFrame","","For security reasons on browsers, some websites can be limited if the host and the iFrame do not have the same origin. ","Read more: [Same-origin policy](https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy)"],"origin":{"identifier":"Iframe","name":"gdevelop-extension-store"},"tags":["browser","iframe","dom apis","online"],"authorIds":["2OwwM8ToR9dx9RJ2sAKTcrLmCB92","kImlRGnf8uU4FlHfeGpkHoCxIfn2"],"dependencies":[],"globalVariables":[],"sceneVariables":[],"eventsFunctions":[{"description":"Create a new Iframe to embed a website inside the game.","fullName":"Create an Iframe","functionType":"Action","name":"Create","sentence":"Create Iframe _PARAM1_ at position _PARAM5_:_PARAM6_, width: _PARAM3_, height: _PARAM4_, url: _PARAM2_","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"BuiltinCommonInstructions::Once"},"parameters":[]}],"actions":[],"events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["const iframe = document.createElement(\"iframe\");","","iframe.src = eventsFunctionContext.getArgument(\"WebsiteURL\");","iframe.id = eventsFunctionContext.getArgument(\"Name\");","iframe.setAttribute(\"width\", eventsFunctionContext.getArgument(\"Width\"));","iframe.setAttribute(\"height\", eventsFunctionContext.getArgument(\"Height\"));","iframe.style.top = eventsFunctionContext.getArgument(\"PositionY\") + \"px\";","iframe.style.left = eventsFunctionContext.getArgument(\"PositionX\") + \"px\";","iframe.frameBorder = eventsFunctionContext.getArgument(\"Border\");","iframe.frameBorder == \"true\" ? iframe.frameBorder = \"yes\" : iframe.frameBorder = \"no\";","iframe.scrolling = eventsFunctionContext.getArgument(\"Scrolling\");","iframe.scrolling == \"true\" ? iframe.scrolling = \"yes\" : iframe.scrolling = \"no\";","iframe.style.position = \"absolute\";","","iframe.style.cssText += eventsFunctionContext.getArgument(\"ExtraCSS\");","","","document.body.appendChild(iframe);",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}]}],"parameters":[{"description":"Name (DOM id)","name":"Name","type":"string"},{"description":"URL","name":"WebsiteURL","type":"string"},{"description":"Width","name":"Width","type":"expression"},{"description":"Height","name":"Height","type":"expression"},{"description":"Position X","name":"PositionX","type":"expression"},{"description":"Position Y","name":"PositionY","type":"expression"},{"description":"Show scrollbar","name":"Scrolling","supplementaryInformation":"[\"no\",\"yes\"]","type":"yesorno"},{"description":"Show border","name":"Border","supplementaryInformation":"[\"yes\",\"no\"]","type":"yesorno"},{"description":"Extra CSS styles (optional)","longDescription":"e.g: `\"border: 10px #f00 solid;\"`","name":"ExtraCSS","type":"string"}],"objectGroups":[]},{"description":"Delete the specified Iframe.","fullName":"Delete an Iframe","functionType":"Action","name":"Delete","sentence":"Delete Iframe _PARAM1_","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"BuiltinCommonInstructions::Once"},"parameters":[]}],"actions":[],"events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":"document.getElementById(eventsFunctionContext.getArgument(\"Name\")).remove();","parameterObjects":"","useStrict":true,"eventsSheetExpanded":false}]}],"parameters":[{"description":"Name (DOM id)","name":"Name","type":"string"}],"objectGroups":[]}],"eventsBasedBehaviors":[],"eventsBasedObjects":[]},{"author":"","category":"","extensionNamespace":"","fullName":"With Three JS","helpPath":"https://pandako.itch.io/with-threejs-extension-for-gdevelop","iconUrl":"data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiBpZD0ibWRpLXJvdGF0ZS0zZCIgd2lkdGg9IjI0IiBoZWlnaHQ9IjI0IiB2aWV3Qm94PSIwIDAgMjQgMjQiPjxwYXRoIGQ9Ik03LjQ3LDIxLjVDNC4yLDE5Ljk0IDEuODYsMTYuNzYgMS41LDEzSDBDMC41LDE5LjE2IDUuNjYsMjQgMTEuOTUsMjRMMTIuNjEsMjMuOTdMOC44LDIwLjE2TDcuNDcsMjEuNU04LjM2LDE0Ljk2QzguMTcsMTQuOTYgOCwxNC45MyA3Ljg0LDE0Ljg4QzcuNjgsMTQuODIgNy41NSwxNC43NSA3LjQ0LDE0LjY0QzcuMzMsMTQuNTQgNy4yNCwxNC40MiA3LjE4LDE0LjI3QzcuMTIsMTQuMTMgNy4wOSwxMy45NyA3LjA5LDEzLjhINS43OUM1Ljc5LDE0LjE2IDUuODYsMTQuNSA2LDE0Ljc1QzYuMTQsMTUgNi4zMywxNS4yNSA2LjU2LDE1LjQ0QzYuOCwxNS42MiA3LjA3LDE1Ljc2IDcuMzgsMTUuODVDNy42OCwxNS45NSA4LDE2IDguMzQsMTZDOC43MSwxNiA5LjA2LDE1Ljk1IDkuMzcsMTUuODVDOS42OSwxNS43NSA5Ljk3LDE1LjYgMTAuMiwxNS40MUMxMC40MywxNS4yMiAxMC42MiwxNSAxMC43NSwxNC42OUMxMC44OCwxNC40IDEwLjk1LDE0LjA4IDEwLjk1LDEzLjcyQzEwLjk1LDEzLjUzIDEwLjkzLDEzLjM0IDEwLjg4LDEzLjE2QzEwLjgzLDEzIDEwLjc2LDEyLjgxIDEwLjY1LDEyLjY1QzEwLjU1LDEyLjUgMTAuNDEsMTIuMzUgMTAuMjUsMTIuMjJDMTAuMDgsMTIuMDkgOS44OCwxMiA5LjY0LDExLjkxQzkuODQsMTEuODIgMTAsMTEuNzEgMTAuMTYsMTEuNThDMTAuMzEsMTEuNDUgMTAuNDMsMTEuMzEgMTAuNTMsMTEuMTZDMTAuNjMsMTEgMTAuNywxMC44NiAxMC43NSwxMC43QzEwLjgsMTAuNTQgMTAuODIsMTAuMzggMTAuODIsMTAuMjJDMTAuODIsOS44NiAxMC43Niw5LjU0IDEwLjY0LDkuMjZDMTAuNSw5IDEwLjM1LDguNzUgMTAuMTMsOC41N0M5LjkzLDguMzggOS42Niw4LjI0IDkuMzYsOC4xNEM5LjA1LDguMDUgOC43MSw4IDguMzQsOEM4LDggNy42NSw4LjA1IDcuMzQsOC4xNkM3LjA0LDguMjcgNi43Nyw4LjQyIDYuNTUsOC42MUM2LjM0LDguOCA2LjE3LDkgNi4wNCw5LjI4QzUuOTIsOS41NCA1Ljg2LDkuODIgNS44NiwxMC4xM0g3LjE2QzcuMTYsOS45NiA3LjE5LDkuODEgNy4yNSw5LjY4QzcuMzEsOS41NSA3LjM5LDkuNDMgNy41LDkuMzRDNy42MSw5LjI1IDcuNzMsOS4xNyA3Ljg4LDkuMTJDOC4wMyw5LjA3IDguMTgsOS4wNCA4LjM2LDkuMDRDOC43Niw5LjA0IDkuMDYsOS4xNCA5LjI1LDkuMzVDOS40NCw5LjU1IDkuNTQsOS44NCA5LjU0LDEwLjIxQzkuNTQsMTAuMzkgOS41LDEwLjU1IDkuNDYsMTAuN0M5LjQxLDEwLjg1IDkuMzIsMTAuOTcgOS4yMSwxMS4wN0M5LjEsMTEuMTcgOC45NiwxMS4yNSA4LjgsMTEuMzFDOC42NCwxMS4zNyA4LjQ0LDExLjQgOC4yMiwxMS40SDcuNDVWMTIuNDNIOC4yMkM4LjQ0LDEyLjQzIDguNjQsMTIuNDUgOC44MiwxMi41QzksMTIuNTUgOS4xNSwxMi42MyA5LjI3LDEyLjczQzkuMzksMTIuODQgOS41LDEyLjk3IDkuNTYsMTMuMTNDOS42MywxMy4yOSA5LjY2LDEzLjUgOS42NiwxMy43QzkuNjYsMTQuMTEgOS41NCwxNC40MiA5LjMxLDE0LjYzQzkuMDgsMTQuODYgOC43NiwxNC45NiA4LjM2LDE0Ljk2TTE2LjkxLDkuMDRDMTYuNTksOC43MSAxNi4yMSw4LjQ1IDE1Ljc3LDguMjdDMTUuMzQsOC4wOSAxNC44NSw4IDE0LjMxLDhIMTEuOTVWMTZIMTQuMjVDMTQuOCwxNiAxNS4zMSwxNS45MSAxNS43NiwxNS43M0MxNi4yMSwxNS41NSAxNi42LDE1LjMgMTYuOTIsMTQuOTdDMTcuMjQsMTQuNjQgMTcuNSwxNC4yNCAxNy42NiwxMy43OEMxNy44MywxMy4zMSAxNy45MiwxMi43OSAxNy45MiwxMi4yMVYxMS44MUMxNy45MiwxMS4yMyAxNy44MywxMC43MSAxNy42NiwxMC4yNEMxNy41LDkuNzcgMTcuMjMsOS4zNyAxNi45MSw5LjA0TTE2LjUsMTIuMkMxNi41LDEyLjYyIDE2LjQ3LDEzIDE2LjM4LDEzLjMzQzE2LjI4LDEzLjY2IDE2LjE0LDEzLjk1IDE1Ljk1LDE0LjE4QzE1Ljc2LDE0LjQxIDE1LjUsMTQuNTkgMTUuMjQsMTQuNzFDMTQuOTUsMTQuODMgMTQuNjIsMTQuODkgMTQuMjUsMTQuODlIMTMuMzRWOS4xMkgxNC4zMUMxNS4wMyw5LjEyIDE1LjU4LDkuMzUgMTUuOTUsOS44MUMxNi4zMywxMC4yNyAxNi41LDEwLjkzIDE2LjUsMTEuOE0xMS45NSwwTDExLjI5LDAuMDNMMTUuMSwzLjg0TDE2LjQzLDIuNUMxOS43LDQuMDYgMjIuMDQsNy4yMyAyMi4zOSwxMUgyMy44OUMyMy4zOSw0Ljg0IDE4LjI0LDAgMTEuOTUsMFoiIC8+PC9zdmc+","name":"WithThreeJS","previewIconUrl":"https://resources.gdevelop-app.com/assets/Icons/rotate-3d.svg","shortDescription":"Create a simple 3D scene.","version":"2.0.2","description":["Extension for GDevelop to create simple 3D scenes.  ","This extension is intended for easy and simple 3D rendering. It does not currently aim for realistic 3D rendering.  ","","##  How to use  ","Check out this page.  ","[WithThreeJs Extension for GDevelop](https://pandako.itch.io/with-threejs-extension-for-gdevelop)  ","","##  Notes on updating from version 1.x.x to version 2.0.0  ","The \"Create 3D Scene\", \"Load 3D Texture\", \"Play 3D Sound\" and \"Create 3D Light\" actions have been updated in version 2.0.0.  ","The previous actions with the same names still work but are deprecated. (Look for the  icon in the event.) Please use the new actions with the same names.  ","","##  Donation  ","Currently, I'm doing development in between jobs, but if many people support me, I will be able to devote more time to the development.  ","If you enjoy this extension, please consider [downloading the Example project file](https://pandako.itch.io/with-threejs-extension-for-gdevelop) to maintain this extension. (The Example project file will surely help you.)  ","","## Three.js  ","Copyright 2010-2022 Three.js Authors  ","https://github.com/mrdoob/three.js/blob/dev/LICENSE"],"origin":{"identifier":"WithThreeJS","name":"gdevelop-extension-store"},"tags":["3d"],"authorIds":["Zu55H5hcb9YmZTltIVOTAFDJQyB2"],"dependencies":[],"globalVariables":[],"sceneVariables":[],"eventsFunctions":[{"fullName":"","functionType":"Action","name":"onFirstSceneLoaded","sentence":"","events":[{"type":"BuiltinCommonInstructions::Comment","color":{"b":109,"g":230,"r":255,"textB":0,"textG":0,"textR":0},"comment":"Three.js"},{"type":"BuiltinCommonInstructions::Comment","color":{"b":109,"g":230,"r":255,"textB":0,"textG":0,"textR":0},"comment":"WithThreeJS"},{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["gdjs.__WithThreeJS = new Map();\r","gdjs.__WithThreeJS.set(\"NoTHREE\", typeof THREE != \"object\");\r","gdjs.__WithThreeJS.set(\"BuiltIn3D\", (runtimeScene.getRenderer()._threeRenderer ? true : false));\r","if (gdjs.__WithThreeJS.get(\"NoTHREE\")) {\r","  return;\r","}\r","//\r","THREE.Cache.enabled = true;// \r","//\r","gdjs.__WithThreeJS.set(\"SceneIsReady\", false);\r","gdjs.__WithThreeJS.set(\"Blend2Dto3D\", [THREE.NormalBlending, THREE.AdditiveBlending, THREE.MultiplyBlending, THREE.NormalBlending, THREE.SubtractiveBlending]);// PixiJSSUBTRACT28\r","if (THREE.REVISION == \"152\") {\r","  gdjs.__WithThreeJS.set(\"LightIntensityScale\", 1);\r","  gdjs.__WithThreeJS.set(\"LightIntensityCandela\", 1);\r","} else {\r","  // >= \"160\"\r","  gdjs.__WithThreeJS.set(\"LightIntensityScale\", Math.PI);\r","  gdjs.__WithThreeJS.set(\"LightIntensityCandela\", 10000);//\r","}\r","gdjs.__WithThreeJS.set(\"ShadowMapSizeStringToValue\", {\"128px\": 128, \"256px\": 256, \"512px\": 512, \"1024px\": 1024, \"2048px\": 2048});\r","gdjs.__WithThreeJS.set(\"ObjectList\", new Map());\r","//\r","gdjs.__WithThreeJS.set(\"SearchObject\", function(Id) {\r","  let Obj = gdjs.__WithThreeJS.get(\"ObjectList\").get(Id);\r","  if (!Obj) {\r","    Obj = gdjs.__WithThreeJS.get(\"Scene\").getObjectByName(Id);\r","    if (Obj) {\r","      gdjs.__WithThreeJS.get(\"ObjectList\").set(Id, Obj);\r","    }\r","  }\r","  return Obj;\r","});\r","//\r","gdjs.__WithThreeJS.set(\"GetResourceFileName\", function(ResourceName, Kind) {\r","  for (const V of gdjs.projectData.resources.resources) {\r","    if (V.name === ResourceName && V.kind === Kind) {\r","      return V.file;\r","    }\r","  }\r","});\r","//\r","gdjs.__WithThreeJS.set(\"SetAllTextures\", function(Obj, Textures) {\r","  const TxNum = Textures.length;\r","  Obj.traverse((Child) => {\r","    if (Child.material) {\r","      if (Array.isArray(Child.material)) {\r","        for (let i = 0; i < Child.material.length; i++) {\r","          if (i < TxNum && (Child.material[i].map !== undefined)) {\r","            Child.material[i].map = Textures[i];\r","          }\r","        }\r","      } else {\r","        if (Child.material.map !== undefined) {\r","          Child.material.map = Textures[0];\r","        }\r","      }\r","    }\r","  });\r","});\r","//\r","gdjs.__WithThreeJS.set(\"GetModelInfo\", function(Obj, T, Lv) {\r","  const Indent = \" \".repeat(Lv * 2);\r","  T += Indent + \"---\\n\";\r","  T += Indent + \"Name: \" + Obj.name + \"\\n\";\r","  T += Indent + \"Type: \" + Obj.type + \"\\n\";\r","  for (let i = 0; i < Obj.animations.length; i++) {\r","    T += Indent + \"Animation \" + i + \": \" + Obj.animations[i].name + \"\\n\";\r","  }\r","  if (Obj.material) {\r","    if (Array.isArray(Obj.material)) {\r","      for (let i = 0; i < Obj.material.length; i++) {\r","        T += Indent + \"Material \" + (i + 1) + \": \" + Obj.material[i].name + \"\\n\";\r","      }\r","    } else {\r","      T += Indent + \"Material 1: \" + Obj.material.name + \"\\n\";\r","    }\r","  }\r","  //\r","  for (let i = 0; i < Obj.children.length; i++) {\r","    T = gdjs.__WithThreeJS.get(\"GetModelInfo\")(Obj.children[i], T, Lv + 1);\r","  }\r","  return T;\r","});\r","//\r","// \r","gdjs.__WithThreeJS.set(\"GetAllMaterials\", function(Obj, Mats) {\r","  Obj.traverse((Child) => {\r","    if (Child.material) {\r","      if (Array.isArray(Child.material)) {\r","        for (let i = 0; i < Child.material.length; i++) {\r","          if (!Mats.has(Child.material[i].uuid)) {\r","            Mats.set(Child.material[i].uuid, Child.material[i]);\r","          }\r","        }\r","      } else {\r","        if (!Mats.has(Child.material.uuid)) {\r","          Mats.set(Child.material.uuid, Child.material);\r","        }\r","      }\r","    }\r","  });\r","});\r","// \r","gdjs.__WithThreeJS.set(\"ReplaceMaterial\", function(Obj, Mats) {\r","  Obj.traverse((Child) => {\r","    if (Child.material) {\r","      if (Array.isArray(Child.material)) {\r","        for (let i = 0; i < Child.material.length; i++) {\r","          if (Mats.has(Child.material[i].uuid)) {\r","            Child.material[i] = Mats.get(Child.material[i].uuid);\r","          }\r","        }\r","      } else {\r","        if (Mats.has(Child.material.uuid)) {\r","          Child.material = Mats.get(Child.material.uuid);\r","        }\r","      }\r","    }\r","  });\r","});\r","//\r","gdjs.__WithThreeJS.set(\"GetAllObjectsName\", function(Obj, T, Lv) {\r","  const Indent = \" \".repeat(Lv * 2);\r","  T += Indent + \"ID: \" + Obj.name + \"\\n\";\r","  //\r","  for (let i = 0; i < Obj.children.length; i++) {\r","    T = gdjs.__WithThreeJS.get(\"GetAllObjectsName\")(Obj.children[i], T, Lv + 1);\r","  }\r","  return T;\r","});\r","//\r","gdjs.__WithThreeJS.set(\"GetSingleRadian3\", function(Obj) {\r","  /*\r","  3D Camera Angle \r","  XYZ\r","  XYZ\r","  */\r","  const HalfPi = Math.PI / 2;/* Pi / 2 = 90 */\r","  // X\r","  // \r","  const DirObj = new THREE.Vector3(0, 0, -1);\r","  DirObj.applyQuaternion(Obj.quaternion);\r","  const UpObj = new THREE.Vector3(0, 1, 0);\r","  UpObj.applyQuaternion(Obj.quaternion);\r","  // M4\r","  const M4 = new THREE.Matrix4();\r","  M4.lookAt(new THREE.Vector3(), DirObj, new THREE.Vector3(0, 1, 0));\r","  // M4Qua\r","  const Qua = new THREE.Quaternion();\r","  Qua.setFromRotationMatrix(M4);\r","  const Up = new THREE.Vector3(0, 1, 0);\r","  Up.applyQuaternion(Qua);\r","  // \r","  const DirObjY0 = DirObj.clone();\r","  DirObjY0.y = 0;// DirObjY0.projectOnPlane(new THREE.Vector3(0, 1, 0));// y=0\r","  DirObjY0.normalize();\r","  // X\r","  let RadX = DirObjY0.angleTo(DirObj);\r","  // 90\r","  const UpToUp = UpObj.angleTo(Up);\r","  if (UpToUp >= HalfPi) {\r","    RadX = (HalfPi - RadX) + HalfPi;\r","  }\r","  // +-\r","  if (DirObj.y < 0) {\r","    RadX *= -1;\r","  }\r","  //\r","  // Y\r","  let RadY = new THREE.Vector3(0, 0, -1).angleTo(DirObjY0);\r","  if (DirObj.x > 0) {\r","    RadY *= -1;\r","  }\r","  //\r","  // Z\r","  let RadZ = UpToUp;\r","  // +-\r","  const Cross = new THREE.Vector3();\r","  Cross.crossVectors(UpObj, Up);\r","  if (Cross.angleTo(DirObj) >= HalfPi) {\r","    RadZ *= -1;\r","  }\r","  //\r","  return new THREE.Vector3(RadX, RadY, RadZ);\r","});\r","//\r","gdjs.__WithThreeJS.set(\"SetBoundingBoxCollisionResult\", function(Obj1, Obj2) {\r","  if (!gdjs.__WithThreeJS.has(\"BoundingBoxCollisionResult\")) {\r","      gdjs.__WithThreeJS.set(\"BoundingBoxCollisionResult\", {});\r","  }\r","  const BoundingBoxCollisionResult = gdjs.__WithThreeJS.get(\"BoundingBoxCollisionResult\");\r","  BoundingBoxCollisionResult.Hit = false;\r","  BoundingBoxCollisionResult.CenterX = 0;\r","  BoundingBoxCollisionResult.CenterY = 0;\r","  BoundingBoxCollisionResult.CenterZ = 0;\r","  BoundingBoxCollisionResult.SizeX = 0;\r","  BoundingBoxCollisionResult.SizeY = 0;\r","  BoundingBoxCollisionResult.SizeZ = 0;\r","  BoundingBoxCollisionResult.MoveX = 0;\r","  BoundingBoxCollisionResult.MoveY = 0;\r","  BoundingBoxCollisionResult.MoveZ = 0;\r","  //\r","  // geometrySpritegeometry\r","  const Geo1 = Obj1.geometry;\r","  const Geo2 = Obj2.geometry;\r","  if (!Geo1 || !Geo2) {\r","      console.warn(\"Geometry not found: \" + Obj1.name + \" or \" + Obj2.name);\r","      return BoundingBoxCollisionResult;\r","  }\r","  //\r","  const Box1 = new THREE.Box3();\r","  const Box2 = new THREE.Box3();\r","  // Box1.setFromObject(Obj1, false);\r","  // Box2.setFromObject(Obj2, false);\r","  Obj1.updateMatrixWorld(true);//\r","  Obj2.updateMatrixWorld(true);//\r","  Box1.copy(Geo1.boundingBox).applyMatrix4(Obj1.matrixWorld);\r","  Box2.copy(Geo2.boundingBox).applyMatrix4(Obj2.matrixWorld);\r","  //\r","  const HitBox = Box1.clone();\r","  HitBox.intersect(Box2);\r","  if (HitBox.isEmpty()) {\r","      return BoundingBoxCollisionResult;\r","  }\r","  //\r","  const Box1Center = new THREE.Vector3();\r","  const Box2Center = new THREE.Vector3();\r","  const HitCenter = new THREE.Vector3();\r","  const HitSize = new THREE.Vector3();\r","  Box1.getCenter(Box1Center);\r","  Box2.getCenter(Box2Center);\r","  HitBox.getCenter(HitCenter);\r","  HitBox.getSize(HitSize);\r","  //\r","  let MoveValue = {x:0, y:0, z:0};\r","  if (HitSize.x <= HitSize.y && HitSize.x <= HitSize.z) {\r","      if (Box1Center.x > Box2Center.x) {\r","          MoveValue.x = HitSize.x;\r","      } else {\r","          MoveValue.x = HitSize.x * -1;\r","      }\r","  } else if (HitSize.y <= HitSize.x && HitSize.y <= HitSize.z) {\r","      if (Box1Center.y > Box2Center.y) {\r","          MoveValue.y = HitSize.y;\r","      } else {\r","          MoveValue.y = HitSize.y * -1;\r","      }\r","  } else if (HitSize.z <= HitSize.x && HitSize.z <= HitSize.y) {\r","      if (Box1Center.z > Box2Center.z) {\r","          MoveValue.z = HitSize.z;\r","      } else {\r","          MoveValue.z = HitSize.z * -1;\r","      }\r","  }\r","  //\r","  BoundingBoxCollisionResult.Hit = true;\r","  BoundingBoxCollisionResult.CenterX = HitCenter.x;\r","  BoundingBoxCollisionResult.CenterY = HitCenter.y;\r","  BoundingBoxCollisionResult.CenterZ = HitCenter.z;\r","  BoundingBoxCollisionResult.SizeX = HitSize.x;\r","  BoundingBoxCollisionResult.SizeY = HitSize.y;\r","  BoundingBoxCollisionResult.SizeZ = HitSize.z;\r","  BoundingBoxCollisionResult.MoveX = MoveValue.x;\r","  BoundingBoxCollisionResult.MoveY = MoveValue.y;\r","  BoundingBoxCollisionResult.MoveZ = MoveValue.z;\r","  return BoundingBoxCollisionResult;\r","});\r","//\r","gdjs.__WithThreeJS.set(\"GetCamera\", function(Id) {\r","  const AllCams = gdjs.__WithThreeJS.get(\"AllCams\");\r","  return AllCams.get(\"Camera\" + gdjs.evtTools.common.clamp(Id, 1, 4));\r","});\r","//\r","gdjs.__WithThreeJS.set(\"DisposeChildren\", function(Obj) {\r","  // \r","  Obj.traverse((Child) => {\r","      // Material\r","      if (Child.material) {\r","          if (Array.isArray(Child.material)) {\r","              for (let i = Child.material.length - 1; i >= 0; i--){\r","                  Child.material[i].dispose();\r","              }\r","          } else {\r","              Child.material.dispose();\r","          }\r","      }\r","      // Light\r","      if (Child.isLight) {\r","          if (Child.castShadow) {\r","              Child.shadow.dispose();\r","          }\r","          Child.dispose();\r","      }\r","      // ObjectList\r","      gdjs.__WithThreeJS.get(\"ObjectList\").delete(Child.name);\r","  });\r","});\r","\r",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true},{"type":"BuiltinCommonInstructions::Comment","color":{"b":109,"g":230,"r":255,"textB":0,"textG":0,"textR":0},"comment":"OBJLoader (Custom)"},{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["// Custom","if (gdjs.__WithThreeJS.get(\"NoTHREE\")) {","  return;","}","//","( function () {","","\tconst _object_pattern = /^[og]\\s*(.+)?/; // mtllib file_reference","","\tconst _material_library_pattern = /^mtllib /; // usemtl material_name","","\tconst _material_use_pattern = /^usemtl /; // usemap map_name","","\tconst _map_use_pattern = /^usemap /;","\tconst _face_vertex_data_separator_pattern = /\\s+/;","","\tconst _vA = new THREE.Vector3();","","\tconst _vB = new THREE.Vector3();","","\tconst _vC = new THREE.Vector3();","","\tconst _ab = new THREE.Vector3();","","\tconst _cb = new THREE.Vector3();","","\tconst _color = new THREE.Color();","","\tfunction ParserState() {","","\t\tconst state = {","\t\t\tobjects: [],","\t\t\tobject: {},","\t\t\tvertices: [],","\t\t\tnormals: [],","\t\t\tcolors: [],","\t\t\tuvs: [],","\t\t\tmaterials: {},","\t\t\tmaterialLibraries: [],","\t\t\tstartObject: function ( name, fromDeclaration ) {","","\t\t\t\t// If the current object (initial from reset) is not from a g/o declaration in the parsed","\t\t\t\t// file. We need to use it for the first parsed g/o to keep things in sync.","\t\t\t\tif ( this.object && this.object.fromDeclaration === false ) {","","\t\t\t\t\tthis.object.name = name;","\t\t\t\t\tthis.object.fromDeclaration = fromDeclaration !== false;","\t\t\t\t\treturn;","","\t\t\t\t}","","\t\t\t\tconst previousMaterial = this.object && typeof this.object.currentMaterial === 'function' ? this.object.currentMaterial() : undefined;","","\t\t\t\tif ( this.object && typeof this.object._finalize === 'function' ) {","","\t\t\t\t\tthis.object._finalize( true );","","\t\t\t\t}","","\t\t\t\tthis.object = {","\t\t\t\t\tname: name || '',","\t\t\t\t\tfromDeclaration: fromDeclaration !== false,","\t\t\t\t\tgeometry: {","\t\t\t\t\t\tvertices: [],","\t\t\t\t\t\tnormals: [],","\t\t\t\t\t\tcolors: [],","\t\t\t\t\t\tuvs: [],","\t\t\t\t\t\thasUVIndices: false","\t\t\t\t\t},","\t\t\t\t\tmaterials: [],","\t\t\t\t\tsmooth: true,","\t\t\t\t\tstartMaterial: function ( name, libraries ) {","","\t\t\t\t\t\tconst previous = this._finalize( false ); // New usemtl declaration overwrites an inherited material, except if faces were declared","\t\t\t\t\t\t// after the material, then it must be preserved for proper MultiMaterial continuation.","","","\t\t\t\t\t\tif ( previous && ( previous.inherited || previous.groupCount <= 0 ) ) {","","\t\t\t\t\t\t\tthis.materials.splice( previous.index, 1 );","","\t\t\t\t\t\t}","","\t\t\t\t\t\tconst material = {","\t\t\t\t\t\t\tindex: this.materials.length,","\t\t\t\t\t\t\tname: name || '',","\t\t\t\t\t\t\tmtllib: Array.isArray( libraries ) && libraries.length > 0 ? libraries[ libraries.length - 1 ] : '',","\t\t\t\t\t\t\tsmooth: previous !== undefined ? previous.smooth : this.smooth,","\t\t\t\t\t\t\tgroupStart: previous !== undefined ? previous.groupEnd : 0,","\t\t\t\t\t\t\tgroupEnd: - 1,","\t\t\t\t\t\t\tgroupCount: - 1,","\t\t\t\t\t\t\tinherited: false,","\t\t\t\t\t\t\tclone: function ( index ) {","","\t\t\t\t\t\t\t\tconst cloned = {","\t\t\t\t\t\t\t\t\tindex: typeof index === 'number' ? index : this.index,","\t\t\t\t\t\t\t\t\tname: this.name,","\t\t\t\t\t\t\t\t\tmtllib: this.mtllib,","\t\t\t\t\t\t\t\t\tsmooth: this.smooth,","\t\t\t\t\t\t\t\t\tgroupStart: 0,","\t\t\t\t\t\t\t\t\tgroupEnd: - 1,","\t\t\t\t\t\t\t\t\tgroupCount: - 1,","\t\t\t\t\t\t\t\t\tinherited: false","\t\t\t\t\t\t\t\t};","\t\t\t\t\t\t\t\tcloned.clone = this.clone.bind( cloned );","\t\t\t\t\t\t\t\treturn cloned;","","\t\t\t\t\t\t\t}","\t\t\t\t\t\t};","\t\t\t\t\t\tthis.materials.push( material );","\t\t\t\t\t\treturn material;","","\t\t\t\t\t},","\t\t\t\t\tcurrentMaterial: function () {","","\t\t\t\t\t\tif ( this.materials.length > 0 ) {","","\t\t\t\t\t\t\treturn this.materials[ this.materials.length - 1 ];","","\t\t\t\t\t\t}","","\t\t\t\t\t\treturn undefined;","","\t\t\t\t\t},","\t\t\t\t\t_finalize: function ( end ) {","","\t\t\t\t\t\tconst lastMultiMaterial = this.currentMaterial();","","\t\t\t\t\t\tif ( lastMultiMaterial && lastMultiMaterial.groupEnd === - 1 ) {","","\t\t\t\t\t\t\tlastMultiMaterial.groupEnd = this.geometry.vertices.length / 3;","\t\t\t\t\t\t\tlastMultiMaterial.groupCount = lastMultiMaterial.groupEnd - lastMultiMaterial.groupStart;","\t\t\t\t\t\t\tlastMultiMaterial.inherited = false;","","\t\t\t\t\t\t} // Ignore objects tail materials if no face declarations followed them before a new o/g started.","","","\t\t\t\t\t\tif ( end && this.materials.length > 1 ) {","","\t\t\t\t\t\t\tfor ( let mi = this.materials.length - 1; mi >= 0; mi -- ) {","","\t\t\t\t\t\t\t\tif ( this.materials[ mi ].groupCount <= 0 ) {","","\t\t\t\t\t\t\t\t\tthis.materials.splice( mi, 1 );","","\t\t\t\t\t\t\t\t}","","\t\t\t\t\t\t\t}","","\t\t\t\t\t\t} // Guarantee at least one empty material, this makes the creation later more straight forward.","","","\t\t\t\t\t\tif ( end && this.materials.length === 0 ) {","","\t\t\t\t\t\t\tthis.materials.push( {","\t\t\t\t\t\t\t\tname: '',","\t\t\t\t\t\t\t\tsmooth: this.smooth","\t\t\t\t\t\t\t} );","","\t\t\t\t\t\t}","","\t\t\t\t\t\treturn lastMultiMaterial;","","\t\t\t\t\t}","\t\t\t\t}; // Inherit previous objects material.","\t\t\t\t// Spec tells us that a declared material must be set to all objects until a new material is declared.","\t\t\t\t// If a usemtl declaration is encountered while this new object is being parsed, it will","\t\t\t\t// overwrite the inherited material. Exception being that there was already face declarations","\t\t\t\t// to the inherited material, then it will be preserved for proper MultiMaterial continuation.","","\t\t\t\tif ( previousMaterial && previousMaterial.name && typeof previousMaterial.clone === 'function' ) {","","\t\t\t\t\tconst declared = previousMaterial.clone( 0 );","\t\t\t\t\tdeclared.inherited = true;","\t\t\t\t\tthis.object.materials.push( declared );","","\t\t\t\t}","","\t\t\t\tthis.objects.push( this.object );","","\t\t\t},","\t\t\tfinalize: function () {","","\t\t\t\tif ( this.object && typeof this.object._finalize === 'function' ) {","","\t\t\t\t\tthis.object._finalize( true );","","\t\t\t\t}","","\t\t\t},","\t\t\tparseVertexIndex: function ( value, len ) {","","\t\t\t\tconst index = parseInt( value, 10 );","\t\t\t\treturn ( index >= 0 ? index - 1 : index + len / 3 ) * 3;","","\t\t\t},","\t\t\tparseNormalIndex: function ( value, len ) {","","\t\t\t\tconst index = parseInt( value, 10 );","\t\t\t\treturn ( index >= 0 ? index - 1 : index + len / 3 ) * 3;","","\t\t\t},","\t\t\tparseUVIndex: function ( value, len ) {","","\t\t\t\tconst index = parseInt( value, 10 );","\t\t\t\treturn ( index >= 0 ? index - 1 : index + len / 2 ) * 2;","","\t\t\t},","\t\t\taddVertex: function ( a, b, c ) {","","\t\t\t\tconst src = this.vertices;","\t\t\t\tconst dst = this.object.geometry.vertices;","\t\t\t\tdst.push( src[ a + 0 ], src[ a + 1 ], src[ a + 2 ] );","\t\t\t\tdst.push( src[ b + 0 ], src[ b + 1 ], src[ b + 2 ] );","\t\t\t\tdst.push( src[ c + 0 ], src[ c + 1 ], src[ c + 2 ] );","","\t\t\t},","\t\t\taddVertexPoint: function ( a ) {","","\t\t\t\tconst src = this.vertices;","\t\t\t\tconst dst = this.object.geometry.vertices;","\t\t\t\tdst.push( src[ a + 0 ], src[ a + 1 ], src[ a + 2 ] );","","\t\t\t},","\t\t\taddVertexLine: function ( a ) {","","\t\t\t\tconst src = this.vertices;","\t\t\t\tconst dst = this.object.geometry.vertices;","\t\t\t\tdst.push( src[ a + 0 ], src[ a + 1 ], src[ a + 2 ] );","","\t\t\t},","\t\t\taddNormal: function ( a, b, c ) {","","\t\t\t\tconst src = this.normals;","\t\t\t\tconst dst = this.object.geometry.normals;","\t\t\t\tdst.push( src[ a + 0 ], src[ a + 1 ], src[ a + 2 ] );","\t\t\t\tdst.push( src[ b + 0 ], src[ b + 1 ], src[ b + 2 ] );","\t\t\t\tdst.push( src[ c + 0 ], src[ c + 1 ], src[ c + 2 ] );","","\t\t\t},","\t\t\taddFaceNormal: function ( a, b, c ) {","","\t\t\t\tconst src = this.vertices;","\t\t\t\tconst dst = this.object.geometry.normals;","","\t\t\t\t_vA.fromArray( src, a );","","\t\t\t\t_vB.fromArray( src, b );","","\t\t\t\t_vC.fromArray( src, c );","","\t\t\t\t_cb.subVectors( _vC, _vB );","","\t\t\t\t_ab.subVectors( _vA, _vB );","","\t\t\t\t_cb.cross( _ab );","","\t\t\t\t_cb.normalize();","","\t\t\t\tdst.push( _cb.x, _cb.y, _cb.z );","\t\t\t\tdst.push( _cb.x, _cb.y, _cb.z );","\t\t\t\tdst.push( _cb.x, _cb.y, _cb.z );","","\t\t\t},","\t\t\taddColor: function ( a, b, c ) {","","\t\t\t\tconst src = this.colors;","\t\t\t\tconst dst = this.object.geometry.colors;","\t\t\t\tif ( src[ a ] !== undefined ) dst.push( src[ a + 0 ], src[ a + 1 ], src[ a + 2 ] );","\t\t\t\tif ( src[ b ] !== undefined ) dst.push( src[ b + 0 ], src[ b + 1 ], src[ b + 2 ] );","\t\t\t\tif ( src[ c ] !== undefined ) dst.push( src[ c + 0 ], src[ c + 1 ], src[ c + 2 ] );","","\t\t\t},","\t\t\taddUV: function ( a, b, c ) {","","\t\t\t\tconst src = this.uvs;","\t\t\t\tconst dst = this.object.geometry.uvs;","\t\t\t\tdst.push( src[ a + 0 ], src[ a + 1 ] );","\t\t\t\tdst.push( src[ b + 0 ], src[ b + 1 ] );","\t\t\t\tdst.push( src[ c + 0 ], src[ c + 1 ] );","","\t\t\t},","\t\t\taddDefaultUV: function () {","","\t\t\t\tconst dst = this.object.geometry.uvs;","\t\t\t\tdst.push( 0, 0 );","\t\t\t\tdst.push( 0, 0 );","\t\t\t\tdst.push( 0, 0 );","","\t\t\t},","\t\t\taddUVLine: function ( a ) {","","\t\t\t\tconst src = this.uvs;","\t\t\t\tconst dst = this.object.geometry.uvs;","\t\t\t\tdst.push( src[ a + 0 ], src[ a + 1 ] );","","\t\t\t},","\t\t\taddFace: function ( a, b, c, ua, ub, uc, na, nb, nc ) {","","\t\t\t\tconst vLen = this.vertices.length;","\t\t\t\tlet ia = this.parseVertexIndex( a, vLen );","\t\t\t\tlet ib = this.parseVertexIndex( b, vLen );","\t\t\t\tlet ic = this.parseVertexIndex( c, vLen );","\t\t\t\tthis.addVertex( ia, ib, ic );","\t\t\t\tthis.addColor( ia, ib, ic ); // normals","","\t\t\t\tif ( na !== undefined && na !== '' ) {","","\t\t\t\t\tconst nLen = this.normals.length;","\t\t\t\t\tia = this.parseNormalIndex( na, nLen );","\t\t\t\t\tib = this.parseNormalIndex( nb, nLen );","\t\t\t\t\tic = this.parseNormalIndex( nc, nLen );","\t\t\t\t\tthis.addNormal( ia, ib, ic );","","\t\t\t\t} else {","","\t\t\t\t\tthis.addFaceNormal( ia, ib, ic );","","\t\t\t\t} // uvs","","","\t\t\t\tif ( ua !== undefined && ua !== '' ) {","","\t\t\t\t\tconst uvLen = this.uvs.length;","\t\t\t\t\tia = this.parseUVIndex( ua, uvLen );","\t\t\t\t\tib = this.parseUVIndex( ub, uvLen );","\t\t\t\t\tic = this.parseUVIndex( uc, uvLen );","\t\t\t\t\tthis.addUV( ia, ib, ic );","\t\t\t\t\tthis.object.geometry.hasUVIndices = true;","","\t\t\t\t} else {","","\t\t\t\t\t// add placeholder values (for inconsistent face definitions)","\t\t\t\t\tthis.addDefaultUV();","","\t\t\t\t}","","\t\t\t},","\t\t\taddPointGeometry: function ( vertices ) {","","\t\t\t\tthis.object.geometry.type = 'Points';","\t\t\t\tconst vLen = this.vertices.length;","","\t\t\t\tfor ( let vi = 0, l = vertices.length; vi < l; vi ++ ) {","","\t\t\t\t\tconst index = this.parseVertexIndex( vertices[ vi ], vLen );","\t\t\t\t\tthis.addVertexPoint( index );","\t\t\t\t\tthis.addColor( index );","","\t\t\t\t}","","\t\t\t},","\t\t\taddLineGeometry: function ( vertices, uvs ) {","","\t\t\t\tthis.object.geometry.type = 'Line';","\t\t\t\tconst vLen = this.vertices.length;","\t\t\t\tconst uvLen = this.uvs.length;","","\t\t\t\tfor ( let vi = 0, l = vertices.length; vi < l; vi ++ ) {","","\t\t\t\t\tthis.addVertexLine( this.parseVertexIndex( vertices[ vi ], vLen ) );","","\t\t\t\t}","","\t\t\t\tfor ( let uvi = 0, l = uvs.length; uvi < l; uvi ++ ) {","","\t\t\t\t\tthis.addUVLine( this.parseUVIndex( uvs[ uvi ], uvLen ) );","","\t\t\t\t}","","\t\t\t}","\t\t};","\t\tstate.startObject( '', false );","\t\treturn state;","","\t} //","","","\tclass OBJLoader extends THREE.Loader {","","\t\tconstructor( manager ) {","","\t\t\tsuper( manager );","\t\t\tthis.materials = null;","","\t\t}","","\t\tload( url, onLoad, onProgress, onError ) {","","\t\t\tconst scope = this;","\t\t\tconst loader = new THREE.FileLoader( this.manager );","\t\t\tloader.setPath( this.path );","\t\t\tloader.setRequestHeader( this.requestHeader );","\t\t\tloader.setWithCredentials( this.withCredentials );","\t\t\tloader.load( url, function ( text ) {","","\t\t\t\ttry {","","\t\t\t\t\tonLoad( scope.parse( text ) );","","\t\t\t\t} catch ( e ) {","","\t\t\t\t\tif ( onError ) {","","\t\t\t\t\t\tonError( e );","","\t\t\t\t\t} else {","","\t\t\t\t\t\tconsole.error( e );","","\t\t\t\t\t}","","\t\t\t\t\tscope.manager.itemError( url );","","\t\t\t\t}","","\t\t\t}, onProgress, onError );","","\t\t}","","\t\tsetMaterials( materials ) {","","\t\t\tthis.materials = materials;","\t\t\treturn this;","","\t\t}","","\t\tparse( text ) {","","\t\t\tconst state = new ParserState();","","\t\t\tif ( text.indexOf( '\\r\\n' ) !== - 1 ) {","","\t\t\t\t// This is faster than String.split with regex that splits on both","\t\t\t\ttext = text.replace( /\\r\\n/g, '\\n' );","","\t\t\t}","","\t\t\tif ( text.indexOf( '\\\\\\n' ) !== - 1 ) {","","\t\t\t\t// join lines separated by a line continuation character (\\)","\t\t\t\ttext = text.replace( /\\\\\\n/g, '' );","","\t\t\t}","","\t\t\tconst lines = text.split( '\\n' );","\t\t\tlet result = [];","","\t\t\tfor ( let i = 0, l = lines.length; i < l; i ++ ) {","","\t\t\t\tconst line = lines[ i ].trimStart();","\t\t\t\tif ( line.length === 0 ) continue;","\t\t\t\tconst lineFirstChar = line.charAt( 0 ); // @todo invoke passed in handler if any","","\t\t\t\tif ( lineFirstChar === '#' ) continue;","","\t\t\t\tif ( lineFirstChar === 'v' ) {","","\t\t\t\t\tconst data = line.split( _face_vertex_data_separator_pattern );","","\t\t\t\t\tswitch ( data[ 0 ] ) {","","\t\t\t\t\t\tcase 'v':","\t\t\t\t\t\t\tstate.vertices.push( parseFloat( data[ 1 ] ), parseFloat( data[ 2 ] ), parseFloat( data[ 3 ] ) );","","\t\t\t\t\t\t\tif ( data.length >= 7 ) {","","\t\t\t\t\t\t\t\t_color.setRGB( parseFloat( data[ 4 ] ), parseFloat( data[ 5 ] ), parseFloat( data[ 6 ] ) ).convertSRGBToLinear();","","\t\t\t\t\t\t\t\tstate.colors.push( _color.r, _color.g, _color.b );","","\t\t\t\t\t\t\t} else {","","\t\t\t\t\t\t\t\t// if no colors are defined, add placeholders so color and vertex indices match","\t\t\t\t\t\t\t\tstate.colors.push( undefined, undefined, undefined );","","\t\t\t\t\t\t\t}","","\t\t\t\t\t\t\tbreak;","","\t\t\t\t\t\tcase 'vn':","\t\t\t\t\t\t\tstate.normals.push( parseFloat( data[ 1 ] ), parseFloat( data[ 2 ] ), parseFloat( data[ 3 ] ) );","\t\t\t\t\t\t\tbreak;","","\t\t\t\t\t\tcase 'vt':","\t\t\t\t\t\t\tstate.uvs.push( parseFloat( data[ 1 ] ), parseFloat( data[ 2 ] ) );","\t\t\t\t\t\t\tbreak;","","\t\t\t\t\t}","","\t\t\t\t} else if ( lineFirstChar === 'f' ) {","","\t\t\t\t\tconst lineData = line.slice( 1 ).trim();","\t\t\t\t\tconst vertexData = lineData.split( _face_vertex_data_separator_pattern );","\t\t\t\t\tconst faceVertices = []; // Parse the face vertex data into an easy to work with format","","\t\t\t\t\tfor ( let j = 0, jl = vertexData.length; j < jl; j ++ ) {","","\t\t\t\t\t\tconst vertex = vertexData[ j ];","","\t\t\t\t\t\tif ( vertex.length > 0 ) {","","\t\t\t\t\t\t\tconst vertexParts = vertex.split( '/' );","\t\t\t\t\t\t\tfaceVertices.push( vertexParts );","","\t\t\t\t\t\t}","","\t\t\t\t\t} // Draw an edge between the first vertex and all subsequent vertices to form an n-gon","","","\t\t\t\t\tconst v1 = faceVertices[ 0 ];","","\t\t\t\t\tfor ( let j = 1, jl = faceVertices.length - 1; j < jl; j ++ ) {","","\t\t\t\t\t\tconst v2 = faceVertices[ j ];","\t\t\t\t\t\tconst v3 = faceVertices[ j + 1 ];","\t\t\t\t\t\tstate.addFace( v1[ 0 ], v2[ 0 ], v3[ 0 ], v1[ 1 ], v2[ 1 ], v3[ 1 ], v1[ 2 ], v2[ 2 ], v3[ 2 ] );","","\t\t\t\t\t}","","\t\t\t\t} else if ( lineFirstChar === 'l' ) {","","\t\t\t\t\tconst lineParts = line.substring( 1 ).trim().split( ' ' );","\t\t\t\t\tlet lineVertices = [];","\t\t\t\t\tconst lineUVs = [];","","\t\t\t\t\tif ( line.indexOf( '/' ) === - 1 ) {","","\t\t\t\t\t\tlineVertices = lineParts;","","\t\t\t\t\t} else {","","\t\t\t\t\t\tfor ( let li = 0, llen = lineParts.length; li < llen; li ++ ) {","","\t\t\t\t\t\t\tconst parts = lineParts[ li ].split( '/' );","\t\t\t\t\t\t\tif ( parts[ 0 ] !== '' ) lineVertices.push( parts[ 0 ] );","\t\t\t\t\t\t\tif ( parts[ 1 ] !== '' ) lineUVs.push( parts[ 1 ] );","","\t\t\t\t\t\t}","","\t\t\t\t\t}","","\t\t\t\t\tstate.addLineGeometry( lineVertices, lineUVs );","","\t\t\t\t} else if ( lineFirstChar === 'p' ) {","","\t\t\t\t\tconst lineData = line.slice( 1 ).trim();","\t\t\t\t\tconst pointData = lineData.split( ' ' );","\t\t\t\t\tstate.addPointGeometry( pointData );","","\t\t\t\t} else if ( ( result = _object_pattern.exec( line ) ) !== null ) {","","\t\t\t\t\t// o object_name","\t\t\t\t\t// or","\t\t\t\t\t// g group_name","\t\t\t\t\t// WORKAROUND: https://bugs.chromium.org/p/v8/issues/detail?id=2869","\t\t\t\t\t// let name = result[ 0 ].slice( 1 ).trim();","\t\t\t\t\tconst name = ( ' ' + result[ 0 ].slice( 1 ).trim() ).slice( 1 );","\t\t\t\t\tstate.startObject( name );","","\t\t\t\t} else if ( _material_use_pattern.test( line ) ) {","","\t\t\t\t\t// material","\t\t\t\t\tstate.object.startMaterial( line.substring( 7 ).trim(), state.materialLibraries );","","\t\t\t\t} else if ( _material_library_pattern.test( line ) ) {","","\t\t\t\t\t// mtl file","\t\t\t\t\tstate.materialLibraries.push( line.substring( 7 ).trim() );","","\t\t\t\t} else if ( _map_use_pattern.test( line ) ) {","","\t\t\t\t\t// the line is parsed but ignored since the loader assumes textures are defined MTL files","\t\t\t\t\t// (according to https://www.okino.com/conv/imp_wave.htm, 'usemap' is the old-style Wavefront texture reference method)","\t\t\t\t\tconsole.warn( 'THREE.OBJLoader: Rendering identifier \"usemap\" not supported. Textures must be defined in MTL files.' );","","\t\t\t\t} else if ( lineFirstChar === 's' ) {","","\t\t\t\t\tresult = line.split( ' ' ); // smooth shading","\t\t\t\t\t// @todo Handle files that have varying smooth values for a set of faces inside one geometry,","\t\t\t\t\t// but does not define a usemtl for each face set.","\t\t\t\t\t// This should be detected and a dummy material created (later MultiMaterial and geometry groups).","\t\t\t\t\t// This requires some care to not create extra material on each smooth value for \"normal\" obj files.","\t\t\t\t\t// where explicit usemtl defines geometry groups.","\t\t\t\t\t// Example asset: examples/models/obj/cerberus/Cerberus.obj","","\t\t\t\t\t/*","        \t * http://paulbourke.net/dataformats/obj/","        \t *","        \t * From chapter \"Grouping\" Syntax explanation \"s group_number\":","        \t * \"group_number is the smoothing group number. To turn off smoothing groups, use a value of 0 or off.","        \t * Polygonal elements use group numbers to put elements in different smoothing groups. For free-form","        \t * surfaces, smoothing groups are either turned on or off; there is no difference between values greater","        \t * than 0.\"","        \t */","","\t\t\t\t\tif ( result.length > 1 ) {","","\t\t\t\t\t\tconst value = result[ 1 ].trim().toLowerCase();","\t\t\t\t\t\tstate.object.smooth = value !== '0' && value !== 'off';","","\t\t\t\t\t} else {","","\t\t\t\t\t\t// ZBrush can produce \"s\" lines #11707","\t\t\t\t\t\tstate.object.smooth = true;","","\t\t\t\t\t}","","\t\t\t\t\tconst material = state.object.currentMaterial();","\t\t\t\t\tif ( material ) material.smooth = state.object.smooth;","","\t\t\t\t} else {","","\t\t\t\t\t// Handle null terminated files without exception","\t\t\t\t\tif ( line === '\\0' ) continue;","\t\t\t\t\tconsole.warn( 'THREE.OBJLoader: Unexpected line: \"' + line + '\"' );","","\t\t\t\t}","","\t\t\t}","","\t\t\tstate.finalize();","\t\t\tconst container = new THREE.Group();","\t\t\tcontainer.materialLibraries = [].concat( state.materialLibraries );","\t\t\tconst hasPrimitives = ! ( state.objects.length === 1 && state.objects[ 0 ].geometry.vertices.length === 0 );","","\t\t\tif ( hasPrimitives === true ) {","","\t\t\t\tfor ( let i = 0, l = state.objects.length; i < l; i ++ ) {","","\t\t\t\t\tconst object = state.objects[ i ];","\t\t\t\t\tconst geometry = object.geometry;","\t\t\t\t\tconst materials = object.materials;","\t\t\t\t\tconst isLine = geometry.type === 'Line';","\t\t\t\t\tconst isPoints = geometry.type === 'Points';","\t\t\t\t\tlet hasVertexColors = false; // Skip o/g line declarations that did not follow with any faces","","\t\t\t\t\tif ( geometry.vertices.length === 0 ) continue;","\t\t\t\t\tconst buffergeometry = new THREE.BufferGeometry();","\t\t\t\t\tbuffergeometry.setAttribute( 'position', new THREE.Float32BufferAttribute( geometry.vertices, 3 ) );","","\t\t\t\t\tif ( geometry.normals.length > 0 ) {","","\t\t\t\t\t\tbuffergeometry.setAttribute( 'normal', new THREE.Float32BufferAttribute( geometry.normals, 3 ) );","","\t\t\t\t\t}","","\t\t\t\t\tif ( geometry.colors.length > 0 ) {","","\t\t\t\t\t\thasVertexColors = true;","\t\t\t\t\t\tbuffergeometry.setAttribute( 'color', new THREE.Float32BufferAttribute( geometry.colors, 3 ) );","","\t\t\t\t\t}","","\t\t\t\t\tif ( geometry.hasUVIndices === true ) {","","\t\t\t\t\t\tbuffergeometry.setAttribute( 'uv', new THREE.Float32BufferAttribute( geometry.uvs, 2 ) );","","\t\t\t\t\t} // Create materials","","","\t\t\t\t\tconst createdMaterials = [];","","\t\t\t\t\tfor ( let mi = 0, miLen = materials.length; mi < miLen; mi ++ ) {","","\t\t\t\t\t\tconst sourceMaterial = materials[ mi ];","\t\t\t\t\t\tconst materialHash = sourceMaterial.name + '_' + sourceMaterial.smooth + '_' + hasVertexColors;","\t\t\t\t\t\tlet material = state.materials[ materialHash ];","","\t\t\t\t\t\tif ( this.materials !== null ) {","","\t\t\t\t\t\t\tmaterial = this.materials.create( sourceMaterial.name ); // mtl etc. loaders probably can't create line materials correctly, copy properties to a line material.","","\t\t\t\t\t\t\tif ( isLine && material && ! ( material instanceof THREE.LineBasicMaterial ) ) {","","\t\t\t\t\t\t\t\tconst materialLine = new THREE.LineBasicMaterial();","\t\t\t\t\t\t\t\tTHREE.Material.prototype.copy.call( materialLine, material );","\t\t\t\t\t\t\t\tmaterialLine.color.copy( material.color );","\t\t\t\t\t\t\t\tmaterial = materialLine;","","\t\t\t\t\t\t\t} else if ( isPoints && material && ! ( material instanceof THREE.PointsMaterial ) ) {","","\t\t\t\t\t\t\t\tconst materialPoints = new THREE.PointsMaterial( {","\t\t\t\t\t\t\t\t\tsize: 10,","\t\t\t\t\t\t\t\t\tsizeAttenuation: false","\t\t\t\t\t\t\t\t} );","\t\t\t\t\t\t\t\tTHREE.Material.prototype.copy.call( materialPoints, material );","\t\t\t\t\t\t\t\tmaterialPoints.color.copy( material.color );","\t\t\t\t\t\t\t\tmaterialPoints.map = material.map;","\t\t\t\t\t\t\t\tmaterial = materialPoints;","","\t\t\t\t\t\t\t}","","\t\t\t\t\t\t}","","\t\t\t\t\t\tif ( material === undefined ) {","","\t\t\t\t\t\t\tif ( isLine ) {","","\t\t\t\t\t\t\t\tmaterial = new THREE.LineBasicMaterial();","","\t\t\t\t\t\t\t} else if ( isPoints ) {","","\t\t\t\t\t\t\t\tmaterial = new THREE.PointsMaterial( {","\t\t\t\t\t\t\t\t\tsize: 1,","\t\t\t\t\t\t\t\t\tsizeAttenuation: false","\t\t\t\t\t\t\t\t} );","","\t\t\t\t\t\t\t} else {","","\t\t\t\t\t\t\t\t// material = new THREE.MeshPhongMaterial();","\t\t\t\t\t\t\t\t// material = new THREE.MeshBasicMaterial();// Custom","        \t\t\t\t\t\tmaterial = new THREE.MeshLambertMaterial();// Custom","","","\t\t\t\t\t\t\t}","","\t\t\t\t\t\t\tmaterial.name = sourceMaterial.name;","\t\t\t\t\t\t\t// material.flatShading = sourceMaterial.smooth ? false : true;// Custom (MeshBasicMaterial)","\t\t\t\t\t\t\tmaterial.flatShading = sourceMaterial.smooth ? false : true;// Custom (MeshLambertMaterial)","\t\t\t\t\t\t\tmaterial.vertexColors = hasVertexColors;","\t\t\t\t\t\t\tstate.materials[ materialHash ] = material;","","\t\t\t\t\t\t}","","\t\t\t\t\t\tcreatedMaterials.push( material );","","\t\t\t\t\t} // Create mesh","","","\t\t\t\t\tlet mesh;","","\t\t\t\t\tif ( createdMaterials.length > 1 ) {","","\t\t\t\t\t\tfor ( let mi = 0, miLen = materials.length; mi < miLen; mi ++ ) {","","\t\t\t\t\t\t\tconst sourceMaterial = materials[ mi ];","\t\t\t\t\t\t\tbuffergeometry.addGroup( sourceMaterial.groupStart, sourceMaterial.groupCount, mi );","","\t\t\t\t\t\t}","","\t\t\t\t\t\tif ( isLine ) {","","\t\t\t\t\t\t\tmesh = new THREE.LineSegments( buffergeometry, createdMaterials );","","\t\t\t\t\t\t} else if ( isPoints ) {","","\t\t\t\t\t\t\tmesh = new THREE.Points( buffergeometry, createdMaterials );","","\t\t\t\t\t\t} else {","","\t\t\t\t\t\t\tmesh = new THREE.Mesh( buffergeometry, createdMaterials );","","\t\t\t\t\t\t}","","\t\t\t\t\t} else {","","\t\t\t\t\t\tif ( isLine ) {","","\t\t\t\t\t\t\tmesh = new THREE.LineSegments( buffergeometry, createdMaterials[ 0 ] );","","\t\t\t\t\t\t} else if ( isPoints ) {","","\t\t\t\t\t\t\tmesh = new THREE.Points( buffergeometry, createdMaterials[ 0 ] );","","\t\t\t\t\t\t} else {","","\t\t\t\t\t\t\tmesh = new THREE.Mesh( buffergeometry, createdMaterials[ 0 ] );","","\t\t\t\t\t\t}","","\t\t\t\t\t}","","\t\t\t\t\tmesh.geometry.computeBoundingBox();// Custom","\t\t\t\t\tmesh.name = object.name;","\t\t\t\t\tcontainer.add( mesh );","","\t\t\t\t}","","\t\t\t} else {","","\t\t\t\t// if there is only the default parser state object with no geometry data, interpret data as point cloud","\t\t\t\tif ( state.vertices.length > 0 ) {","","\t\t\t\t\tconst material = new THREE.PointsMaterial( {","\t\t\t\t\t\tsize: 1,","\t\t\t\t\t\tsizeAttenuation: false","\t\t\t\t\t} );","\t\t\t\t\tconst buffergeometry = new THREE.BufferGeometry();","\t\t\t\t\tbuffergeometry.setAttribute( 'position', new THREE.Float32BufferAttribute( state.vertices, 3 ) );","","\t\t\t\t\tif ( state.colors.length > 0 && state.colors[ 0 ] !== undefined ) {","","\t\t\t\t\t\tbuffergeometry.setAttribute( 'color', new THREE.Float32BufferAttribute( state.colors, 3 ) );","\t\t\t\t\t\tmaterial.vertexColors = true;","","\t\t\t\t\t}","","\t\t\t\t\tconst points = new THREE.Points( buffergeometry, material );","\t\t\t\t\tpoints.geometry.computeBoundingBox();// Custom","\t\t\t\t\tcontainer.add( points );","","\t\t\t\t}","","\t\t\t}","","\t\t\treturn container;","","\t\t}","","\t}","","\tTHREE.OBJLoader = OBJLoader;","","} )();",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":false},{"type":"BuiltinCommonInstructions::Comment","color":{"b":109,"g":230,"r":255,"textB":0,"textG":0,"textR":0},"comment":"OBB (Custom)"},{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["// Custom","if (gdjs.__WithThreeJS.get(\"NoTHREE\")) {","  return;","}","/* // Custom","import {","\tBox3,","\tMathUtils,","\tMatrix4,","\tMatrix3,","\tRay,","\tVector3","} from 'three';","*/","","// module scope helper variables","","const a = {","\tc: null, // center","\tu: [ new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3() ], // basis vectors // Custom","\te: [] // half width","};","","const b = {","\tc: null, // center","\tu: [ new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3() ], // basis vectors // Custom","\te: [] // half width","};","","const R = [[], [], []];","const AbsR = [[], [], []];","const t = [];","","const xAxis = new THREE.Vector3(); // Custom","const yAxis = new THREE.Vector3(); // Custom","const zAxis = new THREE.Vector3(); // Custom","const v1 = new THREE.Vector3(); // Custom","const size = new THREE.Vector3(); // Custom","const closestPoint = new THREE.Vector3(); // Custom","const rotationMatrix = new THREE.Matrix3(); // Custom","const aabb = new THREE.Box3(); // Custom","const matrix = new THREE.Matrix4(); // Custom","const inverse = new THREE.Matrix4(); // Custom","const localRay = new THREE.Ray(); // Custom","","// OBB","","class OBB {","","\tconstructor( center = new THREE.Vector3(), halfSize = new THREE.Vector3(), rotation = new THREE.Matrix3() ) { // Custom","","\t\tthis.center = center;","\t\tthis.halfSize = halfSize;","\t\tthis.rotation = rotation;","","\t}","","\tset( center, halfSize, rotation ) {","","\t\tthis.center = center;","\t\tthis.halfSize = halfSize;","\t\tthis.rotation = rotation;","","\t\treturn this;","","\t}","","\tcopy( obb ) {","","\t\tthis.center.copy( obb.center );","\t\tthis.halfSize.copy( obb.halfSize );","\t\tthis.rotation.copy( obb.rotation );","","\t\treturn this;","","\t}","","\tclone() {","","\t\treturn new this.constructor().copy( this );","","\t}","","\tgetSize( result ) {","","\t\treturn result.copy( this.halfSize ).multiplyScalar( 2 );","","\t}","","\t/**","\t* Reference: Closest Point on OBB to Point in Real-Time Collision Detection","\t* by Christer Ericson (chapter 5.1.4)","\t*/","\tclampPoint( point, result ) {","","\t\tconst halfSize = this.halfSize;","","\t\tv1.subVectors( point, this.center );","\t\tthis.rotation.extractBasis( xAxis, yAxis, zAxis );","","\t\t// start at the center position of the OBB","","\t\tresult.copy( this.center );","","\t\t// project the target onto the OBB axes and walk towards that point","","\t\tconst x = MathUtils.clamp( v1.dot( xAxis ), - halfSize.x, halfSize.x );","\t\tresult.add( xAxis.multiplyScalar( x ) );","","\t\tconst y = MathUtils.clamp( v1.dot( yAxis ), - halfSize.y, halfSize.y );","\t\tresult.add( yAxis.multiplyScalar( y ) );","","\t\tconst z = MathUtils.clamp( v1.dot( zAxis ), - halfSize.z, halfSize.z );","\t\tresult.add( zAxis.multiplyScalar( z ) );","","\t\treturn result;","","\t}","","\tcontainsPoint( point ) {","","\t\tv1.subVectors( point, this.center );","\t\tthis.rotation.extractBasis( xAxis, yAxis, zAxis );","","\t\t// project v1 onto each axis and check if these points lie inside the OBB","","\t\treturn Math.abs( v1.dot( xAxis ) ) <= this.halfSize.x &&","\t\t\t\tMath.abs( v1.dot( yAxis ) ) <= this.halfSize.y &&","\t\t\t\tMath.abs( v1.dot( zAxis ) ) <= this.halfSize.z;","","\t}","","\tintersectsBox3( box3 ) {","","\t\treturn this.intersectsOBB( obb.fromBox3( box3 ) );","","\t}","","\tintersectsSphere( sphere ) {","","\t\t// find the point on the OBB closest to the sphere center","","\t\tthis.clampPoint( sphere.center, closestPoint );","","\t\t// if that point is inside the sphere, the OBB and sphere intersect","","\t\treturn closestPoint.distanceToSquared( sphere.center ) <= ( sphere.radius * sphere.radius );","","\t}","","\t/**","\t* Reference: OBB-OBB Intersection in Real-Time Collision Detection","\t* by Christer Ericson (chapter 4.4.1)","\t*","\t*/","\tintersectsOBB( obb, epsilon = Number.EPSILON ) {","","\t\t// prepare data structures (the code uses the same nomenclature like the reference)","","\t\ta.c = this.center;","\t\ta.e[ 0 ] = this.halfSize.x;","\t\ta.e[ 1 ] = this.halfSize.y;","\t\ta.e[ 2 ] = this.halfSize.z;","\t\tthis.rotation.extractBasis( a.u[ 0 ], a.u[ 1 ], a.u[ 2 ] );","","\t\tb.c = obb.center;","\t\tb.e[ 0 ] = obb.halfSize.x;","\t\tb.e[ 1 ] = obb.halfSize.y;","\t\tb.e[ 2 ] = obb.halfSize.z;","\t\tobb.rotation.extractBasis( b.u[ 0 ], b.u[ 1 ], b.u[ 2 ] );","","\t\t// compute rotation matrix expressing b in a's coordinate frame","","\t\tfor ( let i = 0; i < 3; i ++ ) {","","\t\t\tfor ( let j = 0; j < 3; j ++ ) {","","\t\t\t\tR[ i ][ j ] = a.u[ i ].dot( b.u[ j ] );","","\t\t\t}","","\t\t}","","\t\t// compute translation vector","","\t\tv1.subVectors( b.c, a.c );","","\t\t// bring translation into a's coordinate frame","","\t\tt[ 0 ] = v1.dot( a.u[ 0 ] );","\t\tt[ 1 ] = v1.dot( a.u[ 1 ] );","\t\tt[ 2 ] = v1.dot( a.u[ 2 ] );","","\t\t// compute common subexpressions. Add in an epsilon term to","\t\t// counteract arithmetic errors when two edges are parallel and","\t\t// their cross product is (near) null","","\t\tfor ( let i = 0; i < 3; i ++ ) {","","\t\t\tfor ( let j = 0; j < 3; j ++ ) {","","\t\t\t\tAbsR[ i ][ j ] = Math.abs( R[ i ][ j ] ) + epsilon;","","\t\t\t}","","\t\t}","","\t\tlet ra, rb;","","\t\t// test axes L = A0, L = A1, L = A2","","\t\tfor ( let i = 0; i < 3; i ++ ) {","","\t\t\tra = a.e[ i ];","\t\t\trb = b.e[ 0 ] * AbsR[ i ][ 0 ] + b.e[ 1 ] * AbsR[ i ][ 1 ] + b.e[ 2 ] * AbsR[ i ][ 2 ];","\t\t\tif ( Math.abs( t[ i ] ) > ra + rb ) return false;","","","\t\t}","","\t\t// test axes L = B0, L = B1, L = B2","","\t\tfor ( let i = 0; i < 3; i ++ ) {","","\t\t\tra = a.e[ 0 ] * AbsR[ 0 ][ i ] + a.e[ 1 ] * AbsR[ 1 ][ i ] + a.e[ 2 ] * AbsR[ 2 ][ i ];","\t\t\trb = b.e[ i ];","\t\t\tif ( Math.abs( t[ 0 ] * R[ 0 ][ i ] + t[ 1 ] * R[ 1 ][ i ] + t[ 2 ] * R[ 2 ][ i ] ) > ra + rb ) return false;","","\t\t}","","\t\t// test axis L = A0 x B0","","\t\tra = a.e[ 1 ] * AbsR[ 2 ][ 0 ] + a.e[ 2 ] * AbsR[ 1 ][ 0 ];","\t\trb = b.e[ 1 ] * AbsR[ 0 ][ 2 ] + b.e[ 2 ] * AbsR[ 0 ][ 1 ];","\t\tif ( Math.abs( t[ 2 ] * R[ 1 ][ 0 ] - t[ 1 ] * R[ 2 ][ 0 ] ) > ra + rb ) return false;","","\t\t// test axis L = A0 x B1","","\t\tra = a.e[ 1 ] * AbsR[ 2 ][ 1 ] + a.e[ 2 ] * AbsR[ 1 ][ 1 ];","\t\trb = b.e[ 0 ] * AbsR[ 0 ][ 2 ] + b.e[ 2 ] * AbsR[ 0 ][ 0 ];","\t\tif ( Math.abs( t[ 2 ] * R[ 1 ][ 1 ] - t[ 1 ] * R[ 2 ][ 1 ] ) > ra + rb ) return false;","","\t\t// test axis L = A0 x B2","","\t\tra = a.e[ 1 ] * AbsR[ 2 ][ 2 ] + a.e[ 2 ] * AbsR[ 1 ][ 2 ];","\t\trb = b.e[ 0 ] * AbsR[ 0 ][ 1 ] + b.e[ 1 ] * AbsR[ 0 ][ 0 ];","\t\tif ( Math.abs( t[ 2 ] * R[ 1 ][ 2 ] - t[ 1 ] * R[ 2 ][ 2 ] ) > ra + rb ) return false;","","\t\t// test axis L = A1 x B0","","\t\tra = a.e[ 0 ] * AbsR[ 2 ][ 0 ] + a.e[ 2 ] * AbsR[ 0 ][ 0 ];","\t\trb = b.e[ 1 ] * AbsR[ 1 ][ 2 ] + b.e[ 2 ] * AbsR[ 1 ][ 1 ];","\t\tif ( Math.abs( t[ 0 ] * R[ 2 ][ 0 ] - t[ 2 ] * R[ 0 ][ 0 ] ) > ra + rb ) return false;","","\t\t// test axis L = A1 x B1","","\t\tra = a.e[ 0 ] * AbsR[ 2 ][ 1 ] + a.e[ 2 ] * AbsR[ 0 ][ 1 ];","\t\trb = b.e[ 0 ] * AbsR[ 1 ][ 2 ] + b.e[ 2 ] * AbsR[ 1 ][ 0 ];","\t\tif ( Math.abs( t[ 0 ] * R[ 2 ][ 1 ] - t[ 2 ] * R[ 0 ][ 1 ] ) > ra + rb ) return false;","","\t\t// test axis L = A1 x B2","","\t\tra = a.e[ 0 ] * AbsR[ 2 ][ 2 ] + a.e[ 2 ] * AbsR[ 0 ][ 2 ];","\t\trb = b.e[ 0 ] * AbsR[ 1 ][ 1 ] + b.e[ 1 ] * AbsR[ 1 ][ 0 ];","\t\tif ( Math.abs( t[ 0 ] * R[ 2 ][ 2 ] - t[ 2 ] * R[ 0 ][ 2 ] ) > ra + rb ) return false;","","\t\t// test axis L = A2 x B0","","\t\tra = a.e[ 0 ] * AbsR[ 1 ][ 0 ] + a.e[ 1 ] * AbsR[ 0 ][ 0 ];","\t\trb = b.e[ 1 ] * AbsR[ 2 ][ 2 ] + b.e[ 2 ] * AbsR[ 2 ][ 1 ];","\t\tif ( Math.abs( t[ 1 ] * R[ 0 ][ 0 ] - t[ 0 ] * R[ 1 ][ 0 ] ) > ra + rb ) return false;","","\t\t// test axis L = A2 x B1","","\t\tra = a.e[ 0 ] * AbsR[ 1 ][ 1 ] + a.e[ 1 ] * AbsR[ 0 ][ 1 ];","\t\trb = b.e[ 0 ] * AbsR[ 2 ][ 2 ] + b.e[ 2 ] * AbsR[ 2 ][ 0 ];","\t\tif ( Math.abs( t[ 1 ] * R[ 0 ][ 1 ] - t[ 0 ] * R[ 1 ][ 1 ] ) > ra + rb ) return false;","","\t\t// test axis L = A2 x B2","","\t\tra = a.e[ 0 ] * AbsR[ 1 ][ 2 ] + a.e[ 1 ] * AbsR[ 0 ][ 2 ];","\t\trb = b.e[ 0 ] * AbsR[ 2 ][ 1 ] + b.e[ 1 ] * AbsR[ 2 ][ 0 ];","\t\tif ( Math.abs( t[ 1 ] * R[ 0 ][ 2 ] - t[ 0 ] * R[ 1 ][ 2 ] ) > ra + rb ) return false;","","\t\t// since no separating axis is found, the OBBs must be intersecting","","\t\treturn true;","","\t}","","\t/**","\t* Reference: Testing Box Against Plane in Real-Time Collision Detection","\t* by Christer Ericson (chapter 5.2.3)","\t*/","\tintersectsPlane( plane ) {","","\t\tthis.rotation.extractBasis( xAxis, yAxis, zAxis );","","\t\t// compute the projection interval radius of this OBB onto L(t) = this->center + t * p.normal;","","\t\tconst r = this.halfSize.x * Math.abs( plane.normal.dot( xAxis ) ) +","\t\t\t\tthis.halfSize.y * Math.abs( plane.normal.dot( yAxis ) ) +","\t\t\t\tthis.halfSize.z * Math.abs( plane.normal.dot( zAxis ) );","","\t\t// compute distance of the OBB's center from the plane","","\t\tconst d = plane.normal.dot( this.center ) - plane.constant;","","\t\t// Intersection occurs when distance d falls within [-r,+r] interval","","\t\treturn Math.abs( d ) <= r;","","\t}","","\t/**","\t* Performs a ray/OBB intersection test and stores the intersection point","\t* to the given 3D vector. If no intersection is detected, *null* is returned.","\t*/","\tintersectRay( ray, result ) {","","\t\t// the idea is to perform the intersection test in the local space","\t\t// of the OBB.","","\t\tthis.getSize( size );","\t\taabb.setFromCenterAndSize( v1.set( 0, 0, 0 ), size );","","\t\t// create a 4x4 transformation matrix","","\t\tmatrix.setFromMatrix3( this.rotation );","\t\tmatrix.setPosition( this.center );","","\t\t// transform ray to the local space of the OBB","","\t\tinverse.copy( matrix ).invert();","\t\tlocalRay.copy( ray ).applyMatrix4( inverse );","","\t\t// perform ray <-> AABB intersection test","","\t\tif ( localRay.intersectBox( aabb, result ) ) {","","\t\t\t// transform the intersection point back to world space","","\t\t\treturn result.applyMatrix4( matrix );","","\t\t} else {","","\t\t\treturn null;","","\t\t}","","\t}","","\t/**","\t* Performs a ray/OBB intersection test. Returns either true or false if","\t* there is a intersection or not.","\t*/","\tintersectsRay( ray ) {","","\t\treturn this.intersectRay( ray, v1 ) !== null;","","\t}","","\tfromBox3( box3 ) {","","\t\tbox3.getCenter( this.center );","","\t\tbox3.getSize( this.halfSize ).multiplyScalar( 0.5 );","","\t\tthis.rotation.identity();","","\t\treturn this;","","\t}","","\tequals( obb ) {","","\t\treturn obb.center.equals( this.center ) &&","\t\t\tobb.halfSize.equals( this.halfSize ) &&","\t\t\tobb.rotation.equals( this.rotation );","","\t}","","\tapplyMatrix4( matrix ) {","","\t\tconst e = matrix.elements;","","\t\tlet sx = v1.set( e[ 0 ], e[ 1 ], e[ 2 ] ).length();","\t\tconst sy = v1.set( e[ 4 ], e[ 5 ], e[ 6 ] ).length();","\t\tconst sz = v1.set( e[ 8 ], e[ 9 ], e[ 10 ] ).length();","","\t\tconst det = matrix.determinant();","\t\tif ( det < 0 ) sx = - sx;","","\t\trotationMatrix.setFromMatrix4( matrix );","","\t\tconst invSX = 1 / sx;","\t\tconst invSY = 1 / sy;","\t\tconst invSZ = 1 / sz;","","\t\trotationMatrix.elements[ 0 ] *= invSX;","\t\trotationMatrix.elements[ 1 ] *= invSX;","\t\trotationMatrix.elements[ 2 ] *= invSX;","","\t\trotationMatrix.elements[ 3 ] *= invSY;","\t\trotationMatrix.elements[ 4 ] *= invSY;","\t\trotationMatrix.elements[ 5 ] *= invSY;","","\t\trotationMatrix.elements[ 6 ] *= invSZ;","\t\trotationMatrix.elements[ 7 ] *= invSZ;","\t\trotationMatrix.elements[ 8 ] *= invSZ;","","\t\tthis.rotation.multiply( rotationMatrix );","","\t\tthis.halfSize.x *= sx;","\t\tthis.halfSize.y *= sy;","\t\tthis.halfSize.z *= sz;","","\t\tv1.setFromMatrixPosition( matrix );","\t\tthis.center.add( v1 );","","\t\treturn this;","","\t}","","}","","// const obb = new OBB();// Custom","","// export { OBB };// Custom","","THREE.OBB = OBB;// Custom"],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":false}],"parameters":[],"objectGroups":[]},{"fullName":"","functionType":"Action","name":"onScenePostEvents","sentence":"","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["// console.log(\"Three.js post events\");","if (!gdjs.__WithThreeJS.has(\"Renderer\")) {","  return;","}","const Canvas2D = gdjs.__WithThreeJS.get(\"Canvas2D\");","const Rect = Canvas2D.getBoundingClientRect();","const Scene = gdjs.__WithThreeJS.get(\"Scene\");","const AllCams = gdjs.__WithThreeJS.get(\"AllCams\");","const Renderer = gdjs.__WithThreeJS.get(\"Renderer\");","const AnimationMixer = gdjs.__WithThreeJS.get(\"AnimationMixer\");","//","AnimationMixer.update(runtimeScene.getElapsedTime() / 1000);","for (const [K, V] of AllCams) {","  if (V.userData.CameraStatus.Active) {","    const X = V.userData.CameraStatus.X;","    const Y = V.userData.CameraStatus.Y;","    const W = V.userData.CameraStatus.W;","    const H = V.userData.CameraStatus.H;","    Renderer.setViewport(X, Y, W, H);","    Renderer.setScissor(X, Y, W, H);","    Renderer.render( Scene, V );","  }","}","",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"parameters":[],"objectGroups":[]},{"fullName":"","functionType":"Action","name":"onSceneUnloading","sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"BuiltinCommonInstructions::CompareStrings"},"parameters":["CurrentSceneName()","=","WithThreeJS::CreatedSceneName()"]}],"actions":[{"type":{"value":"WithThreeJS::Clear3DScene"},"parameters":["",""]}],"events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["if (gdjs.__WithThreeJS.get(\"BuiltIn3D\")) {","    if (runtimeScene.getRenderer()._threeRenderer._render_WithThreeJS) {","        runtimeScene.getRenderer()._threeRenderer.render = runtimeScene.getRenderer()._threeRenderer._render_WithThreeJS;","        runtimeScene.getRenderer()._threeRenderer._render_WithThreeJS = null;","    };","    if (runtimeScene.getRenderer().getPIXIRenderer()._clear_WithThreeJS) {","        runtimeScene.getRenderer().getPIXIRenderer().clear = runtimeScene.getRenderer().getPIXIRenderer()._clear_WithThreeJS;","        runtimeScene.getRenderer().getPIXIRenderer()._clear_WithThreeJS = null;","    };","}","if (runtimeScene.getRenderer().getPIXIRenderer().background) {","    runtimeScene.getRenderer().getPIXIRenderer().background.alpha = 1;// For PixiJS 7","} else {","    runtimeScene.getRenderer().getPIXIRenderer().backgroundAlpha = 1;// For PixiJS 6","}","gdjs.__WithThreeJS.set(\"SceneIsReady\", false);","",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}]}],"parameters":[],"objectGroups":[]},{"description":"Create a 3D Scene and initialize all 3D Cameras.","fullName":"Create 3D Scene V1 (Deprecated)","functionType":"Action","group":"3D Scene","name":"Create3DScene","private":true,"sentence":" Create 3D Scene V1 (Background: _PARAM1_, _PARAM2_, Ambient: _PARAM3_, Fog: _PARAM4_, _PARAM5_, _PARAM6_, Projection Scale: _PARAM7_, View Mode: _PARAM8_)","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["// console.log(\"Three.js create scene\");","// v5.1.162  Built-In 3D ","const BuiltIn3D = gdjs.__WithThreeJS.get(\"BuiltIn3D\");","if (BuiltIn3D) {","  // runtimescene-pixi-renderer.ts ","  console.log(\"[WithThreeJS] Built-in 3D is enabled.\");","  if (!runtimeScene.getRenderer()._threeRenderer._render_WithThreeJS) {","    runtimeScene.getRenderer()._threeRenderer._render_WithThreeJS = runtimeScene.getRenderer()._threeRenderer.render;","    runtimeScene.getRenderer()._threeRenderer.render = function(S, C) {","      // Three.js ","      runtimeScene.getLayer(\"\").getRenderer().getThreeScene().background = null;","      this._render_WithThreeJS(S, C);","    }","  }","  if (!runtimeScene.getRenderer().getPIXIRenderer()._clear_WithThreeJS) {","    runtimeScene.getRenderer().getPIXIRenderer()._clear_WithThreeJS = runtimeScene.getRenderer().getPIXIRenderer().clear;","    runtimeScene.getRenderer().getPIXIRenderer().clear = function() {","      // PixiJS ","      runtimeScene.setBackgroundColor(0,0,0);","      if (this.background) {","        this.background.alpha = 0;// For PixiJS 7","      } else {","        this.backgroundAlpha = 0;// For PixiJS 6","      }","      this._clear_WithThreeJS();","    }","  }","} else {","  console.log(\"[WithThreeJS] Built-in 3D is disabled.\");","  // ","  let AlertElement = document.createElement('div');","  AlertElement.innerHTML = `<strong>Warning from WithThreeJS</strong><br>","  Please add an \"Enable WithThreeJS\" object to a scene.<br>","  For more information, <a href=\"https://pandako.itch.io/with-threejs-extension-for-gdevelop/devlog/631434/about-the-warning-please-add-an-enable-withthreejs-object-to-a-scene\" target=\"_blank\" style=\"color:yellow\">please click here</a>.`;","  AlertElement.style.position = \"absolute\";","  AlertElement.style.zIndex = 999;","  AlertElement.style.top = 0;","  AlertElement.style.left = 0;","  AlertElement.style.backgroundColor = \"red\";","  AlertElement.style.color = \"white\";","  AlertElement.style.padding = \"0.5em\";","  document.body.appendChild(AlertElement);","  return;","}","//","const ProjectionScale = eventsFunctionContext.getArgument(\"ProjectionScale\") || 1;","let ViewMode = eventsFunctionContext.getArgument(\"ViewMode\");","if (ViewMode !== \"Top Down\" && ViewMode !== \"Side\") {","  ViewMode = \"Top Down\";","}","gdjs.__WithThreeJS.set(\"ProjectionScale\", ProjectionScale);","gdjs.__WithThreeJS.set(\"ViewMode\", ViewMode);","//","const Canvas2D = document.getElementsByTagName(\"canvas\")[0];","gdjs.__WithThreeJS.set(\"Canvas2D\", Canvas2D);","const Rect = Canvas2D.getBoundingClientRect();","//","let Scene;","if (gdjs.__WithThreeJS.has(\"Scene\")) {","  Scene = gdjs.__WithThreeJS.get(\"Scene\");","} else {","  Scene = new THREE.Scene();","  gdjs.__WithThreeJS.set(\"Scene\", Scene);","}","Scene.name =\"Scene\";","gdjs.__WithThreeJS.set(\"SceneIsReady\", true);","//","const BG_RGB = eventsFunctionContext.getArgument(\"BackGroundColor\") || \"0;0;0\";","const BG_Img = eventsFunctionContext.getArgument(\"BackGroundImage\") || \"\";","const Ambient_RGB = eventsFunctionContext.getArgument(\"AmbientColor\") || \"255;255;255\";","const FogColor = eventsFunctionContext.getArgument(\"FogColor\") || \"\";","const FogNear = eventsFunctionContext.getArgument(\"FogNear\") || 1;","const FogFar = eventsFunctionContext.getArgument(\"FogFar\") || 1000;","//","if (Scene.background) {","  if (Scene.background.isTexture) {","    Scene.background.dispose();","    Scene.background = null;","  }","}","//","if (BG_Img !== \"\") {","  const Resource = runtimeScene.getGame().getImageManager().getPIXITexture(BG_Img).baseTexture.resource;","  const ResourceWidth = Resource.width;","  const ResourceHeight = Resource.height;","  const BGTexture = new THREE.Texture();","  BGTexture.image = Resource.source;","  if (ResourceWidth == ResourceHeight * 2) {","    BGTexture.mapping = THREE.EquirectangularReflectionMapping;","  }","  BGTexture.colorSpace = THREE.SRGBColorSpace;","  BGTexture.needsUpdate = true;//","  Scene.background = BGTexture;","} else {","  const RGB = BG_RGB.split(\";\");","  Scene.background = new THREE.Color(`rgb(${RGB[0]}, ${RGB[1]}, ${RGB[2]})`);","}","//","let AmbientLight;","const AmbientColor = Ambient_RGB.split(\";\");","if (gdjs.__WithThreeJS.has(\"AmbientLight\")) {","  AmbientLight = gdjs.__WithThreeJS.get(\"AmbientLight\");","} else {","  AmbientLight = new THREE.AmbientLight();","  AmbientLight.intensity = gdjs.__WithThreeJS.get(\"LightIntensityScale\");// Three.js r160","  gdjs.__WithThreeJS.set(\"AmbientLight\", AmbientLight);","}","Scene.add(AmbientLight);","AmbientLight.color.set(`rgb(${AmbientColor[0]}, ${AmbientColor[1]}, ${AmbientColor[2]})`);","//","if (FogColor === \"\") {","  Scene.fog = null;","} else {","  const RGB = FogColor.split(\";\");","  Scene.fog = new THREE.Fog(`rgb(${RGB[0]}, ${RGB[1]}, ${RGB[2]})`, FogNear, FogFar);","  // Scene.fog = new THREE.FogExp2(\"rgb(0,0,0)\", 0.005);","}","//","// ","let AllCams, Camera1, Camera2, Camera3, Camera4;","if (gdjs.__WithThreeJS.has(\"AllCams\")) {","  AllCams = gdjs.__WithThreeJS.get(\"AllCams\");","  Camera1 = AllCams.get(\"Camera1\");","  Camera2 = AllCams.get(\"Camera2\");","  Camera3 = AllCams.get(\"Camera3\");","  Camera4 = AllCams.get(\"Camera4\");","} else {","  AllCams = new Map();","  Camera1 = new THREE.PerspectiveCamera();","  Camera2 = new THREE.PerspectiveCamera();","  Camera3 = new THREE.PerspectiveCamera();","  Camera4 = new THREE.PerspectiveCamera();","  AllCams.set(\"Camera1\", Camera1);","  AllCams.set(\"Camera2\", Camera2);","  AllCams.set(\"Camera3\", Camera3);","  AllCams.set(\"Camera4\", Camera4);","  gdjs.__WithThreeJS.set(\"AllCams\", AllCams);","}","for (const [K, V] of AllCams) {","  V.name = K;","  V.fov = 50;","  V.aspect = Rect.width / Rect.height;","  V.near = 0.1;","  V.far = 10000;//1000","  V.position.set(0, 0, 0);","  V.rotation.set(0, 0, 0);","  V.updateProjectionMatrix();//","  V.userData.CameraStatus = {};","  V.userData.CameraStatus.Active = false;","  V.userData.CameraStatus.T = 1;","  V.userData.CameraStatus.B = 0;","  V.userData.CameraStatus.L = 0;","  V.userData.CameraStatus.R = 1;","  V.userData.CameraStatus.X = 0;","  V.userData.CameraStatus.Y = 0;","  V.userData.CameraStatus.W = Rect.width;","  V.userData.CameraStatus.H = Rect.height;","}","Camera1.userData.CameraStatus.Active = true;","//","let Listener;","if (gdjs.__WithThreeJS.has(\"Listener\")) {","  Listener = gdjs.__WithThreeJS.get(\"Listener\");","} else {","  Listener = new THREE.AudioListener();","  gdjs.__WithThreeJS.set(\"Listener\", Listener);","}","Listener.name =\"Listener\";","Camera1.add(Listener);","//","let Renderer;","if (gdjs.__WithThreeJS.has(\"Renderer\")) {","  Renderer = gdjs.__WithThreeJS.get(\"Renderer\");","} else {","  Renderer = new THREE.WebGLRenderer();","  document.body.appendChild( Renderer.domElement );","  gdjs.__WithThreeJS.set(\"Renderer\", Renderer);","}","Renderer.setPixelRatio(window.devicePixelRatio);","// Renderer.setSize( window.innerWidth, window.innerHeight );","Renderer.setSize(Rect.width, Rect.height);","Renderer.domElement.id = \"WithThreeJS_Canvas\";","Renderer.domElement.style.position = \"absolute\";","Renderer.domElement.style.zIndex = -99;","Renderer.domElement.style.left = Rect.left + \"px\";","Renderer.domElement.style.top = Rect.top + \"px\";","Renderer.setScissorTest(true);","Renderer.shadowMap.enabled = false;","// Renderer.shadowMap.type = THREE.PCFShadowMap;//THREE.BasicShadowMap THREE.PCFShadowMap THREE.PCFSoftShadowMap THREE.VSMShadowMap","// Renderer.outputColorSpace = THREE.LinearSRGBColorSpace;//NoColorSpace SRGBColorSpace LinearSRGBColorSpace","//","let AnimationMixer;","if (gdjs.__WithThreeJS.has(\"AnimationMixer\")) {","  AnimationMixer = gdjs.__WithThreeJS.get(\"AnimationMixer\");","} else {","  AnimationMixer = new THREE.AnimationMixer(Scene);","  gdjs.__WithThreeJS.set(\"AnimationMixer\", AnimationMixer);","}","//","let AnimationActions;","if (gdjs.__WithThreeJS.has(\"AnimationActions\")) {","  AnimationActions = gdjs.__WithThreeJS.get(\"AnimationActions\");","} else {","  AnimationActions = new Map();","  gdjs.__WithThreeJS.set(\"AnimationActions\", AnimationActions);","}","//","// Resize","window.addEventListener('resize', () => {","  const Rect = Canvas2D.getBoundingClientRect();","","  // ","  Renderer.setPixelRatio(window.devicePixelRatio);","  Renderer.setSize(Rect.width, Rect.height);","","  // ","  // Camera.aspect = Rect.width / Rect.height;","  // Camera.updateProjectionMatrix();","  for (const [K, V] of AllCams) {","    const T = V.userData.CameraStatus.T;","    const B = V.userData.CameraStatus.B;","    const L = V.userData.CameraStatus.L;","    const R = V.userData.CameraStatus.R;","    const X = V.userData.CameraStatus.X = L * Rect.width;","    const Y = V.userData.CameraStatus.Y = B * Rect.height;","    const W = V.userData.CameraStatus.W = (R - L) * Rect.width;","    const H = V.userData.CameraStatus.H = (T - B) * Rect.height;","    V.aspect = W / H;","    V.updateProjectionMatrix();","  }","","  // CSS","  Renderer.domElement.style.position = \"absolute\";","  Renderer.domElement.style.zIndex = -99;","  Renderer.domElement.style.left = Rect.left + \"px\";","  Renderer.domElement.style.top = Rect.top + \"px\";","});","","",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"parameters":[{"description":"Background Color","name":"BackGroundColor","type":"color"},{"description":"Background Image (GDevelop Resource Name) (\"\" => No Background Image)","longDescription":"Escape is required. example: \"assets\\\\Image.png\" -> \"assets\\\\\\\\Image.png\"  \n\"\" => No Background Image  \nImage ratio 2:1 (e.g. 1024 x 512 pixels) => Skybox  \nOther image ratio => Flat Background Image","name":"BackGroundImage","type":"string"},{"description":"Ambient Light Color","name":"AmbientColor","type":"color"},{"description":"Fog Color (\"\" is none fog)","name":"FogColor","type":"color"},{"description":"Fog Start Distance (Default: 1)","longDescription":"Distance to start applying fog.","name":"FogNear","type":"expression"},{"description":"Fog Maximum Distance (Default: 1000)","longDescription":"Distance to maximum fog.","name":"FogFar","type":"expression"},{"description":"Projection Scale (Recommended: 1)","longDescription":"Only affects WithThreeJS Behaviors and WithThreeJS Custom Objects.  \nAffects X, Y, Z and Width, Height, Depth.","name":"ProjectionScale","type":"expression"},{"description":"View Mode","longDescription":"Only affects WithThreeJS Behaviors and WithThreeJS Custom Objects.  \nTop Down: 2D[X, Y, Z-Order] -> 3D[X, Z-Order, Y] or Side: 2D[X, Y, Z-Order] -> 3D[X, -Y, Z-Order]","name":"ViewMode","supplementaryInformation":"[\"Top Down\",\"Side\"]","type":"stringWithSelector"}],"objectGroups":[]},{"description":"Create a 3D Scene and initialize all 3D Cameras.\nThe second parameter is the background image.\nBackground image ratio 2:1 (e.g. 1024 x 512 pixels) => Skybox.\nOther image ratio => Flat background image.\nNo image specified => No Background Image.","fullName":"Create 3D Scene","functionType":"Action","group":"3D Scene","name":"Create3DSceneV2","sentence":"Create 3D Scene (Background: _PARAM1_, _PARAM2_, Ambient: _PARAM3_, Fog: _PARAM4_, _PARAM5_, _PARAM6_, Projection Scale: _PARAM7_, View Mode: _PARAM8_)","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["// console.log(\"Three.js create scene\");","// v5.1.162  Built-In 3D ","const BuiltIn3D = gdjs.__WithThreeJS.get(\"BuiltIn3D\");","if (BuiltIn3D) {","  // runtimescene-pixi-renderer.ts ","  console.log(\"[WithThreeJS] Built-in 3D is enabled.\");","  if (!runtimeScene.getRenderer()._threeRenderer._render_WithThreeJS) {","    runtimeScene.getRenderer()._threeRenderer._render_WithThreeJS = runtimeScene.getRenderer()._threeRenderer.render;","    runtimeScene.getRenderer()._threeRenderer.render = function(S, C) {","      // Three.js ","      runtimeScene.getLayer(\"\").getRenderer().getThreeScene().background = null;","      this._render_WithThreeJS(S, C);","    }","  }","  if (!runtimeScene.getRenderer().getPIXIRenderer()._clear_WithThreeJS) {","    runtimeScene.getRenderer().getPIXIRenderer()._clear_WithThreeJS = runtimeScene.getRenderer().getPIXIRenderer().clear;","    runtimeScene.getRenderer().getPIXIRenderer().clear = function() {","      // PixiJS ","      runtimeScene.setBackgroundColor(0,0,0);","      if (this.background) {","        this.background.alpha = 0;// For PixiJS 7","      } else {","        this.backgroundAlpha = 0;// For PixiJS 6","      }","      this._clear_WithThreeJS();","    }","  }","} else {","  console.log(\"[WithThreeJS] Built-in 3D is disabled.\");","  // ","  let AlertElement = document.createElement('div');","  AlertElement.innerHTML = `<strong>Warning from WithThreeJS</strong><br>","  Please add an \"Enable WithThreeJS\" object to a scene.<br>","  For more information, <a href=\"https://pandako.itch.io/with-threejs-extension-for-gdevelop/devlog/631434/about-the-warning-please-add-an-enable-withthreejs-object-to-a-scene\" target=\"_blank\" style=\"color:yellow\">please click here</a>.`;","  AlertElement.style.position = \"absolute\";","  AlertElement.style.zIndex = 999;","  AlertElement.style.top = 0;","  AlertElement.style.left = 0;","  AlertElement.style.backgroundColor = \"red\";","  AlertElement.style.color = \"white\";","  AlertElement.style.padding = \"0.5em\";","  document.body.appendChild(AlertElement);","  return;","}","//","const ProjectionScale = eventsFunctionContext.getArgument(\"ProjectionScale\") || 1;","let ViewMode = eventsFunctionContext.getArgument(\"ViewMode\");","if (ViewMode !== \"Top Down\" && ViewMode !== \"Side\") {","  ViewMode = \"Top Down\";","}","gdjs.__WithThreeJS.set(\"ProjectionScale\", ProjectionScale);","gdjs.__WithThreeJS.set(\"ViewMode\", ViewMode);","//","const Canvas2D = document.getElementsByTagName(\"canvas\")[0];","gdjs.__WithThreeJS.set(\"Canvas2D\", Canvas2D);","const Rect = Canvas2D.getBoundingClientRect();","//","let Scene;","if (gdjs.__WithThreeJS.has(\"Scene\")) {","  Scene = gdjs.__WithThreeJS.get(\"Scene\");","} else {","  Scene = new THREE.Scene();","  gdjs.__WithThreeJS.set(\"Scene\", Scene);","}","Scene.name =\"Scene\";","if (!gdjs.__WithThreeJS.get(\"SceneIsReady\")) {","  gdjs.__WithThreeJS.set(\"SceneIsReady\", runtimeScene.getName());","}","//","const BG_RGB = eventsFunctionContext.getArgument(\"BackGroundColor\") || \"0;0;0\";","const BG_Img = eventsFunctionContext.getArgument(\"BackGroundImage\");","const Ambient_RGB = eventsFunctionContext.getArgument(\"AmbientColor\") || \"255;255;255\";","const FogColor = eventsFunctionContext.getArgument(\"FogColor\") || \"\";","const FogNear = eventsFunctionContext.getArgument(\"FogNear\") || 1;","const FogFar = eventsFunctionContext.getArgument(\"FogFar\") || 1000;","//","if (Scene.background) {","  if (Scene.background.isTexture) {","    Scene.background.dispose();","    Scene.background = null;","  }","}","//","if (BG_Img !== \"\") {","  const Resource = runtimeScene.getGame().getImageManager().getPIXITexture(BG_Img).baseTexture.resource;","  const ResourceWidth = Resource.width;","  const ResourceHeight = Resource.height;","  const BGTexture = new THREE.Texture();","  BGTexture.image = Resource.source;","  if (ResourceWidth == ResourceHeight * 2) {","    BGTexture.mapping = THREE.EquirectangularReflectionMapping;","  }","  BGTexture.colorSpace = THREE.SRGBColorSpace;","  BGTexture.needsUpdate = true;//","  Scene.background = BGTexture;","} else {","  const RGB = gdjs.rgbOrHexToRGBColor(BG_RGB);","  Scene.background = new THREE.Color(`rgb(${RGB[0]}, ${RGB[1]}, ${RGB[2]})`);","}","//","let AmbientLight;","const AmbientColor = Ambient_RGB.split(\";\");","if (gdjs.__WithThreeJS.has(\"AmbientLight\")) {","  AmbientLight = gdjs.__WithThreeJS.get(\"AmbientLight\");","} else {","  AmbientLight = new THREE.AmbientLight();","  AmbientLight.intensity = gdjs.__WithThreeJS.get(\"LightIntensityScale\");// Three.js r160","  gdjs.__WithThreeJS.set(\"AmbientLight\", AmbientLight);","}","Scene.add(AmbientLight);","AmbientLight.color.set(`rgb(${AmbientColor[0]}, ${AmbientColor[1]}, ${AmbientColor[2]})`);","//","if (FogColor === \"\") {","  Scene.fog = null;","} else {","  const RGB = FogColor.split(\";\");","  Scene.fog = new THREE.Fog(`rgb(${RGB[0]}, ${RGB[1]}, ${RGB[2]})`, FogNear, FogFar);","  // Scene.fog = new THREE.FogExp2(\"rgb(0,0,0)\", 0.005);","}","//","// ","let AllCams, Camera1, Camera2, Camera3, Camera4;","if (gdjs.__WithThreeJS.has(\"AllCams\")) {","  AllCams = gdjs.__WithThreeJS.get(\"AllCams\");","  Camera1 = AllCams.get(\"Camera1\");","  Camera2 = AllCams.get(\"Camera2\");","  Camera3 = AllCams.get(\"Camera3\");","  Camera4 = AllCams.get(\"Camera4\");","} else {","  AllCams = new Map();","  Camera1 = new THREE.PerspectiveCamera();","  Camera2 = new THREE.PerspectiveCamera();","  Camera3 = new THREE.PerspectiveCamera();","  Camera4 = new THREE.PerspectiveCamera();","  AllCams.set(\"Camera1\", Camera1);","  AllCams.set(\"Camera2\", Camera2);","  AllCams.set(\"Camera3\", Camera3);","  AllCams.set(\"Camera4\", Camera4);","  gdjs.__WithThreeJS.set(\"AllCams\", AllCams);","}","for (const [K, V] of AllCams) {","  V.name = K;","  V.fov = 50;","  V.aspect = Rect.width / Rect.height;","  V.near = 0.1;","  V.far = 10000;//1000","  V.position.set(0, 0, 0);","  V.rotation.set(0, 0, 0);","  V.zoom = 1;","  V.updateProjectionMatrix();//","  V.userData.CameraStatus = {};","  V.userData.CameraStatus.Active = false;","  V.userData.CameraStatus.T = 1;","  V.userData.CameraStatus.B = 0;","  V.userData.CameraStatus.L = 0;","  V.userData.CameraStatus.R = 1;","  V.userData.CameraStatus.X = 0;","  V.userData.CameraStatus.Y = 0;","  V.userData.CameraStatus.W = Rect.width;","  V.userData.CameraStatus.H = Rect.height;","}","Camera1.userData.CameraStatus.Active = true;","//","let Listener;","if (gdjs.__WithThreeJS.has(\"Listener\")) {","  Listener = gdjs.__WithThreeJS.get(\"Listener\");","} else {","  Listener = new THREE.AudioListener();","  gdjs.__WithThreeJS.set(\"Listener\", Listener);","}","Listener.name =\"Listener\";","Camera1.add(Listener);","//","let Renderer;","if (gdjs.__WithThreeJS.has(\"Renderer\")) {","  Renderer = gdjs.__WithThreeJS.get(\"Renderer\");","} else {","  Renderer = new THREE.WebGLRenderer();","  document.body.appendChild( Renderer.domElement );","  gdjs.__WithThreeJS.set(\"Renderer\", Renderer);","}","Renderer.setPixelRatio(window.devicePixelRatio);","// Renderer.setSize( window.innerWidth, window.innerHeight );","Renderer.setSize(Rect.width, Rect.height);","Renderer.domElement.id = \"WithThreeJS_Canvas\";","Renderer.domElement.style.position = \"absolute\";","Renderer.domElement.style.zIndex = -99;","Renderer.domElement.style.left = Rect.left + \"px\";","Renderer.domElement.style.top = Rect.top + \"px\";","Renderer.setScissorTest(true);","Renderer.shadowMap.enabled = false;","Renderer.shadowMap.type = THREE.PCFSoftShadowMap;//THREE.BasicShadowMap THREE.PCFShadowMap THREE.PCFSoftShadowMap THREE.VSMShadowMap","// Renderer.outputColorSpace = THREE.LinearSRGBColorSpace;//NoColorSpace SRGBColorSpace LinearSRGBColorSpace","//","let AnimationMixer;","if (gdjs.__WithThreeJS.has(\"AnimationMixer\")) {","  AnimationMixer = gdjs.__WithThreeJS.get(\"AnimationMixer\");","} else {","  AnimationMixer = new THREE.AnimationMixer(Scene);","  gdjs.__WithThreeJS.set(\"AnimationMixer\", AnimationMixer);","}","//","let AnimationActions;","if (gdjs.__WithThreeJS.has(\"AnimationActions\")) {","  AnimationActions = gdjs.__WithThreeJS.get(\"AnimationActions\");","} else {","  AnimationActions = new Map();","  gdjs.__WithThreeJS.set(\"AnimationActions\", AnimationActions);","}","//","// Resize","window.addEventListener('resize', () => {","  const Rect = Canvas2D.getBoundingClientRect();","","  // ","  Renderer.setPixelRatio(window.devicePixelRatio);","  Renderer.setSize(Rect.width, Rect.height);","","  // ","  // Camera.aspect = Rect.width / Rect.height;","  // Camera.updateProjectionMatrix();","  for (const [K, V] of AllCams) {","    const T = V.userData.CameraStatus.T;","    const B = V.userData.CameraStatus.B;","    const L = V.userData.CameraStatus.L;","    const R = V.userData.CameraStatus.R;","    const X = V.userData.CameraStatus.X = L * Rect.width;","    const Y = V.userData.CameraStatus.Y = B * Rect.height;","    const W = V.userData.CameraStatus.W = (R - L) * Rect.width;","    const H = V.userData.CameraStatus.H = (T - B) * Rect.height;","    V.aspect = W / H;","    V.updateProjectionMatrix();","  }","","  // CSS","  Renderer.domElement.style.position = \"absolute\";","  Renderer.domElement.style.zIndex = -99;","  Renderer.domElement.style.left = Rect.left + \"px\";","  Renderer.domElement.style.top = Rect.top + \"px\";","});","","",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"parameters":[{"description":"Background Color","name":"BackGroundColor","type":"color"},{"description":"Background Image","name":"BackGroundImage","type":"imageResource"},{"description":"Ambient Light Color","name":"AmbientColor","type":"color"},{"description":"Fog Color (\"\" is none fog)","name":"FogColor","type":"color"},{"description":"Fog Start Distance (Default: 1)","longDescription":"Distance to start applying fog.","name":"FogNear","type":"expression"},{"description":"Fog Maximum Distance (Default: 1000)","longDescription":"Distance to maximum fog.","name":"FogFar","type":"expression"},{"description":"Projection Scale (Recommended: 1)","longDescription":"Only affects WithThreeJS Behaviors and WithThreeJS Custom Objects.  \nAffects X, Y, Z and Width, Height, Depth.","name":"ProjectionScale","type":"expression"},{"description":"View Mode","longDescription":"Only affects WithThreeJS Behaviors and WithThreeJS Custom Objects.  \nTop Down: 2D[X, Y, Z-Order] -> 3D[X, Z-Order, Y] or Side: 2D[X, Y, Z-Order] -> 3D[X, -Y, Z-Order]","name":"ViewMode","supplementaryInformation":"[\"Top Down\",\"Side\"]","type":"stringWithSelector"}],"objectGroups":[]},{"fullName":"Created Scene Name (Private)","functionType":"StringExpression","name":"CreatedSceneName","private":true,"sentence":"","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":"eventsFunctionContext.returnValue = gdjs.__WithThreeJS.get(\"SceneIsReady\");","parameterObjects":"","useStrict":true,"eventsSheetExpanded":false}],"expressionType":{"type":"string"},"parameters":[],"objectGroups":[]},{"description":"Clear 3D Scene. Removes all 3D Objects in the 3D Scene.\nAs a result, this action also removes 2D Objects that have 3D Projection Behaviors.\nThis action does not clear the loaded 3D Texture data and the loaded 3D Model data.\nThey will continue to be accessible by ID.","fullName":"Clear 3D Scene","functionType":"Action","group":"3D Scene","name":"Clear3DScene","sentence":"Clear 3D Scene","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["if (!gdjs.__WithThreeJS.has(\"Renderer\")) {","    // console.warn(\"!\");","    return;","}","const Scene = gdjs.__WithThreeJS.get(\"Scene\");","const AnimationMixer = gdjs.__WithThreeJS.get(\"AnimationMixer\");","const AnimationActions = gdjs.__WithThreeJS.get(\"AnimationActions\");","//","const All = runtimeScene.getAdhocListOfAllInstances();","for (let i = All.length - 1; i >= 0; i--){","    if (","           All[i].hasBehavior(\"SpriteProjection\")","        || All[i].hasBehavior(\"BoardProjection\")","        || All[i].hasBehavior(\"PlaneProjectionFromTiled\")","        || All[i].hasBehavior(\"BoxProjectionFromTiled\")","        || All[i].type == \"WithThreeJS::Box3D\"","        || All[i].hasBehavior(\"LinkedLight\")","        ) {","        All[i].deleteFromScene(runtimeScene);","    }","}","//","Scene.traverse((Child) => {","    if (Child.type === \"Audio\") {","        if (Child.isPlaying) {","            Child.stop();","        }","    }","});","//","AnimationMixer.stopAllAction();","for (const [K, V] of AnimationActions) {","    for (const [KK, VV] of V) {","        AnimationMixer.uncacheAction(VV.getClip(), VV.getRoot());","        AnimationMixer.uncacheClip(VV.getClip());","        AnimationMixer.uncacheRoot(VV.getRoot());","    }","}","AnimationActions.clear();","//","gdjs.__WithThreeJS.get(\"ObjectList\").clear();","Scene.clear();","",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"parameters":[],"objectGroups":[]},{"description":"Load image from GDevelop resources and create 3D Texture.","fullName":"Load 3D Texture V2 (Deprecated)","functionType":"Action","group":"3D Scene","name":"Load3DTextureV2","private":true,"sentence":" Load 3D Texture V2 (Resource: _PARAM1_, ID: _PARAM2_, Repeat: _PARAM3_, _PARAM4_, Anti-Aliasing: _PARAM5_)","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["if (!gdjs.__WithThreeJS.has(\"Renderer\")) {","    console.warn(\"!\");","    return;","}","if (!gdjs.__WithThreeJS.has(\"Textures\")) {","    gdjs.__WithThreeJS.set(\"Textures\", new Map());","}","let Textures = gdjs.__WithThreeJS.get(\"Textures\");","const ResourceName = eventsFunctionContext.getArgument(\"ResourceName\");","const TextureId = eventsFunctionContext.getArgument(\"TextureId\");","const RepeatU = eventsFunctionContext.getArgument(\"RepeatU\");","const RepeatV = eventsFunctionContext.getArgument(\"RepeatV\");","const AntiAliasing = eventsFunctionContext.getArgument(\"AntiAliasing\");","//","if (!Textures.has(TextureId)) {","    const T = new THREE.Texture();","    T.image = runtimeScene.getGame().getImageManager().getPIXITexture(ResourceName).baseTexture.resource.source;","    T.wrapS = THREE.RepeatWrapping;","    T.wrapT = THREE.RepeatWrapping;","    T.repeat.set(RepeatU, RepeatV);","    if (!AntiAliasing) {","        T.magFilter = THREE.NearestFilter;// THREE.LinearFilter","        T.minFilter = THREE.NearestFilter;// THREE.LinearMipmapLinearFilter","    }","    T.colorSpace = THREE.SRGBColorSpace;//NoColorSpace SRGBColorSpace LinearSRGBColorSpace","    T.needsUpdate = true;//","    Textures.set(TextureId, T);","}","",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"parameters":[{"description":"GDevelop Resource Name (Image)","longDescription":"Escape is required. example: \"assets\\\\Image.png\" -> \"assets\\\\\\\\Image.png\"","name":"ResourceName","type":"string"},{"description":"3D Texture ID","name":"TextureId","supplementaryInformation":"scene3D Texture ID","type":"identifier"},{"description":"Texture Repeat U","name":"RepeatU","type":"expression"},{"description":"Texture Repeat V","name":"RepeatV","type":"expression"},{"defaultValue":"True","description":"Anti-Aliasing","name":"AntiAliasing","optional":true,"supplementaryInformation":"[\"Antialiased\",\"No Antialiasing\"]","type":"trueorfalse"}],"objectGroups":[]},{"description":"Load image from GDevelop resources and create 3D Texture.","fullName":"Load 3D Texture","functionType":"Action","group":"3D Scene","name":"Load3DTextureV3","sentence":"Load 3D Texture (Resource: _PARAM1_, ID: _PARAM2_, Repeat: _PARAM3_, _PARAM4_, Anti-Aliasing: _PARAM5_)","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["if (!gdjs.__WithThreeJS.has(\"Renderer\")) {","    console.warn(\"!\");","    return;","}","if (!gdjs.__WithThreeJS.has(\"Textures\")) {","    gdjs.__WithThreeJS.set(\"Textures\", new Map());","}","let Textures = gdjs.__WithThreeJS.get(\"Textures\");","const ResourceName = eventsFunctionContext.getArgument(\"ResourceName\");","const TextureId = eventsFunctionContext.getArgument(\"TextureId\");","const RepeatU = eventsFunctionContext.getArgument(\"RepeatU\");","const RepeatV = eventsFunctionContext.getArgument(\"RepeatV\");","const AntiAliasing = eventsFunctionContext.getArgument(\"AntiAliasing\");","//","if (!Textures.has(TextureId)) {","    const T = new THREE.Texture();","    T.image = runtimeScene.getGame().getImageManager().getPIXITexture(ResourceName).baseTexture.resource.source;","    T.wrapS = THREE.RepeatWrapping;","    T.wrapT = THREE.RepeatWrapping;","    T.repeat.set(RepeatU, RepeatV);","    if (!AntiAliasing) {","        T.magFilter = THREE.NearestFilter;// THREE.LinearFilter","        T.minFilter = THREE.NearestFilter;// THREE.LinearMipmapLinearFilter","    }","    T.colorSpace = THREE.SRGBColorSpace;//NoColorSpace SRGBColorSpace LinearSRGBColorSpace","    T.needsUpdate = true;//","    Textures.set(TextureId, T);","}","",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"parameters":[{"description":"GDevelop Resource Name (Image)","name":"ResourceName","type":"imageResource"},{"description":"3D Texture ID","name":"TextureId","supplementaryInformation":"scene3D Texture ID","type":"identifier"},{"description":"Texture Repeat U","name":"RepeatU","type":"expression"},{"description":"Texture Repeat V","name":"RepeatV","type":"expression"},{"defaultValue":"True","description":"Anti-Aliasing","name":"AntiAliasing","optional":true,"supplementaryInformation":"[\"Antialiased\",\"No Antialiasing\"]","type":"trueorfalse"}],"objectGroups":[]},{"fullName":"Load 3D Model From OBJ","functionType":"Action","group":"3D Scene","name":"Load3DModelFromOBJ","sentence":"Load 3D Model From OBJ (ID: _PARAM2_)","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["if (!gdjs.__WithThreeJS.has(\"Renderer\")) {","    console.warn(\"!\");","    return;","}","if (!gdjs.__WithThreeJS.has(\"Models\")) {","    gdjs.__WithThreeJS.set(\"Models\", new Map());","}","const Models = gdjs.__WithThreeJS.get(\"Models\");","const OBJ = eventsFunctionContext.getArgument(\"OBJ\");","const ModelId = eventsFunctionContext.getArgument(\"ModelId\");","//","const OBJLoader = new THREE.OBJLoader();","const Model = OBJLoader.parse(OBJ);","Models.set(ModelId, Model);","",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"parameters":[{"description":"OBJ","longDescription":"Paste the contents of the OBJ file.","name":"OBJ","type":"string"},{"description":"3D Model ID","name":"ModelId","supplementaryInformation":"scene3D Model ID","type":"identifier"}],"objectGroups":[]},{"description":"Do a Raycast.\nYou can get the count of 3D Objects in the result with the \"Raycast Result Count\" expression.\nThe result can be accessed via the \"Raycast Result Number\" expression or the \"Raycast Result String\" string expression.","fullName":"Raycast","functionType":"Action","group":"3D Raycast","name":"Raycast","sentence":"Raycast (From: _PARAM1_, _PARAM2_, _PARAM3_, To: _PARAM4_, _PARAM5_, _PARAM6_)","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["if (!gdjs.__WithThreeJS.has(\"Renderer\")) {","    console.warn(\"!\");","    return;","}","if (!gdjs.__WithThreeJS.has(\"Raycaster\")) {","    gdjs.__WithThreeJS.set(\"Raycaster\", new THREE.Raycaster());","    gdjs.__WithThreeJS.set(\"RaycastResult\", new Array());","}","const Scene = gdjs.__WithThreeJS.get(\"Scene\");","// const Camera = gdjs.__WithThreeJS.get(\"Camera\");","const Camera = gdjs.__WithThreeJS.get(\"GetCamera\")(1);// 1","const Raycaster = gdjs.__WithThreeJS.get(\"Raycaster\");","//","const FromX = eventsFunctionContext.getArgument(\"FromX\");","const FromY = eventsFunctionContext.getArgument(\"FromY\");","const FromZ = eventsFunctionContext.getArgument(\"FromZ\");","const ToX = eventsFunctionContext.getArgument(\"ToX\");","const ToY = eventsFunctionContext.getArgument(\"ToY\");","const ToZ = eventsFunctionContext.getArgument(\"ToZ\");","//","const From = new THREE.Vector3(FromX, FromY, FromZ);","const To = new THREE.Vector3(ToX, ToY, ToZ);","const Distance = From.distanceTo(To);","const Direction = new THREE.Vector3().subVectors(To, From).normalize();","//","Raycaster.camera = Camera;","Raycaster.set(From, Direction);","Raycaster.far = Distance;","gdjs.__WithThreeJS.set(\"RaycastResult\", Raycaster.intersectObjects(Scene.children, true));","",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"parameters":[{"description":"From World Position X","name":"FromX","type":"expression"},{"description":"From World Position Y","name":"FromY","type":"expression"},{"description":"From World Position Z","name":"FromZ","type":"expression"},{"description":"To World Position X","name":"ToX","type":"expression"},{"description":"To World Position Y","name":"ToY","type":"expression"},{"description":"To World Position Z","name":"ToZ","type":"expression"}],"objectGroups":[]},{"description":"Do a Raycast from the 3D Camera.\nYou can get the count of 3D Objects in the result with the \"Raycast Result Count\" expression.\nThe result can be accessed via the \"Raycast Result Number\" expression or the \"Raycast Result String\" string expression.","fullName":"Raycast From 3D Camera","functionType":"Action","group":"3D Raycast","name":"RaycastFrom3DCamera","sentence":"Raycast From 3D Camera (ID: _PARAM1_, Screen: _PARAM2_, _PARAM3_)","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["if (!gdjs.__WithThreeJS.has(\"Renderer\")) {","    console.warn(\"!\");","    return;","}","if (!gdjs.__WithThreeJS.has(\"Raycaster\")) {","    gdjs.__WithThreeJS.set(\"Raycaster\", new THREE.Raycaster());","    gdjs.__WithThreeJS.set(\"RaycastResult\", new Array());","}","const Scene = gdjs.__WithThreeJS.get(\"Scene\");","// const Camera = gdjs.__WithThreeJS.get(\"Camera\");","const Raycaster = gdjs.__WithThreeJS.get(\"Raycaster\");","//","const Id = eventsFunctionContext.getArgument(\"Id\");","const Camera = gdjs.__WithThreeJS.get(\"GetCamera\")(Id);","const ScreenX = eventsFunctionContext.getArgument(\"ScreenX\");","const ScreenY = eventsFunctionContext.getArgument(\"ScreenY\");","const ScreenPoint = new THREE.Vector2();","//","Camera.updateWorldMatrix(false, false);//","const T = Camera.userData.CameraStatus.T;","const B = Camera.userData.CameraStatus.B;","const L = Camera.userData.CameraStatus.L;","const R = Camera.userData.CameraStatus.R;","const GameResolutionWidth = runtimeScene.getGame().getGameResolutionWidth();","const GameResolutionHeight = runtimeScene.getGame().getGameResolutionHeight();","const ScreenResolutionWidth = GameResolutionWidth * (R - L);","const ScreenResolutionHeight = GameResolutionHeight * (T - B);","const CameraScreenX = ScreenX - (L * GameResolutionWidth);","const CameraScreenY = ScreenY - ((1 - T) * GameResolutionHeight);","//","ScreenPoint.x = (CameraScreenX / ScreenResolutionWidth) * 2 - 1;","ScreenPoint.y = -(CameraScreenY / ScreenResolutionHeight) * 2 + 1;","//","Raycaster.setFromCamera(ScreenPoint, Camera);","Raycaster.far = Camera.far;","gdjs.__WithThreeJS.set(\"RaycastResult\", Raycaster.intersectObjects(Scene.children, true));","",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"parameters":[{"description":"3D Camera ID (1 to 4)","name":"Id","type":"expression"},{"description":"Screen X","name":"ScreenX","type":"expression"},{"description":"Screen Y","name":"ScreenY","type":"expression"}],"objectGroups":[]},{"description":"Do a Raycast from the 3D Object. (Z axis direction)\nYou can get the count of 3D Objects in the result with the \"Raycast Result Count\" expression.\nThe result can be accessed via the \"Raycast Result Number\" expression or the \"Raycast Result String\" string expression.","fullName":"Raycast From 3D Object","functionType":"Action","group":"3D Raycast","name":"RaycastFrom3DObject","sentence":"Raycast From 3D Object (ID: _PARAM1_, Distance: _PARAM2_)","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["if (!gdjs.__WithThreeJS.has(\"Renderer\")) {","    console.warn(\"!\");","    return;","}","if (!gdjs.__WithThreeJS.has(\"Raycaster\")) {","    gdjs.__WithThreeJS.set(\"Raycaster\", new THREE.Raycaster());","    gdjs.__WithThreeJS.set(\"RaycastResult\", new Array());","}","const Scene = gdjs.__WithThreeJS.get(\"Scene\");","const Camera = gdjs.__WithThreeJS.get(\"GetCamera\")(1);// 1","const Raycaster = gdjs.__WithThreeJS.get(\"Raycaster\");","//","const Id = eventsFunctionContext.getArgument(\"Id\");","const Distance = eventsFunctionContext.getArgument(\"Distance\");","//","const Obj = gdjs.__WithThreeJS.get(\"SearchObject\")(Id);","if (!Obj) {","    console.warn(\"3D Object not found: \" + Id);","    return;","}","const WorldPosition = new THREE.Vector3();","const WorldDirection = new THREE.Vector3();","Obj.getWorldPosition(WorldPosition);","Obj.getWorldDirection(WorldDirection);","//","Raycaster.camera = Camera;","Raycaster.set(WorldPosition, WorldDirection);","Raycaster.far = Distance;","gdjs.__WithThreeJS.set(\"RaycastResult\", Raycaster.intersectObjects(Scene.children, true));","",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"parameters":[{"description":"3D Object ID","name":"Id","supplementaryInformation":"scene3D Object ID","type":"identifier"},{"description":"Distance","name":"Distance","type":"expression"}],"objectGroups":[]},{"fullName":"Place 3D Object Using Raycast Result","functionType":"Action","group":"3D Raycast","name":"Place3DObjectUsingRaycastResult","sentence":"Place 3D Object Using Raycast Result (ID: _PARAM1_, Result: _PARAM2_, Position: _PARAM3_, Normal: _PARAM4_)","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["if (!gdjs.__WithThreeJS.has(\"Renderer\")) {","    console.warn(\"!\");","    return;","}","if (!gdjs.__WithThreeJS.has(\"RaycastResult\")) {","    console.warn(\"No Raycast has been done yet.\");","    return;","}","const Scene = gdjs.__WithThreeJS.get(\"Scene\");","const RaycastResult = gdjs.__WithThreeJS.get(\"RaycastResult\");","//","const Id = eventsFunctionContext.getArgument(\"Id\");","const Index = eventsFunctionContext.getArgument(\"Index\");","const Position = eventsFunctionContext.getArgument(\"Position\");","const Normal = eventsFunctionContext.getArgument(\"Normal\");","//","const Obj = gdjs.__WithThreeJS.get(\"SearchObject\")(Id);","if (!Obj) {","    console.warn(\"3D Object not found: \" + Id);","    return;","}","if (Index < 0 || RaycastResult.length <= Index) {","    console.warn(\"Incorrect Raycast Result index.\");","    return;","}","//","const Parent = Obj.parent;","Scene.attach(Obj);","if (Position) {","    Obj.position.copy(RaycastResult[Index].point);","}","if (Normal && RaycastResult[Index].normal) {","    const DirY = new THREE.Vector3(0, 1, 0);","    const DifQua = new THREE.Quaternion();","    DirY.applyQuaternion(Obj.quaternion);","    DifQua.setFromUnitVectors(DirY, RaycastResult[Index].normal);","    Obj.applyQuaternion(DifQua);","}","Parent.attach(Obj);","",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"parameters":[{"description":"3D Object ID","name":"Id","supplementaryInformation":"scene3D Object ID","type":"identifier"},{"description":"Index of Raycast Result (0 or more)","name":"Index","type":"expression"},{"defaultValue":"yes","description":"Position","name":"Position","optional":true,"type":"yesorno"},{"defaultValue":"yes","description":"Normal","name":"Normal","optional":true,"type":"yesorno"}],"objectGroups":[]},{"description":"Count of 3D Objects in Raycast Result","fullName":"Raycast Result Count","functionType":"Expression","group":"3D Raycast","name":"RaycastResultCount","sentence":"Raycast (From: _PARAM1_, _PARAM2_, _PARAM3_, To: _PARAM4_, _PARAM5_, _PARAM6_)","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["if (!gdjs.__WithThreeJS.has(\"Renderer\")) {","    console.warn(\"!\");","    return;","}","if (!gdjs.__WithThreeJS.has(\"RaycastResult\")) {","    console.warn(\"No Raycast has been done yet.\");","    return;","}","const RaycastResult = gdjs.__WithThreeJS.get(\"RaycastResult\");","eventsFunctionContext.returnValue = RaycastResult.length;","",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"expressionType":{"type":"expression"},"parameters":[],"objectGroups":[]},{"fullName":"Raycast Result Number","functionType":"Expression","group":"3D Raycast","name":"RaycastResultNumber","sentence":"Raycast (From: _PARAM1_, _PARAM2_, _PARAM3_, To: _PARAM4_, _PARAM5_, _PARAM6_)","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["if (!gdjs.__WithThreeJS.has(\"Renderer\")) {","    console.warn(\"!\");","    return;","}","if (!gdjs.__WithThreeJS.has(\"RaycastResult\")) {","    console.warn(\"No Raycast has been done yet.\");","    return;","}","const RaycastResult = gdjs.__WithThreeJS.get(\"RaycastResult\");","//","const Index = eventsFunctionContext.getArgument(\"Index\");","const Item = eventsFunctionContext.getArgument(\"Item\");","//","if (Index < 0 || RaycastResult.length <= Index) {","    // console.warn(\"Incorrect index.\");","    eventsFunctionContext.returnValue = 0;","    return;","}","if (Item == \"Distance\") {","    eventsFunctionContext.returnValue = RaycastResult[Index].distance;","} else if (Item == \"Point X\") {","    eventsFunctionContext.returnValue = RaycastResult[Index].point.x;","} else if (Item == \"Point Y\") {","    eventsFunctionContext.returnValue = RaycastResult[Index].point.y;","} else if (Item == \"Point Z\") {","    eventsFunctionContext.returnValue = RaycastResult[Index].point.z;","} else if (Item == \"Normal X\") {","    eventsFunctionContext.returnValue = RaycastResult[Index].normal.x;","} else if (Item == \"Normal Y\") {","    eventsFunctionContext.returnValue = RaycastResult[Index].normal.y;","} else if (Item == \"Normal Z\") {","    eventsFunctionContext.returnValue = RaycastResult[Index].normal.z;","}","",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"expressionType":{"type":"expression"},"parameters":[{"description":"Index (0 or more)","name":"Index","type":"expression"},{"description":"Item","name":"Item","supplementaryInformation":"[\"Distance\",\"Point X\",\"Point Y\",\"Point Z\",\"Normal X\",\"Normal Y\",\"Normal Z\"]","type":"stringWithSelector"}],"objectGroups":[]},{"fullName":"Raycast Result String","functionType":"StringExpression","group":"3D Raycast","name":"RaycastResultString","sentence":"Raycast (From: _PARAM1_, _PARAM2_, _PARAM3_, To: _PARAM4_, _PARAM5_, _PARAM6_)","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["if (!gdjs.__WithThreeJS.has(\"Renderer\")) {","    console.warn(\"!\");","    return;","}","if (!gdjs.__WithThreeJS.has(\"RaycastResult\")) {","    console.warn(\"No Raycast has been done yet.\");","    return;","}","const RaycastResult = gdjs.__WithThreeJS.get(\"RaycastResult\");","//","const Index = eventsFunctionContext.getArgument(\"Index\");","const Item = eventsFunctionContext.getArgument(\"Item\");","//","if (Index < 0 || RaycastResult.length <= Index) {","    // console.warn(\"Incorrect index.\");","    eventsFunctionContext.returnValue = \"\";","    return;","}","if (Item == \"3D Object ID\") {","    eventsFunctionContext.returnValue = RaycastResult[Index].object.name;","} else if (Item == \"Parent 3D Object ID\") {","    if (RaycastResult[Index].object.parent) {","        eventsFunctionContext.returnValue = RaycastResult[Index].object.parent.name;","    }","}","",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"expressionType":{"type":"string"},"parameters":[{"description":"Index (0 or more)","name":"Index","type":"expression"},{"description":"Item","name":"Item","supplementaryInformation":"[\"3D Object ID\",\"Parent 3D Object ID\"]","type":"stringWithSelector"}],"objectGroups":[]},{"fullName":"Create 3D Sprite","functionType":"Action","group":"3D Object","name":"Create3DSprite","sentence":"Create 3D Sprite (ID: _PARAM1_, X: _PARAM2_, Y: _PARAM3_, Z: _PARAM4_, Scale: _PARAM5_, Texture: _PARAM6_, Test: _PARAM7_, Opacity: _PARAM8_, Blend: _PARAM9_)","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["if (!gdjs.__WithThreeJS.has(\"Renderer\")) {","    console.warn(\"!\");","    return;","}","if (!gdjs.__WithThreeJS.has(\"Textures\")) {","    console.warn(\"!\");","    return;","}","const Scene = gdjs.__WithThreeJS.get(\"Scene\");","const Textures = gdjs.__WithThreeJS.get(\"Textures\");","const TextureId = eventsFunctionContext.getArgument(\"TextureId\");","if (!Textures.has(TextureId)) {","    console.warn(\"3D Texture not found: \" + TextureId);","    return;","}","const Id = eventsFunctionContext.getArgument(\"Id\");","const X = eventsFunctionContext.getArgument(\"X\");","const Y = eventsFunctionContext.getArgument(\"Y\");","const Z = eventsFunctionContext.getArgument(\"Z\");","const Scale = eventsFunctionContext.getArgument(\"Scale\");","const AlphaTest = eventsFunctionContext.getArgument(\"AlphaTest\");","const Opacity = eventsFunctionContext.getArgument(\"Opacity\");","const Transparent = (AlphaTest !== 0 || Opacity !== 1);","let Blend = THREE.NormalBlending;","if (eventsFunctionContext.getArgument(\"Blend\") == \"Additive\") {","    Blend = THREE.AdditiveBlending;","} else if (eventsFunctionContext.getArgument(\"Blend\") == \"Subtractive\") {","    Blend = THREE.SubtractiveBlending;","} else if (eventsFunctionContext.getArgument(\"Blend\") == \"Multiply\") {","    Blend = THREE.MultiplyBlending;","}","//","const Texture = Textures.get(TextureId);","const TextureWidth = Texture.image.width;","const TextureHeight = Texture.image.height;","const Material = new THREE.SpriteMaterial({map:Texture, transparent:Transparent, alphaTest:AlphaTest, blending:Blend, opacity:Opacity});","const Sprite = new THREE.Sprite(Material);","Sprite.geometry.computeBoundingBox();","Sprite.position.set(X, Y, Z);","Sprite.scale.set(TextureWidth * Scale, TextureHeight * Scale, 1);","Sprite.name = Id;","Scene.add(Sprite);","",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"parameters":[{"description":"3D Object ID","name":"Id","supplementaryInformation":"scene3D Object ID","type":"identifier"},{"description":"X","name":"X","type":"expression"},{"description":"Y","name":"Y","type":"expression"},{"description":"Z","name":"Z","type":"expression"},{"description":"Scale","longDescription":"Recommended value: 1","name":"Scale","type":"expression"},{"description":"3D Texture ID","name":"TextureId","supplementaryInformation":"scene3D Texture ID","type":"identifier"},{"description":"Alpha Channel Test (0 to 1)","longDescription":"Recommended values: 0 or 0.5  \nIf the texture is opaque, you can set the value to 0 to reduce the drawing load.","name":"AlphaTest","type":"expression"},{"description":"Opacity (0 to 1)","longDescription":"1 is fully opaque.  \nIf the object is opaque, you can set the value to 1 to reduce the drawing load.","name":"Opacity","type":"expression"},{"description":"Blend Mode","name":"Blend","supplementaryInformation":"[\"Normal\",\"Additive\",\"Subtractive\",\"Multiply\"]","type":"stringWithSelector"}],"objectGroups":[]},{"fullName":"Create 3D Plane","functionType":"Action","group":"3D Object","name":"Create3DPlane","sentence":"Create 3D Plane (ID: _PARAM1_, X: _PARAM2_, Y: _PARAM3_, Z: _PARAM4_, AX: _PARAM5_, AY: _PARAM6_, AZ: _PARAM7_, W: _PARAM8_, H: _PARAM9_, Texture: _PARAM10_, Test: _PARAM11_, Opacity: _PARAM12_, Blend: _PARAM13_)","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["if (!gdjs.__WithThreeJS.has(\"Renderer\")) {","    console.warn(\"!\");","    return;","}","if (!gdjs.__WithThreeJS.has(\"Textures\")) {","    console.warn(\"!\");","    return;","}","const Scene = gdjs.__WithThreeJS.get(\"Scene\");","const Textures = gdjs.__WithThreeJS.get(\"Textures\");","const TextureId = eventsFunctionContext.getArgument(\"TextureId\");","if (!Textures.has(TextureId)) {","    console.warn(\"3D Texture not found: \" + TextureId);","    return;","}","const Id = eventsFunctionContext.getArgument(\"Id\");","const X = eventsFunctionContext.getArgument(\"X\");","const Y = eventsFunctionContext.getArgument(\"Y\");","const Z = eventsFunctionContext.getArgument(\"Z\");","const AngleX = eventsFunctionContext.getArgument(\"AngleX\");","const AngleY = eventsFunctionContext.getArgument(\"AngleY\");","const AngleZ = eventsFunctionContext.getArgument(\"AngleZ\");","const Width = eventsFunctionContext.getArgument(\"Width\");","const Height = eventsFunctionContext.getArgument(\"Height\");","const AlphaTest = eventsFunctionContext.getArgument(\"AlphaTest\");","const Opacity = eventsFunctionContext.getArgument(\"Opacity\");","const Transparent = (AlphaTest !== 0 || Opacity !== 1);","let Blend = THREE.NormalBlending;","if (eventsFunctionContext.getArgument(\"Blend\") == \"Additive\") {","    Blend = THREE.AdditiveBlending;","} else if (eventsFunctionContext.getArgument(\"Blend\") == \"Subtractive\") {","    Blend = THREE.SubtractiveBlending;","} else if (eventsFunctionContext.getArgument(\"Blend\") == \"Multiply\") {","    Blend = THREE.MultiplyBlending;","}","//","const Texture = Textures.get(TextureId);","// const Material = new THREE.MeshBasicMaterial({map: Texture, side: THREE.DoubleSide, transparent:Transparent, alphaTest:AlphaTest, blending:Blend, opacity:Opacity});//transparent:false, alphaTest:0, opacity:1.0","const Material = new THREE.MeshLambertMaterial({map: Texture, side: THREE.DoubleSide, transparent:Transparent, alphaTest:AlphaTest, blending:Blend, opacity:Opacity});//transparent:false, alphaTest:0, opacity:1.0","const Geometry = new THREE.PlaneGeometry(Width, Height, 1, 1);","Geometry.computeBoundingBox();","const Plane = new THREE.Mesh(Geometry, Material);","Plane.position.set(X, Y, Z);","Plane.rotation.set(gdjs.toRad(AngleX), gdjs.toRad(AngleY), gdjs.toRad(AngleZ));","Plane.name = Id;","Scene.add(Plane);","",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"parameters":[{"description":"3D Object ID","name":"Id","supplementaryInformation":"scene3D Object ID","type":"identifier"},{"description":"X","name":"X","type":"expression"},{"description":"Y","name":"Y","type":"expression"},{"description":"Z","name":"Z","type":"expression"},{"description":"Angle X Axis","name":"AngleX","type":"expression"},{"description":"Angle Y Axis","name":"AngleY","type":"expression"},{"description":"Angle Z Axis","name":"AngleZ","type":"expression"},{"description":"Width","name":"Width","type":"expression"},{"description":"Height","name":"Height","type":"expression"},{"description":"3D Texture ID","name":"TextureId","supplementaryInformation":"scene3D Texture ID","type":"identifier"},{"description":"Alpha Channel Test (0 to 1)","longDescription":"Recommended values: 0 or 0.5  \nIf the texture is opaque, you can set the value to 0 to reduce the drawing load.","name":"AlphaTest","type":"expression"},{"description":"Opacity (0 to 1)","longDescription":"1 is fully opaque.  \nIf the object is opaque, you can set the value to 1 to reduce the drawing load.","name":"Opacity","type":"expression"},{"description":"Blend Mode","name":"Blend","supplementaryInformation":"[\"Normal\",\"Additive\",\"Subtractive\",\"Multiply\"]","type":"stringWithSelector"}],"objectGroups":[]},{"fullName":"Create 3D Box","functionType":"Action","group":"3D Object","name":"Create3DBox","sentence":"Create 3D Box (ID: _PARAM1_, X: _PARAM2_, Y: _PARAM3_, Z: _PARAM4_, AX: _PARAM5_, AY: _PARAM6_, AZ: _PARAM7_, W: _PARAM8_, H: _PARAM9_, D: _PARAM10_, Texture: _PARAM11_, Test: _PARAM12_, Opacity: _PARAM13_, Blend: _PARAM14_)","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["if (!gdjs.__WithThreeJS.has(\"Renderer\")) {","    console.warn(\"!\");","    return;","}","if (!gdjs.__WithThreeJS.has(\"Textures\")) {","    console.warn(\"!\");","    return;","}","const Scene = gdjs.__WithThreeJS.get(\"Scene\");","const Textures = gdjs.__WithThreeJS.get(\"Textures\");","//","const Id = eventsFunctionContext.getArgument(\"Id\");","const X = eventsFunctionContext.getArgument(\"X\");","const Y = eventsFunctionContext.getArgument(\"Y\");","const Z = eventsFunctionContext.getArgument(\"Z\");","const AngleX = eventsFunctionContext.getArgument(\"AngleX\");","const AngleY = eventsFunctionContext.getArgument(\"AngleY\");","const AngleZ = eventsFunctionContext.getArgument(\"AngleZ\");","const Width = eventsFunctionContext.getArgument(\"Width\");","const Height = eventsFunctionContext.getArgument(\"Height\");","const Depth = eventsFunctionContext.getArgument(\"Depth\");","const TextureIdList = eventsFunctionContext.getArgument(\"TextureIdList\");","const AlphaTest = eventsFunctionContext.getArgument(\"AlphaTest\");","const Opacity = eventsFunctionContext.getArgument(\"Opacity\");","const Transparent = (AlphaTest !== 0 || Opacity !== 1);","let Blend = THREE.NormalBlending;","if (eventsFunctionContext.getArgument(\"Blend\") == \"Additive\") {","    Blend = THREE.AdditiveBlending;","} else if (eventsFunctionContext.getArgument(\"Blend\") == \"Subtractive\") {","    Blend = THREE.SubtractiveBlending;","} else if (eventsFunctionContext.getArgument(\"Blend\") == \"Multiply\") {","    Blend = THREE.MultiplyBlending;","}","//","let TextureList = [];","for (const V of TextureIdList.split(\"\\n\")) {","    if (V != \"\") {","        if (!Textures.has(V)) {","            console.warn(\"3D Texture not found: \" + V);","        } else {","            TextureList.push(Textures.get(V));","        }","    }","}","//","let Materials;","if (TextureList.length === 1) {","    // Materials = new THREE.MeshBasicMaterial({map:TextureList[0], transparent:Transparent, alphaTest:AlphaTest, blending:Blend, opacity:Opacity});","    Materials = new THREE.MeshLambertMaterial({map:TextureList[0], transparent:Transparent, alphaTest:AlphaTest, blending:Blend, opacity:Opacity});","} else if (TextureList.length == 6) {","    Materials = [];","    for (let i = 0; i < TextureList.length; i++) {","        // Materials.push(new THREE.MeshBasicMaterial({map:TextureList[i], transparent:Transparent, alphaTest:AlphaTest, blending:Blend, opacity:Opacity}));//side:THREE.FrontSide, transparent:false, alphaTest:0, opacity:1.0","        Materials.push(new THREE.MeshLambertMaterial({map:TextureList[i], transparent:Transparent, alphaTest:AlphaTest, blending:Blend, opacity:Opacity}));//side:THREE.FrontSide, transparent:false, alphaTest:0, opacity:1.0","    }","} else {","    console.warn(\"Requires 1 or 6 Texture IDs\");","    return;","}","const Geometry = new THREE.BoxGeometry(Width, Height, Depth);","Geometry.computeBoundingBox();","const Box = new THREE.Mesh(Geometry, Materials);","Box.position.set(X, Y, Z);","Box.rotation.set(gdjs.toRad(AngleX), gdjs.toRad(AngleY), gdjs.toRad(AngleZ));","Box.name = Id;","Scene.add(Box);","",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"parameters":[{"description":"3D Object ID","name":"Id","supplementaryInformation":"scene3D Object ID","type":"identifier"},{"description":"X","name":"X","type":"expression"},{"description":"Y","name":"Y","type":"expression"},{"description":"Z","name":"Z","type":"expression"},{"description":"Angle X Axis","name":"AngleX","type":"expression"},{"description":"Angle Y Axis","name":"AngleY","type":"expression"},{"description":"Angle Z Axis","name":"AngleZ","type":"expression"},{"description":"Width","name":"Width","type":"expression"},{"description":"Height","name":"Height","type":"expression"},{"description":"Depth","name":"Depth","type":"expression"},{"description":"3D Texture ID List","longDescription":"One Texture ID per line. Requires 1 or 6 Texture IDs. 3D Object with 6 textures increase the drawing load.","name":"TextureIdList","supplementaryInformation":"scene3D Texture ID","type":"identifier"},{"description":"Alpha Channel Test (0 to 1)","longDescription":"Recommended values: 0 or 0.5  \nIf the texture is opaque, you can set the value to 0 to reduce the drawing load.  \nThe same value is set for multiple textures.","name":"AlphaTest","type":"expression"},{"description":"Opacity (0 to 1)","longDescription":"1 is fully opaque.  \nIf the object is opaque, you can set the value to 1 to reduce the drawing load.  \nThe same value is set for multiple textures.","name":"Opacity","type":"expression"},{"description":"Blend Mode","longDescription":"The same value is set for multiple textures.","name":"Blend","supplementaryInformation":"[\"Normal\",\"Additive\",\"Subtractive\",\"Multiply\"]","type":"stringWithSelector"}],"objectGroups":[]},{"description":"Create a new 3D model from the 3D model loaded with the \"Load 3D Model From OBJ\" action.","fullName":"Create 3D Model","functionType":"Action","group":"3D Object","name":"Create3DModel","sentence":"Create 3D Model (3D Model: _PARAM1_, ID: _PARAM2_, X: _PARAM3_, Y: _PARAM4_, Z: _PARAM5_, AX: _PARAM6_, AY: _PARAM7_, AZ: _PARAM8_, Scale: _PARAM9_, Texture: _PARAM10_, Test: _PARAM11_, Opacity: _PARAM12_, Blend: _PARAM13_)","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["if (!gdjs.__WithThreeJS.has(\"Renderer\")) {","    console.warn(\"!\");","    return;","}","if (!gdjs.__WithThreeJS.has(\"Textures\")) {","    console.warn(\"!\");","    return;","}","if (!gdjs.__WithThreeJS.has(\"Models\")) {","    console.warn(\"!\");","    return;","}","const Scene = gdjs.__WithThreeJS.get(\"Scene\");","const Textures = gdjs.__WithThreeJS.get(\"Textures\");","const Models = gdjs.__WithThreeJS.get(\"Models\");","//","const ModelId = eventsFunctionContext.getArgument(\"ModelId\");","const Id = eventsFunctionContext.getArgument(\"Id\");","const X = eventsFunctionContext.getArgument(\"X\");","const Y = eventsFunctionContext.getArgument(\"Y\");","const Z = eventsFunctionContext.getArgument(\"Z\");","const AngleX = eventsFunctionContext.getArgument(\"AngleX\");","const AngleY = eventsFunctionContext.getArgument(\"AngleY\");","const AngleZ = eventsFunctionContext.getArgument(\"AngleZ\");","const Scale = eventsFunctionContext.getArgument(\"Scale\");","const TextureIdList = eventsFunctionContext.getArgument(\"TextureIdList\");","const AlphaTest = eventsFunctionContext.getArgument(\"AlphaTest\");","const Opacity = eventsFunctionContext.getArgument(\"Opacity\");","const Transparent = (AlphaTest !== 0 || Opacity !== 1);","let Blend = THREE.NormalBlending;","if (eventsFunctionContext.getArgument(\"Blend\") == \"Additive\") {","    Blend = THREE.AdditiveBlending;","} else if (eventsFunctionContext.getArgument(\"Blend\") == \"Subtractive\") {","    Blend = THREE.SubtractiveBlending;","} else if (eventsFunctionContext.getArgument(\"Blend\") == \"Multiply\") {","    Blend = THREE.MultiplyBlending;","}","//","let TextureList = [];","for (const V of TextureIdList.split(\"\\n\")) {","    if (V != \"\") {","        if (!Textures.has(V)) {","            console.warn(\"3D Texture not found: \" + V);","        } else {","            TextureList.push(Textures.get(V));","        }","    }","}","//","if (!Models.has(ModelId)) {","    console.warn(\"3D Model not found: \" + ModelId);","    return;","}","//","const Model = Models.get(ModelId).clone();","//","const Mats = new Map();","gdjs.__WithThreeJS.get(\"GetAllMaterials\")(Model, Mats);","for (const [K, V] of Mats) {","    const CloneMaterial = V.clone();","    CloneMaterial.transparent = Transparent;","    CloneMaterial.alphaTest = AlphaTest;","    CloneMaterial.blending = Blend;","    CloneMaterial.opacity = Opacity;","    Mats.set(K, CloneMaterial);","}","gdjs.__WithThreeJS.get(\"ReplaceMaterial\")(Model, Mats);","//","Model.position.set(X, Y, Z);","Model.rotation.set(gdjs.toRad(AngleX), gdjs.toRad(AngleY), gdjs.toRad(AngleZ));","Model.name = Id;","Model.scale.setScalar(Scale);","gdjs.__WithThreeJS.get(\"SetAllTextures\")(Model, TextureList);","Scene.add(Model);","",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"parameters":[{"description":"3D Model ID","name":"ModelId","supplementaryInformation":"scene3D Model ID","type":"identifier"},{"description":"3D Object ID","name":"Id","supplementaryInformation":"scene3D Object ID","type":"identifier"},{"description":"X","name":"X","type":"expression"},{"description":"Y","name":"Y","type":"expression"},{"description":"Z","name":"Z","type":"expression"},{"description":"Angle X Axis","name":"AngleX","type":"expression"},{"description":"Angle Y Axis","name":"AngleY","type":"expression"},{"description":"Angle Z Axis","name":"AngleZ","type":"expression"},{"description":"Scale","name":"Scale","type":"expression"},{"description":"3D Texture ID List","longDescription":"One Texture ID per line.","name":"TextureIdList","supplementaryInformation":"scene3D Texture ID","type":"identifier"},{"description":"Alpha Channel Test (0 to 1)","longDescription":"Recommended values: 0 or 0.5  \nIf the texture is opaque, you can set the value to 0 to reduce the drawing load.  \nThe same value is set for multiple textures.","name":"AlphaTest","type":"expression"},{"description":"Opacity (0 to 1)","longDescription":"1 is fully opaque.  \nIf the object is opaque, you can set the value to 1 to reduce the drawing load.  \nThe same value is set for multiple textures.","name":"Opacity","type":"expression"},{"description":"Blend Mode","longDescription":"The same value is set for multiple textures.","name":"Blend","supplementaryInformation":"[\"Normal\",\"Additive\",\"Subtractive\",\"Multiply\"]","type":"stringWithSelector"}],"objectGroups":[]},{"description":"The only valid object properties are \"3D model\" and \"Material modifier\".","fullName":"Create 3D Model From Built-In 3D Model","functionType":"Action","group":"3D Object","name":"Create3DModelFromBuiltIn","sentence":"Create 3D Model From Built-In (3D Model: _PARAM1_, ID: _PARAM2_, X: _PARAM3_, Y: _PARAM4_, Z: _PARAM5_, AX: _PARAM6_, AY: _PARAM7_, AZ: _PARAM8_, Scale: _PARAM9_)","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["if (!gdjs.__WithThreeJS.has(\"Renderer\")) {","    console.warn(\"!\");","    return;","}","if (!gdjs.__WithThreeJS.get(\"BuiltIn3D\")) {","    console.warn(\"!\");","    return;","}","if (!gdjs.__WithThreeJS.has(\"Models\")) {","    gdjs.__WithThreeJS.set(\"Models\", new Map());","}","const Models = gdjs.__WithThreeJS.get(\"Models\");","const Scene = gdjs.__WithThreeJS.get(\"Scene\");","//","const ModelObject = eventsFunctionContext.getObjectsLists(\"ModelObject\");","const ModelObjectName = ModelObject.firstKey();","const ModelResourceName = runtimeScene._objects.get(ModelObjectName).content.modelResourceName;","const MaterialType = runtimeScene._objects.get(ModelObjectName).content.materialType;//\"Basic\", \"StandardWithoutMetalness\", \"KeepOriginal\"","const Id = eventsFunctionContext.getArgument(\"Id\");","const X = eventsFunctionContext.getArgument(\"X\");","const Y = eventsFunctionContext.getArgument(\"Y\");","const Z = eventsFunctionContext.getArgument(\"Z\");","const AngleX = eventsFunctionContext.getArgument(\"AngleX\");","const AngleY = eventsFunctionContext.getArgument(\"AngleY\");","const AngleZ = eventsFunctionContext.getArgument(\"AngleZ\");","const Scale = eventsFunctionContext.getArgument(\"Scale\");","//","if (!Models.has(ModelResourceName)) {","    const ResourceModel = runtimeScene.getGame().getModel3DManager().getModel(ModelResourceName).scene;","    const ResourceAnimations = runtimeScene.getGame().getModel3DManager().getModel(ModelResourceName).animations;","    ResourceModel.animations = ResourceAnimations;","    //","    if (MaterialType != \"KeepOriginal\") {","        // MeshStandardMaterial ","        const Mats = new Map();","        gdjs.__WithThreeJS.get(\"GetAllMaterials\")(ResourceModel, Mats);","        for (const [K, V] of Mats) {","            let NewMaterial;","            if (MaterialType == \"Basic\") {","                NewMaterial = new THREE.MeshBasicMaterial();","            } else {","                NewMaterial = new THREE.MeshLambertMaterial();","            }","            for(const KK of Object.keys(V)) {","                // console.log(`V.${KK} = ${V[KK]}`);","                if (KK === \"isMaterial\") {","                    continue;","                }","                if (KK === \"uuid\") {","                    continue;","                }","                if (KK === \"id\") {","                    continue;","                }","                if (KK === \"type\") {","                    continue;","                }","                if (NewMaterial[KK] !== undefined) {","                    NewMaterial[KK] = V[KK];","                }","            }","            NewMaterial.side = THREE.FrontSide;","            V.dispose();// ","            Mats.set(K, NewMaterial);","        }","        gdjs.__WithThreeJS.get(\"ReplaceMaterial\")(ResourceModel, Mats);","    }","    Models.set(ModelResourceName, ResourceModel);","    // console.log(ResourceModel, ResourceAnimations);","}","// const Model = Models.get(ModelResourceName).clone();// ","const Model = THREE_ADDONS.SkeletonUtils.clone(Models.get(ModelResourceName));","//","const Mats = new Map();","gdjs.__WithThreeJS.get(\"GetAllMaterials\")(Model, Mats);","for (const [K, V] of Mats) {","    const CloneMaterial = V.clone();","    Mats.set(K, CloneMaterial);","}","gdjs.__WithThreeJS.get(\"ReplaceMaterial\")(Model, Mats);","//","Model.position.set(X, Y, Z);","Model.rotation.set(gdjs.toRad(AngleX), gdjs.toRad(AngleY), gdjs.toRad(AngleZ));","Model.name = Id;","Model.scale.setScalar(Scale);","Scene.add(Model);","",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"parameters":[{"description":"3D Model Object","name":"ModelObject","supplementaryInformation":"Scene3D::Model3DObject","type":"objectList"},{"description":"3D Object ID","name":"Id","supplementaryInformation":"scene3D Object ID","type":"identifier"},{"description":"X","name":"X","type":"expression"},{"description":"Y","name":"Y","type":"expression"},{"description":"Z","name":"Z","type":"expression"},{"description":"Angle X Axis","name":"AngleX","type":"expression"},{"description":"Angle Y Axis","name":"AngleY","type":"expression"},{"description":"Angle Z Axis","name":"AngleZ","type":"expression"},{"description":"Scale","name":"Scale","type":"expression"}],"objectGroups":[]},{"description":" 3D Lights are highly loaded.\n3D Directional Light and 3D Spot Light emit light in the -Z direction.\n3D Lights can be handled like 3D Objects.","fullName":"Create 3D Light V1 (Deprecated)","functionType":"Action","group":"3D Light","name":"Create3DLight","private":true,"sentence":" Create 3D Light V1 (ID: _PARAM1_, Type: _PARAM2_, Color: _PARAM3_, Intensity: _PARAM4_, Distance: _PARAM5_, SpotAngle: _PARAM6_, SpotPenumbra: _PARAM7_, Pos: _PARAM8_, _PARAM9_, _PARAM10_, Ang: _PARAM11_, _PARAM12_, _PARAM13_)","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["if (!gdjs.__WithThreeJS.has(\"Renderer\")) {","    console.warn(\"!\");","    return;","}","const Scene = gdjs.__WithThreeJS.get(\"Scene\");","//","const LightId = eventsFunctionContext.getArgument(\"LightId\");","const LightType = eventsFunctionContext.getArgument(\"Type\");","const Color = eventsFunctionContext.getArgument(\"Color\") || \"255;255;255\";","let Intensity = eventsFunctionContext.getArgument(\"Intensity\");","const Distance = eventsFunctionContext.getArgument(\"Distance\");","const Decay = 2;","const SpotAngle = eventsFunctionContext.getArgument(\"SpotAngle\");","const SpotPenumbra = eventsFunctionContext.getArgument(\"SpotPenumbra\");","const X = eventsFunctionContext.getArgument(\"X\");","const Y = eventsFunctionContext.getArgument(\"Y\");","const Z = eventsFunctionContext.getArgument(\"Z\");","const AngleX = eventsFunctionContext.getArgument(\"AngleX\");","const AngleY = eventsFunctionContext.getArgument(\"AngleY\");","const AngleZ = eventsFunctionContext.getArgument(\"AngleZ\");","//","const RGB = Color.split(\";\");","let Light;","if (LightType == \"Directional Light\") {","    Intensity *= gdjs.__WithThreeJS.get(\"LightIntensityScale\");// Three.js r160","    Light = new THREE.DirectionalLight(`rgb(${RGB[0]}, ${RGB[1]}, ${RGB[2]})`, Intensity);","    const Target = new THREE.Group();","    Target.translateZ(-1);","    Light.add(Target);","    Light.target = Target;","} else if (LightType == \"Spot Light\") {","    Intensity *= gdjs.__WithThreeJS.get(\"LightIntensityCandela\");// Three.js r160","    Light = new THREE.SpotLight(`rgb(${RGB[0]}, ${RGB[1]}, ${RGB[2]})`, Intensity, Distance, gdjs.toRad(SpotAngle), SpotPenumbra, Decay);","    const Target = new THREE.Group();","    Target.translateZ(-1);","    Light.add(Target);","    Light.target = Target;","} else {","    // Point","    Intensity *= gdjs.__WithThreeJS.get(\"LightIntensityCandela\");// Three.js r160","    Light = new THREE.PointLight(`rgb(${RGB[0]}, ${RGB[1]}, ${RGB[2]})`, Intensity, Distance, Decay);","}","Light.name = LightId;","Light.position.set(X, Y, Z);","Light.rotation.set(gdjs.toRad(AngleX), gdjs.toRad(AngleY), gdjs.toRad(AngleZ));","Scene.add(Light);","",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"parameters":[{"description":"3D Light ID (3D Object ID)","name":"LightId","supplementaryInformation":"scene3D Object ID","type":"identifier"},{"description":"Light Type","name":"Type","supplementaryInformation":"[\"Directional Light\",\"Point Light\",\"Spot Light\"]","type":"stringWithSelector"},{"description":"Color","name":"Color","type":"color"},{"description":"Intensity (Default: 1)","name":"Intensity","type":"expression"},{"description":"Distance (Default: 0)","longDescription":"For Point and Spot Lights.\n0 is no limit.","name":"Distance","type":"expression"},{"description":"Spot Angle (0 to 180)","longDescription":"For Spot Lights.","name":"SpotAngle","type":"expression"},{"description":"Spot Penumbra (0 to 1)","longDescription":"For Spot Lights.","name":"SpotPenumbra","type":"expression"},{"description":"X","name":"X","type":"expression"},{"description":"Y","name":"Y","type":"expression"},{"description":"Z","name":"Z","type":"expression"},{"description":"Angle X Axis","name":"AngleX","type":"expression"},{"description":"Angle Y Axis","name":"AngleY","type":"expression"},{"description":"Angle Z Axis","name":"AngleZ","type":"expression"}],"objectGroups":[]},{"description":" 3D Lights are highly loaded.\n3D Directional Light and 3D Spot Light emit light in the -Z direction.\n3D Lights can be handled like 3D Objects.","fullName":"Create 3D Light","functionType":"Action","group":"3D Light","name":"Create3DLightV2","sentence":"Create 3D Light (ID: _PARAM1_, Type: _PARAM2_, Color: _PARAM3_, Intensity: _PARAM4_, Distance: _PARAM5_, SpotAngle: _PARAM6_, SpotPenumbra: _PARAM7_, Pos: _PARAM8_, _PARAM9_, _PARAM10_, Ang: _PARAM11_, _PARAM12_, _PARAM13_, Shadow: _PARAM14_, Size: _PARAM15_, Range: _PARAM16_, Bias: _PARAM17_, _PARAM18_, Helper: _PARAM19_, _PARAM20_)","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["if (!gdjs.__WithThreeJS.has(\"Renderer\")) {","    console.warn(\"!\");","    return;","}","const Scene = gdjs.__WithThreeJS.get(\"Scene\");","const Renderer = gdjs.__WithThreeJS.get(\"Renderer\");","//","const LightId = eventsFunctionContext.getArgument(\"LightId\");","const LightType = eventsFunctionContext.getArgument(\"Type\");","const Color = eventsFunctionContext.getArgument(\"Color\") || \"255;255;255\";","let Intensity = eventsFunctionContext.getArgument(\"Intensity\");","const Distance = eventsFunctionContext.getArgument(\"Distance\");","const Decay = 2;","const SpotAngle = eventsFunctionContext.getArgument(\"SpotAngle\");","const SpotPenumbra = eventsFunctionContext.getArgument(\"SpotPenumbra\");","const X = eventsFunctionContext.getArgument(\"X\");","const Y = eventsFunctionContext.getArgument(\"Y\");","const Z = eventsFunctionContext.getArgument(\"Z\");","const AngleX = eventsFunctionContext.getArgument(\"AngleX\");","const AngleY = eventsFunctionContext.getArgument(\"AngleY\");","const AngleZ = eventsFunctionContext.getArgument(\"AngleZ\");","const CastShadow = eventsFunctionContext.getArgument(\"CastShadow\");","const ShadowMapSize = gdjs.__WithThreeJS.get(\"ShadowMapSizeStringToValue\")[eventsFunctionContext.getArgument(\"ShadowMapSize\")];","const ShadowRange = eventsFunctionContext.getArgument(\"ShadowRange\");","const ShadowBias = eventsFunctionContext.getArgument(\"ShadowBias\");","const ShadowNormalBias = eventsFunctionContext.getArgument(\"ShadowNormalBias\");","const LightHelper = eventsFunctionContext.getArgument(\"LightHelper\");","const ShadowHelper = eventsFunctionContext.getArgument(\"ShadowHelper\");","//","const RGB = Color.split(\";\");","let Light;","if (LightType == \"Directional Light\") {","    Intensity *= gdjs.__WithThreeJS.get(\"LightIntensityScale\");// Three.js r160","    Light = new THREE.DirectionalLight(`rgb(${RGB[0]}, ${RGB[1]}, ${RGB[2]})`, Intensity);","    const Target = new THREE.Group();","    Target.translateZ(-128);","    Light.add(Target);","    Light.target = Target;","    //","    Light.shadow.camera.top = ShadowRange / 2;","    Light.shadow.camera.right = ShadowRange / 2;","    Light.shadow.camera.bottom = -ShadowRange / 2;","    Light.shadow.camera.left = -ShadowRange / 2;","    Light.shadow.camera.near = 0.5;// default","    Light.shadow.camera.far = ShadowRange;","    //","    if (LightHelper) {","        const DirectionalLightHelper = new THREE.DirectionalLightHelper(Light, 128);","        DirectionalLightHelper.name = LightId + \"_DirectionalLightHelper\";","        Scene.add(DirectionalLightHelper);","    }","} else if (LightType == \"Spot Light\") {","    Intensity *= gdjs.__WithThreeJS.get(\"LightIntensityCandela\");// Three.js r160","    Light = new THREE.SpotLight(`rgb(${RGB[0]}, ${RGB[1]}, ${RGB[2]})`, Intensity, Distance, gdjs.toRad(SpotAngle), SpotPenumbra, Decay);","    const Target = new THREE.Group();","    Target.translateZ(-1);","    Light.add(Target);","    Light.target = Target;","    //","    Light.shadow.camera.near = 0.5;// default","    Light.shadow.camera.far = ShadowRange;","    Light.shadow.focus = 1; // default","    //","    if (LightHelper) {","        const SpotLightHelper = new THREE.SpotLightHelper(Light);","        SpotLightHelper.name = LightId + \"_SpotLightHelper\";","        Scene.add(SpotLightHelper);","    }","} else {","    // Point","    Intensity *= gdjs.__WithThreeJS.get(\"LightIntensityCandela\");// Three.js r160","    Light = new THREE.PointLight(`rgb(${RGB[0]}, ${RGB[1]}, ${RGB[2]})`, Intensity, Distance, Decay);","    //","    Light.shadow.camera.near = 0.5;// default","    Light.shadow.camera.far = ShadowRange;","    //","    if (LightHelper) {","        const PointLightHelper = new THREE.PointLightHelper(Light, 16);","        PointLightHelper.name = LightId + \"_PointLightHelper\";","        Scene.add(PointLightHelper);","    }","}","Renderer.shadowMap.enabled = Renderer.shadowMap.enabled ? true : CastShadow;","Light.castShadow = CastShadow;","Light.shadow.mapSize.width = ShadowMapSize;","Light.shadow.mapSize.height = ShadowMapSize;","Light.shadow.bias = ShadowBias;","Light.shadow.normalBias = ShadowNormalBias;","Light.shadow.updateMatrices(Light);// ","Light.shadow.camera.updateProjectionMatrix();","//","Light.name = LightId;","Light.position.set(X, Y, Z);","Light.rotation.set(gdjs.toRad(AngleX), gdjs.toRad(AngleY), gdjs.toRad(AngleZ));","Scene.add(Light);","//","if (ShadowHelper && CastShadow) {","    let CameraHelper;","    if (LightType != \"Point Light\") {","        CameraHelper = new THREE.CameraHelper(Light.shadow.camera);","        Scene.add(CameraHelper);","    } else {","        const Geometry = new THREE.IcosahedronGeometry(Light.shadow.camera.far, 2); ","        const Material = new THREE.MeshBasicMaterial( {color: 0xffaa00, wireframe: true} );","        CameraHelper = new THREE.Mesh(Geometry, Material);","        Light.add(CameraHelper);","    }","    CameraHelper.name = LightId + \"_CameraHelper\";","}","",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"parameters":[{"description":"3D Light ID (3D Object ID)","name":"LightId","supplementaryInformation":"scene3D Object ID","type":"identifier"},{"description":"Light Type","name":"Type","supplementaryInformation":"[\"Directional Light\",\"Point Light\",\"Spot Light\"]","type":"stringWithSelector"},{"description":"Color","name":"Color","type":"color"},{"description":"Intensity (Default: 1)","name":"Intensity","type":"expression"},{"description":"Distance (Default: 0)","longDescription":"For Point and Spot Lights.  \n0 is no limit.","name":"Distance","type":"expression"},{"description":"Spot Angle (0 to 180)","longDescription":"For Spot Lights.  \nThe narrower the angle, the better the shadow quality.  \nIf it is a multiple of 90, the shadow will not be cast correctly.","name":"SpotAngle","type":"expression"},{"description":"Spot Penumbra (0 to 1)","longDescription":"For Spot Lights.","name":"SpotPenumbra","type":"expression"},{"description":"X","name":"X","type":"expression"},{"description":"Y","name":"Y","type":"expression"},{"description":"Z","name":"Z","type":"expression"},{"description":"Angle X Axis","name":"AngleX","type":"expression"},{"description":"Angle Y Axis","name":"AngleY","type":"expression"},{"description":"Angle Z Axis","name":"AngleZ","type":"expression"},{"description":"Cast Shadow","longDescription":" This is expensive and requires tweaking to get shadows looking right.","name":"CastShadow","type":"yesorno"},{"description":"Shadow Map Size (Default: 512px)","longDescription":"The larger the map, the better the shadow quality, but the greater the load.","name":"ShadowMapSize","supplementaryInformation":"[\"128px\",\"256px\",\"512px\",\"1024px\",\"2048px\"]","type":"stringWithSelector"},{"description":"Range to Draw Shadows (Default: 256)","longDescription":"The smaller the range, the better the shadow quality.  \nFor Point and Spot Lights, this value is valid only if the Distance is 0.","name":"ShadowRange","type":"expression"},{"description":"Shadow Depth Bias (Default: 0.002)","longDescription":"It is mainly effective for filling gaps between objects and shadows.  \nReference value: [Directional Light: 0.002] [Point Light: 0.001] [Spot Light: 0.00001]","name":"ShadowDepthBias","type":"expression"},{"description":"Shadow Normal Bias (Default: 2)","longDescription":"It is mainly effective in reducing striped patterns.  \nReference value: [Directional Light: 2] [Point Light: 1] [Spot Light: 1]","name":"ShadowNormalBias","type":"expression"},{"description":"Light Helper","name":"LightHelper","type":"yesorno"},{"description":"Shadow Range Helper","name":"ShadowHelper","type":"yesorno"}],"objectGroups":[]},{"description":"This 3D Object without geometry is useful for grouping other 3D Objects together or changing their center point.","fullName":"Create 3D Group","functionType":"Action","group":"3D Object","name":"Create3DGroup","sentence":"Create 3D Group (ID: _PARAM1_, X: _PARAM2_, Y: _PARAM3_, Z: _PARAM4_, AX: _PARAM5_, AY: _PARAM6_, AZ: _PARAM7_)","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["if (!gdjs.__WithThreeJS.has(\"Renderer\")) {","    console.warn(\"!\");","    return;","}","const Scene = gdjs.__WithThreeJS.get(\"Scene\");","const Id = eventsFunctionContext.getArgument(\"Id\");","const X = eventsFunctionContext.getArgument(\"X\");","const Y = eventsFunctionContext.getArgument(\"Y\");","const Z = eventsFunctionContext.getArgument(\"Z\");","const AngleX = eventsFunctionContext.getArgument(\"AngleX\");","const AngleY = eventsFunctionContext.getArgument(\"AngleY\");","const AngleZ = eventsFunctionContext.getArgument(\"AngleZ\");","const Group = new THREE.Group();","Group.position.set(X, Y, Z);","Group.rotation.set(gdjs.toRad(AngleX), gdjs.toRad(AngleY), gdjs.toRad(AngleZ));","Group.name = Id;","Scene.add(Group);","",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"parameters":[{"description":"3D Object ID","name":"Id","supplementaryInformation":"scene3D Object ID","type":"identifier"},{"description":"X","name":"X","type":"expression"},{"description":"Y","name":"Y","type":"expression"},{"description":"Z","name":"Z","type":"expression"},{"description":"Angle X Axis","name":"AngleX","type":"expression"},{"description":"Angle Y Axis","name":"AngleY","type":"expression"},{"description":"Angle Z Axis","name":"AngleZ","type":"expression"}],"objectGroups":[]},{"description":"Move a 3D Camera.\n'=' is relative to the parent axis.\n\"+\" and \"-\" are relative to the local axis.","fullName":"Move 3D Camera","functionType":"Action","group":"3D Camera","name":"Move3DCamera","sentence":"Move 3D Camera (ID: _PARAM1_, _PARAM2_, X: _PARAM3_, Y: _PARAM4_, Z: _PARAM5_)","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["if (!gdjs.__WithThreeJS.has(\"Renderer\")) {","    console.warn(\"!\");","    return;","}","// const Camera = gdjs.__WithThreeJS.get(\"Camera\");","const Id = eventsFunctionContext.getArgument(\"Id\");","const Camera = gdjs.__WithThreeJS.get(\"GetCamera\")(Id);","const Operator = eventsFunctionContext.getArgument(\"Operator\");","const X = eventsFunctionContext.getArgument(\"X\");","const Y = eventsFunctionContext.getArgument(\"Y\");","const Z = eventsFunctionContext.getArgument(\"Z\");","//","if (Operator == \"=\") {","    Camera.position.set(X, Y, Z);","} else if (Operator == \"+\") {","    Camera.translateX(X);","    Camera.translateY(Y);","    Camera.translateZ(Z);","} else {","    Camera.translateX(-X);","    Camera.translateY(-Y);","    Camera.translateZ(-Z);","}","",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"parameters":[{"description":"3D Camera ID (1 to 4)","name":"Id","type":"expression"},{"description":"Operator","name":"Operator","supplementaryInformation":"[\"=\",\"+\",\"-\"]","type":"stringWithSelector"},{"description":"X","name":"X","type":"expression"},{"description":"Y","name":"Y","type":"expression"},{"description":"Z","name":"Z","type":"expression"}],"objectGroups":[]},{"description":"Rotate the 3D Camera in the order X, Y, Z.","fullName":"Rotate 3D Camera","functionType":"Action","group":"3D Camera","name":"Rotate3DCamera","sentence":"Rotate 3D Camera (ID: _PARAM1_, _PARAM2_, X: _PARAM3_, Y: _PARAM4_, Z: _PARAM5_)","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["if (!gdjs.__WithThreeJS.has(\"Renderer\")) {","    console.warn(\"!\");","    return;","}","// const Camera = gdjs.__WithThreeJS.get(\"Camera\");","const Id = eventsFunctionContext.getArgument(\"Id\");","const Camera = gdjs.__WithThreeJS.get(\"GetCamera\")(Id);","const Operator = eventsFunctionContext.getArgument(\"Operator\");","const AngleX = eventsFunctionContext.getArgument(\"AngleX\");","const AngleY = eventsFunctionContext.getArgument(\"AngleY\");","const AngleZ = eventsFunctionContext.getArgument(\"AngleZ\");","//","if (Operator == \"=\") {","    Camera.rotation.set(gdjs.toRad(AngleX), gdjs.toRad(AngleY), gdjs.toRad(AngleZ));","} else if (Operator == \"+\") {","    Camera.rotateX(gdjs.toRad(AngleX));","    Camera.rotateY(gdjs.toRad(AngleY));","    Camera.rotateZ(gdjs.toRad(AngleZ));","} else {","    Camera.rotateX(gdjs.toRad(-AngleX));","    Camera.rotateY(gdjs.toRad(-AngleY));","    Camera.rotateZ(gdjs.toRad(-AngleZ));","}","",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"parameters":[{"description":"3D Camera ID (1 to 4)","name":"Id","type":"expression"},{"description":"Operator","name":"Operator","supplementaryInformation":"[\"=\",\"+\",\"-\"]","type":"stringWithSelector"},{"description":"Angle X","name":"AngleX","type":"expression"},{"description":"Angle Y","name":"AngleY","type":"expression"},{"description":"Angle Z","name":"AngleZ","type":"expression"}],"objectGroups":[]},{"description":"Rotate the 3D Camera in the order X, Y, Z on the world axis.","fullName":"Rotate 3D Camera On World","functionType":"Action","group":"3D Camera","name":"Rotate3DCameraOnWorld","sentence":"Rotate 3D Camera On World (ID: _PARAM1_, _PARAM2_, X: _PARAM3_, Y: _PARAM4_, Z: _PARAM5_)","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["if (!gdjs.__WithThreeJS.has(\"Renderer\")) {","    console.warn(\"!\");","    return;","}","// const Camera = gdjs.__WithThreeJS.get(\"Camera\");","const Id = eventsFunctionContext.getArgument(\"Id\");","const Camera = gdjs.__WithThreeJS.get(\"GetCamera\")(Id);","const Operator = eventsFunctionContext.getArgument(\"Operator\");","const AngleX = eventsFunctionContext.getArgument(\"AngleX\");","const AngleY = eventsFunctionContext.getArgument(\"AngleY\");","const AngleZ = eventsFunctionContext.getArgument(\"AngleZ\");","//","if (Operator == \"=\") {","    Camera.rotation.set(0, 0, 0);","    Camera.rotateOnWorldAxis(new THREE.Vector3(1, 0, 0), gdjs.toRad(AngleX));","    Camera.rotateOnWorldAxis(new THREE.Vector3(0, 1, 0), gdjs.toRad(AngleY));","    Camera.rotateOnWorldAxis(new THREE.Vector3(0, 0, 1), gdjs.toRad(AngleZ));","} else if (Operator == \"+\") {","    Camera.rotateOnWorldAxis(new THREE.Vector3(1, 0, 0), gdjs.toRad(AngleX));","    Camera.rotateOnWorldAxis(new THREE.Vector3(0, 1, 0), gdjs.toRad(AngleY));","    Camera.rotateOnWorldAxis(new THREE.Vector3(0, 0, 1), gdjs.toRad(AngleZ));","} else {","    Camera.rotateOnWorldAxis(new THREE.Vector3(1, 0, 0), gdjs.toRad(-AngleX));","    Camera.rotateOnWorldAxis(new THREE.Vector3(0, 1, 0), gdjs.toRad(-AngleY));","    Camera.rotateOnWorldAxis(new THREE.Vector3(0, 0, 1), gdjs.toRad(-AngleZ));","}","",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"parameters":[{"description":"3D Camera ID (1 to 4)","name":"Id","type":"expression"},{"description":"Operator","name":"Operator","supplementaryInformation":"[\"=\",\"+\",\"-\"]","type":"stringWithSelector"},{"description":"Angle X","name":"AngleX","type":"expression"},{"description":"Angle Y","name":"AngleY","type":"expression"},{"description":"Angle Z","name":"AngleZ","type":"expression"}],"objectGroups":[]},{"description":"Rotate the 3D Camera first in the world Y axis, then on the local X and Z axes.","fullName":"Rotate 3D Camera Like Head","functionType":"Action","group":"3D Camera","name":"Rotate3DCameraLikeHead","sentence":"Rotate 3D Camera Like Head (ID: _PARAM1_, _PARAM2_, X: _PARAM3_, Y: _PARAM4_, Z: _PARAM5_)","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["if (!gdjs.__WithThreeJS.has(\"Renderer\")) {","    console.warn(\"!\");","    return;","}","// const Camera = gdjs.__WithThreeJS.get(\"Camera\");","const Id = eventsFunctionContext.getArgument(\"Id\");","const Camera = gdjs.__WithThreeJS.get(\"GetCamera\")(Id);","const Operator = eventsFunctionContext.getArgument(\"Operator\");","const AngleX = eventsFunctionContext.getArgument(\"AngleX\");","const AngleY = eventsFunctionContext.getArgument(\"AngleY\");","const AngleZ = eventsFunctionContext.getArgument(\"AngleZ\");","//","if (Operator == \"=\") {","    // Camera.rotation.set(gdjs.toRad(AngleX), gdjs.toRad(AngleY), gdjs.toRad(AngleZ), \"YXZ\");","    Camera.rotation.set(0, 0, 0);","    Camera.rotateY(gdjs.toRad(AngleY));","    Camera.rotateX(gdjs.toRad(AngleX));","    Camera.rotateZ(gdjs.toRad(AngleZ));","} else if (Operator == \"+\") {","    Camera.rotateX(gdjs.toRad(AngleX));","    Camera.rotateOnWorldAxis(new THREE.Vector3(0, 1, 0), gdjs.toRad(AngleY));","    Camera.rotateZ(gdjs.toRad(AngleZ));","} else {","    Camera.rotateX(gdjs.toRad(-AngleX));","    Camera.rotateOnWorldAxis(new THREE.Vector3(0, 1, 0), gdjs.toRad(-AngleY));","    Camera.rotateZ(gdjs.toRad(-AngleZ));","}","",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"parameters":[{"description":"3D Camera ID (1 to 4)","name":"Id","type":"expression"},{"description":"Operator","name":"Operator","supplementaryInformation":"[\"=\",\"+\",\"-\"]","type":"stringWithSelector"},{"description":"Angle X","name":"AngleX","type":"expression"},{"description":"Angle Y","name":"AngleY","type":"expression"},{"description":"Angle Z","name":"AngleZ","type":"expression"}],"objectGroups":[]},{"fullName":"3D Camera Look At 3D Object","functionType":"Action","group":"3D Camera","name":"CameraLookAt3DObject","sentence":"3D Camera Look At 3D Object (Camera ID: _PARAM1_, Target ID: _PARAM2_)","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["if (!gdjs.__WithThreeJS.has(\"Renderer\")) {","    console.warn(\"!\");","    return;","}","const Scene = gdjs.__WithThreeJS.get(\"Scene\");","// const Camera = gdjs.__WithThreeJS.get(\"Camera\");","const Id = eventsFunctionContext.getArgument(\"Id\");","const Camera = gdjs.__WithThreeJS.get(\"GetCamera\")(Id);","const TargetId = eventsFunctionContext.getArgument(\"TargetId\");","//","const Obj = gdjs.__WithThreeJS.get(\"SearchObject\")(TargetId);","if (!Obj) {","    console.warn(\"3D Object not found: \" + TargetId);","    return;","}","//","const WPos = new THREE.Vector3();","Obj.getWorldPosition(WPos);","Camera.lookAt(WPos);","",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"parameters":[{"description":"3D Camera ID (1 to 4)","name":"Id","type":"expression"},{"description":"Target 3D Object ID","name":"TargetId","supplementaryInformation":"scene3D Object ID","type":"identifier"}],"objectGroups":[]},{"description":"Change the Field Of View of the 3D Camera.","fullName":"Change 3D Camera FOV","functionType":"Action","group":"3D Camera","name":"Change3DCameraFOV","sentence":"Change 3D Camera FOV (ID: _PARAM1_, _PARAM2_, Fov: _PARAM3_)","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["if (!gdjs.__WithThreeJS.has(\"Renderer\")) {","    console.warn(\"!\");","    return;","}","// const Camera = gdjs.__WithThreeJS.get(\"Camera\");","const Id = eventsFunctionContext.getArgument(\"Id\");","const Camera = gdjs.__WithThreeJS.get(\"GetCamera\")(Id);","const Operator = eventsFunctionContext.getArgument(\"Operator\");","const Fov = eventsFunctionContext.getArgument(\"Fov\");","//","if (Operator == \"=\") {","    Camera.fov = Fov;","} else if (Operator == \"+\") {","    Camera.fov += Fov;","} else if (Operator == \"-\") {","    Camera.fov -= Fov;","}","Camera.updateProjectionMatrix();","",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"parameters":[{"description":"3D Camera ID (1 to 4)","name":"Id","type":"expression"},{"description":"Operator","name":"Operator","supplementaryInformation":"[\"=\",\"+\",\"-\"]","type":"stringWithSelector"},{"description":"Field Of View (Default: 50)","name":"Fov","type":"expression"}],"objectGroups":[]},{"description":"Change the near property of the 3D Camera.\nThe 3D Camera will not render 3D Objects closer than this distance.","fullName":"Change 3D Camera Near","functionType":"Action","group":"3D Camera","name":"Change3DCameraNear","sentence":"Change 3D Camera Near (ID: _PARAM1_, _PARAM2_, Near: _PARAM3_)","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["if (!gdjs.__WithThreeJS.has(\"Renderer\")) {","    console.warn(\"!\");","    return;","}","// const Camera = gdjs.__WithThreeJS.get(\"Camera\");","const Id = eventsFunctionContext.getArgument(\"Id\");","const Camera = gdjs.__WithThreeJS.get(\"GetCamera\")(Id);","const Operator = eventsFunctionContext.getArgument(\"Operator\");","const Near = eventsFunctionContext.getArgument(\"Near\");","//","if (Operator == \"=\") {","    Camera.near = Near;","} else if (Operator == \"+\") {","    Camera.near += Near;","} else if (Operator == \"-\") {","    Camera.near -= Near;","}","Camera.updateProjectionMatrix();","",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"parameters":[{"description":"3D Camera ID (1 to 4)","name":"Id","type":"expression"},{"description":"Operator","name":"Operator","supplementaryInformation":"[\"=\",\"+\",\"-\"]","type":"stringWithSelector"},{"description":"Near (Default: 0.1) (Greater than 0)","name":"Near","type":"expression"}],"objectGroups":[]},{"description":"Change the far property of 3D Camera.\nThe 3D Camera will not render 3D Objects farther than this distance.","fullName":"Change 3D Camera Far","functionType":"Action","group":"3D Camera","name":"Change3DCameraFar","sentence":"Change 3D Camera Far (ID: _PARAM1_, _PARAM2_, Far: _PARAM3_)","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["if (!gdjs.__WithThreeJS.has(\"Renderer\")) {","    console.warn(\"!\");","    return;","}","// const Camera = gdjs.__WithThreeJS.get(\"Camera\");","const Id = eventsFunctionContext.getArgument(\"Id\");","const Camera = gdjs.__WithThreeJS.get(\"GetCamera\")(Id);","const Operator = eventsFunctionContext.getArgument(\"Operator\");","const Far = eventsFunctionContext.getArgument(\"Far\");","//","if (Operator == \"=\") {","    Camera.far = Far;","} else if (Operator == \"+\") {","    Camera.far += Far;","} else if (Operator == \"-\") {","    Camera.far -= Far;","}","Camera.updateProjectionMatrix();","",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"parameters":[{"description":"3D Camera ID (1 to 4)","name":"Id","type":"expression"},{"description":"Operator","name":"Operator","supplementaryInformation":"[\"=\",\"+\",\"-\"]","type":"stringWithSelector"},{"description":"Far (Default: 10000)","name":"Far","type":"expression"}],"objectGroups":[]},{"fullName":"Change 3D Camera Zoom","functionType":"Action","group":"3D Camera","name":"Change3DCameraZoom","sentence":"Change 3D Camera Zoom (ID: _PARAM1_, _PARAM2_, Zoom: _PARAM3_)","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["if (!gdjs.__WithThreeJS.has(\"Renderer\")) {","    console.warn(\"!\");","    return;","}","// const Camera = gdjs.__WithThreeJS.get(\"Camera\");","const Id = eventsFunctionContext.getArgument(\"Id\");","const Camera = gdjs.__WithThreeJS.get(\"GetCamera\")(Id);","const Operator = eventsFunctionContext.getArgument(\"Operator\");","const Zoom = eventsFunctionContext.getArgument(\"Zoom\");","//","if (Operator == \"=\") {","    Camera.zoom = Zoom;","} else if (Operator == \"+\") {","    Camera.zoom += Zoom;","} else if (Operator == \"-\") {","    Camera.zoom -= Zoom;","}","Camera.updateProjectionMatrix();","",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"parameters":[{"description":"3D Camera ID (1 to 4)","name":"Id","type":"expression"},{"description":"Operator","name":"Operator","supplementaryInformation":"[\"=\",\"+\",\"-\"]","type":"stringWithSelector"},{"description":"Zoom (Default: 1)","name":"Zoom","type":"expression"}],"objectGroups":[]},{"description":"Note that rendering time increases by the number of enabled 3D Cameras.","fullName":"Setup Multiple 3D Cameras","functionType":"Action","group":"3D Camera","name":"SetupMultiple3DCameras","sentence":"Setup Multiple 3D Cameras (Camera2: _PARAM5_, Camera3: _PARAM10_, Camera4: _PARAM15_)","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["if (!gdjs.__WithThreeJS.has(\"Renderer\")) {","    console.warn(\"!\");","    return;","}","// const Camera = gdjs.__WithThreeJS.get(\"Camera\");","const Canvas2D = gdjs.__WithThreeJS.get(\"Canvas2D\");","const Rect = Canvas2D.getBoundingClientRect();","const AllCams = gdjs.__WithThreeJS.get(\"AllCams\");","const Arguments = {};","Arguments.Camera1 = {};","Arguments.Camera1.Active = true;","Arguments.Camera1.Top = eventsFunctionContext.getArgument(\"Top1\") || 0;","Arguments.Camera1.Bottom = eventsFunctionContext.getArgument(\"Bottom1\") || 1;","Arguments.Camera1.Left = eventsFunctionContext.getArgument(\"Left1\") || 0;","Arguments.Camera1.Right = eventsFunctionContext.getArgument(\"Right1\") || 1;","Arguments.Camera2 = {};","Arguments.Camera2.Active = eventsFunctionContext.getArgument(\"Active2\") || false;","Arguments.Camera2.Top = eventsFunctionContext.getArgument(\"Top2\") || 0;","Arguments.Camera2.Bottom = eventsFunctionContext.getArgument(\"Bottom2\") || 1;","Arguments.Camera2.Left = eventsFunctionContext.getArgument(\"Left2\") || 0;","Arguments.Camera2.Right = eventsFunctionContext.getArgument(\"Right2\") || 1;","Arguments.Camera3 = {};","Arguments.Camera3.Active = eventsFunctionContext.getArgument(\"Active3\") || false;","Arguments.Camera3.Top = eventsFunctionContext.getArgument(\"Top3\") || 0;","Arguments.Camera3.Bottom = eventsFunctionContext.getArgument(\"Bottom3\") || 1;","Arguments.Camera3.Left = eventsFunctionContext.getArgument(\"Left3\") || 0;","Arguments.Camera3.Right = eventsFunctionContext.getArgument(\"Right3\") || 1;","Arguments.Camera4 = {};","Arguments.Camera4.Active = eventsFunctionContext.getArgument(\"Active4\") || false;","Arguments.Camera4.Top = eventsFunctionContext.getArgument(\"Top4\") || 0;","Arguments.Camera4.Bottom = eventsFunctionContext.getArgument(\"Bottom4\") || 1;","Arguments.Camera4.Left = eventsFunctionContext.getArgument(\"Left4\") || 0;","Arguments.Camera4.Right = eventsFunctionContext.getArgument(\"Right4\") || 1;","//","for (const [K, V] of AllCams) {","    const C = Arguments[K];","    V.userData.CameraStatus.Active = C.Active;","    const T = V.userData.CameraStatus.T = 1 - C.Top;","    const B = V.userData.CameraStatus.B = 1 - C.Bottom;","    const L = V.userData.CameraStatus.L = C.Left;","    const R = V.userData.CameraStatus.R = C.Right;","    V.userData.CameraStatus.X = L * Rect.width;","    V.userData.CameraStatus.Y = B * Rect.height;","    const W = V.userData.CameraStatus.W = (R - L) * Rect.width;","    const H = V.userData.CameraStatus.H = (T - B) * Rect.height;","    V.aspect = W / H;","    V.updateProjectionMatrix();","}","",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"parameters":[{"description":"Camera1 Viewport: Top (0 to 1, Default: 0)","name":"Top1","type":"expression"},{"description":"Camera1 Viewport: Bottom (0 to 1, Default: 1)","name":"Bottom1","type":"expression"},{"description":"Camera1 Viewport: Left (0 to 1, Default: 0)","name":"Left1","supplementaryInformation":"[\"=\",\"+\",\"-\"]","type":"expression"},{"description":"Camera1 Viewport: Right (0 to 1, Default: 1)","name":"Right1","type":"expression"},{"defaultValue":"no","description":"Enable 3D Camera2","name":"Active2","optional":true,"type":"yesorno"},{"description":"Camera2 Viewport: Top (0 to 1)","name":"Top2","type":"expression"},{"description":"Camera2 Viewport: Bottom (0 to 1)","name":"Bottom2","type":"expression"},{"description":"Camera2 Viewport: Left (0 to 1)","name":"Left2","type":"expression"},{"description":"Camera2 Viewport: Right (0 to 1)","name":"Right2","type":"expression"},{"description":"Enable 3D Camera3","name":"Active3","type":"yesorno"},{"description":"Camera3 Viewport: Top (0 to 1)","name":"Top3","type":"expression"},{"description":"Camera3 Viewport: Bottom (0 to 1)","name":"Bottom3","type":"expression"},{"description":"Camera3 Viewport: Left (0 to 1)","name":"Left3","type":"expression"},{"description":"Camera3 Viewport: Right (0 to 1)","name":"Right3","type":"expression"},{"description":"Enable 3D Camera4","name":"Active4","type":"yesorno"},{"description":"Camera4 Viewport: Top (0 to 1)","name":"Top4","type":"expression"},{"description":"Camera4 Viewport: Bottom (0 to 1)","name":"Bottom4","type":"expression"},{"description":"Camera4 Viewport: Left (0 to 1)","name":"Left4","type":"expression"},{"description":"Camera4 Viewport: Right (0 to 1)","name":"Right4","type":"expression"}],"objectGroups":[]},{"fullName":"Linearly interpolate 3D Camera","functionType":"Action","group":"3D Camera","name":"LerpCamera","sentence":"Linearly Interpolate 3D Camera (Camera ID: _PARAM1_, Target ID: _PARAM2_, Position: _PARAM3_, Rotation: _PARAM4_)","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["if (!gdjs.__WithThreeJS.has(\"Renderer\")) {","    console.warn(\"!\");","    return;","}","const Scene = gdjs.__WithThreeJS.get(\"Scene\");","const Id = eventsFunctionContext.getArgument(\"Id\");","const Camera = gdjs.__WithThreeJS.get(\"GetCamera\")(Id);","const TargetId = eventsFunctionContext.getArgument(\"TargetId\");","const FactorP = eventsFunctionContext.getArgument(\"FactorP\");","const FactorR = eventsFunctionContext.getArgument(\"FactorR\");","//","const Obj = gdjs.__WithThreeJS.get(\"SearchObject\")(TargetId);","if (!Obj) {","    console.warn(\"3D Object not found: \" + TargetId);","    return;","}","//","if (FactorP) {","    const WPos = new THREE.Vector3();","    Obj.getWorldPosition(WPos);","    Camera.position.lerp(WPos, FactorP);","}","if (FactorR) {","    const WQua = new THREE.Quaternion();","    Obj.getWorldQuaternion(WQua);","    Camera.quaternion.slerp(WQua, FactorR);","}","",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"parameters":[{"description":"3D Camera ID (1 to 4)","name":"Id","type":"expression"},{"description":"Target 3D Object ID","name":"TargetId","supplementaryInformation":"scene3D Object ID","type":"identifier"},{"description":"Position interpolation factor (0 to 1)","longDescription":"Disable with 0","name":"FactorP","type":"expression"},{"description":"Rotation interpolation factor (0 to 1)","longDescription":"Disable with 0","name":"FactorR","type":"expression"}],"objectGroups":[]},{"fullName":"3D Camera Position","functionType":"Expression","group":"3D Camera","name":"CameraPosition","sentence":"","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["if (!gdjs.__WithThreeJS.has(\"Renderer\")) {","    console.warn(\"!\");","    return;","}","// const Camera = gdjs.__WithThreeJS.get(\"Camera\");","const Id = eventsFunctionContext.getArgument(\"Id\");","const Camera = gdjs.__WithThreeJS.get(\"GetCamera\")(Id);","const Axis = eventsFunctionContext.getArgument(\"Axis\");","if (Axis == \"X\") {","    eventsFunctionContext.returnValue = Camera.position.x;","} else if (Axis == \"Y\") {","    eventsFunctionContext.returnValue = Camera.position.y;","} else {","    eventsFunctionContext.returnValue = Camera.position.z;","}","",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"expressionType":{"type":"expression"},"parameters":[{"description":"3D Camera ID (1 to 4)","name":"Id","type":"expression"},{"description":"Axis","name":"Axis","supplementaryInformation":"[\"X\",\"Y\",\"Z\"]","type":"stringWithSelector"}],"objectGroups":[]},{"fullName":"3D Camera Rotation","functionType":"Expression","group":"3D Camera","name":"CameraRotation","sentence":"","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["if (!gdjs.__WithThreeJS.has(\"Renderer\")) {","    console.warn(\"!\");","    return;","}","// const Camera = gdjs.__WithThreeJS.get(\"Camera\");","const Id = eventsFunctionContext.getArgument(\"Id\");","const Camera = gdjs.__WithThreeJS.get(\"GetCamera\")(Id);","const Axis = eventsFunctionContext.getArgument(\"Axis\");","if (Axis == \"X\") {","    eventsFunctionContext.returnValue = gdjs.toDegrees(Camera.rotation.x);","} else if (Axis == \"Y\") {","    eventsFunctionContext.returnValue = gdjs.toDegrees(Camera.rotation.y);","} else {","    eventsFunctionContext.returnValue = gdjs.toDegrees(Camera.rotation.z);","}","",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"expressionType":{"type":"expression"},"parameters":[{"description":"3D Camera ID (1 to 4)","name":"Id","type":"expression"},{"description":"Axis","name":"Axis","supplementaryInformation":"[\"X\",\"Y\",\"Z\"]","type":"stringWithSelector"}],"objectGroups":[]},{"description":"3D Camera Angle for GDevelop.\nReturns the angle of an individual axis.\nNote that combining the resulting XYZ values may not reproduce the original rotation.","fullName":"3D Camera Angle (Deprecated)","functionType":"Expression","group":"3D Camera","name":"CameraAngle","private":true,"sentence":"","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["if (!gdjs.__WithThreeJS.has(\"Renderer\")) {","    console.warn(\"!\");","    return;","}","// const Camera = gdjs.__WithThreeJS.get(\"Camera\");","const Id = eventsFunctionContext.getArgument(\"Id\");","const Camera = gdjs.__WithThreeJS.get(\"GetCamera\")(Id);","const Axis = eventsFunctionContext.getArgument(\"Axis\");","const Rad3 = gdjs.__WithThreeJS.get(\"GetSingleRadian3\")(Camera);","","if (Axis == \"X\") {","    eventsFunctionContext.returnValue = gdjs.toDegrees(Rad3.x * -1);","} else if (Axis == \"Y\") {","    eventsFunctionContext.returnValue = gdjs.toDegrees(Rad3.y * -1);","} else {","    eventsFunctionContext.returnValue = gdjs.toDegrees(Rad3.z * -1);","}","",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"expressionType":{"type":"expression"},"parameters":[{"description":"3D Camera ID (1 to 4)","name":"Id","type":"expression"},{"description":"Axis","name":"Axis","supplementaryInformation":"[\"X\",\"Y\",\"Z\"]","type":"stringWithSelector"}],"objectGroups":[]},{"description":"Normalized direction vector of 3D camera.\n(3D Camera is shooting in the negative Z axis direction)","fullName":"3D Camera Direction","functionType":"Expression","group":"3D Camera","name":"CameraDirection","sentence":"","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["if (!gdjs.__WithThreeJS.has(\"Renderer\")) {","    console.warn(\"!\");","    return;","}","// const Camera = gdjs.__WithThreeJS.get(\"Camera\");","const Id = eventsFunctionContext.getArgument(\"Id\");","const Camera = gdjs.__WithThreeJS.get(\"GetCamera\")(Id);","const Axis = eventsFunctionContext.getArgument(\"Axis\");","const WorldDirection = new THREE.Vector3();","Camera.getWorldDirection(WorldDirection);","//","if (Axis == \"X\") {","    eventsFunctionContext.returnValue = WorldDirection.x;","} else if (Axis == \"Y\") {","    eventsFunctionContext.returnValue = WorldDirection.y;","} else {","    eventsFunctionContext.returnValue = WorldDirection.z;","}","",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"expressionType":{"type":"expression"},"parameters":[{"description":"3D Camera ID (1 to 4)","name":"Id","type":"expression"},{"description":"Axis","name":"Axis","supplementaryInformation":"[\"X\",\"Y\",\"Z\"]","type":"stringWithSelector"}],"objectGroups":[]},{"fullName":"Distance From 3D Camera To 3D Object","functionType":"Expression","group":"3D Camera","name":"DistanceFrom3DCameraTo3DObject","sentence":"","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["if (!gdjs.__WithThreeJS.has(\"Renderer\")) {","    console.warn(\"!\");","    return;","}","const Scene = gdjs.__WithThreeJS.get(\"Scene\");","// const Camera = gdjs.__WithThreeJS.get(\"Camera\");","const CameraId = eventsFunctionContext.getArgument(\"CameraId\");","const Camera = gdjs.__WithThreeJS.get(\"GetCamera\")(CameraId);","const Id = eventsFunctionContext.getArgument(\"Id\");","//","const Obj = gdjs.__WithThreeJS.get(\"SearchObject\")(Id);","if (!Obj) {","    console.warn(\"3D Object not found: \" + Id);","    return;","}","//","const WPos1 = new THREE.Vector3();","const WPos2 = new THREE.Vector3();","Camera.getWorldPosition(WPos1);","Obj.getWorldPosition(WPos2);","eventsFunctionContext.returnValue = WPos1.distanceTo(WPos2);","",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"expressionType":{"type":"expression"},"parameters":[{"description":"From 3D Camera ID (1 to 4)","name":"CameraId","type":"expression"},{"description":"To 3D Object ID","name":"Id","supplementaryInformation":"scene3D Object ID","type":"identifier"}],"objectGroups":[]},{"fullName":"3D Camera FOV","functionType":"Expression","group":"3D Camera","name":"CameraFOV","sentence":"","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["if (!gdjs.__WithThreeJS.has(\"Renderer\")) {","    console.warn(\"!\");","    return;","}","// const Camera = gdjs.__WithThreeJS.get(\"Camera\");","const Id = eventsFunctionContext.getArgument(\"Id\");","const Camera = gdjs.__WithThreeJS.get(\"GetCamera\")(Id);","eventsFunctionContext.returnValue = Camera.fov;","",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"expressionType":{"type":"expression"},"parameters":[{"description":"3D Camera ID (1 to 4)","name":"Id","type":"expression"}],"objectGroups":[]},{"description":"The camera will not render objects closer than this distance.","fullName":"3D Camera Near","functionType":"Expression","group":"3D Camera","name":"CameraNear","sentence":"","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["if (!gdjs.__WithThreeJS.has(\"Renderer\")) {","    console.warn(\"!\");","    return;","}","// const Camera = gdjs.__WithThreeJS.get(\"Camera\");","const Id = eventsFunctionContext.getArgument(\"Id\");","const Camera = gdjs.__WithThreeJS.get(\"GetCamera\")(Id);","eventsFunctionContext.returnValue = Camera.near;","",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"expressionType":{"type":"expression"},"parameters":[{"description":"3D Camera ID (1 to 4)","name":"Id","type":"expression"}],"objectGroups":[]},{"fullName":"3D Camera Far","functionType":"Expression","group":"3D Camera","name":"CameraFar","sentence":"","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["if (!gdjs.__WithThreeJS.has(\"Renderer\")) {","    console.warn(\"!\");","    return;","}","// const Camera = gdjs.__WithThreeJS.get(\"Camera\");","const Id = eventsFunctionContext.getArgument(\"Id\");","const Camera = gdjs.__WithThreeJS.get(\"GetCamera\")(Id);","eventsFunctionContext.returnValue = Camera.far;","",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"expressionType":{"type":"expression"},"parameters":[{"description":"3D Camera ID (1 to 4)","name":"Id","type":"expression"}],"objectGroups":[]},{"fullName":"3D Camera Zoom","functionType":"Expression","group":"3D Camera","name":"CameraZoom","sentence":"","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["if (!gdjs.__WithThreeJS.has(\"Renderer\")) {","    console.warn(\"!\");","    return;","}","// const Camera = gdjs.__WithThreeJS.get(\"Camera\");","const Id = eventsFunctionContext.getArgument(\"Id\");","const Camera = gdjs.__WithThreeJS.get(\"GetCamera\")(Id);","eventsFunctionContext.returnValue = Camera.zoom;","",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"expressionType":{"type":"expression"},"parameters":[{"description":"3D Camera ID (1 to 4)","name":"Id","type":"expression"}],"objectGroups":[]},{"fullName":"Point Of 3D Object On 3D Camera","functionType":"Expression","group":"3D Camera","name":"PointOf3DObjectOn3DCamera","sentence":"","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["if (!gdjs.__WithThreeJS.has(\"Renderer\")) {","    console.warn(\"!\");","    return;","}","const Scene = gdjs.__WithThreeJS.get(\"Scene\");","const CameraId = eventsFunctionContext.getArgument(\"CameraId\");","const Camera = gdjs.__WithThreeJS.get(\"GetCamera\")(CameraId);","const Id = eventsFunctionContext.getArgument(\"Id\");","const Axis = eventsFunctionContext.getArgument(\"Axis\");","//","const Obj = gdjs.__WithThreeJS.get(\"SearchObject\")(Id);","if (!Obj) {","    console.warn(\"3D Object not found: \" + Id);","    return;","}","//","const WorldPosition = new THREE.Vector3();","Obj.getWorldPosition(WorldPosition);","const Project = WorldPosition.project(Camera);","//","const T = Camera.userData.CameraStatus.T;","const B = Camera.userData.CameraStatus.B;","const L = Camera.userData.CameraStatus.L;","const R = Camera.userData.CameraStatus.R;","const GameResolutionWidth = runtimeScene.getGame().getGameResolutionWidth();","const GameResolutionHeight = runtimeScene.getGame().getGameResolutionHeight();","const ScreenResolutionWidth = GameResolutionWidth * (R - L);","const ScreenResolutionHeight = GameResolutionHeight * (T - B);","const CameraScreenX = L * GameResolutionWidth;","const CameraScreenY = (1 - T) * GameResolutionHeight;","//","const PointX = CameraScreenX + ((ScreenResolutionWidth / 2) * (Project.x + 1.0));","const PointY = CameraScreenY + ((ScreenResolutionHeight / 2) * ((Project.y * -1) + 1.0));","//","if (Axis == \"X\") {","    eventsFunctionContext.returnValue = PointX;","} else {","    eventsFunctionContext.returnValue = PointY;","}","",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"expressionType":{"type":"expression"},"parameters":[{"description":"3D Camera ID (1 to 4)","name":"CameraId","type":"expression"},{"description":"3D Object ID","name":"Id","supplementaryInformation":"scene3D Object ID","type":"identifier"},{"description":"Axis Of Return Value","name":"Axis","supplementaryInformation":"[\"X\",\"Y\"]","type":"stringWithSelector"}],"objectGroups":[]},{"fullName":"Point Of World Position On 3D Camera","functionType":"Expression","group":"3D Camera","name":"PointOfPositionOn3DCamera","sentence":"","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["if (!gdjs.__WithThreeJS.has(\"Renderer\")) {","    console.warn(\"!\");","    return;","}","const CameraId = eventsFunctionContext.getArgument(\"CameraId\");","const Camera = gdjs.__WithThreeJS.get(\"GetCamera\")(CameraId);","const X = eventsFunctionContext.getArgument(\"X\");","const Y = eventsFunctionContext.getArgument(\"Y\");","const Z = eventsFunctionContext.getArgument(\"Z\");","const Axis = eventsFunctionContext.getArgument(\"Axis\");","//","const WorldPosition = new THREE.Vector3(X, Y, Z);","const Project = WorldPosition.project(Camera);","//","const T = Camera.userData.CameraStatus.T;","const B = Camera.userData.CameraStatus.B;","const L = Camera.userData.CameraStatus.L;","const R = Camera.userData.CameraStatus.R;","const GameResolutionWidth = runtimeScene.getGame().getGameResolutionWidth();","const GameResolutionHeight = runtimeScene.getGame().getGameResolutionHeight();","const ScreenResolutionWidth = GameResolutionWidth * (R - L);","const ScreenResolutionHeight = GameResolutionHeight * (T - B);","const CameraScreenX = L * GameResolutionWidth;","const CameraScreenY = (1 - T) * GameResolutionHeight;","//","const PointX = CameraScreenX + ((ScreenResolutionWidth / 2) * (Project.x + 1.0));","const PointY = CameraScreenY + ((ScreenResolutionHeight / 2) * ((Project.y * -1) + 1.0));","//","if (Axis == \"X\") {","    eventsFunctionContext.returnValue = PointX;","} else {","    eventsFunctionContext.returnValue = PointY;","}","",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"expressionType":{"type":"expression"},"parameters":[{"description":"3D Camera ID (1 to 4)","name":"CameraId","type":"expression"},{"description":"World Position X","name":"X","supplementaryInformation":"scene3D Object ID","type":"expression"},{"description":"World Position Y","name":"Y","type":"expression"},{"description":"World Position Z","name":"Z","type":"expression"},{"description":"Axis Of Return Value","name":"Axis","supplementaryInformation":"[\"X\",\"Y\"]","type":"stringWithSelector"}],"objectGroups":[]},{"description":"Move a 3D Object.\n'=' is relative to the parent axis.\n\"+\" and \"-\" are relative to the local axis.","fullName":"Move 3D Object","functionType":"Action","group":"3D Object","name":"Move3DObject","sentence":"Move 3D Object (ID: _PARAM1_, _PARAM2_, X: _PARAM3_, Y: _PARAM4_, Z: _PARAM5_)","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["if (!gdjs.__WithThreeJS.has(\"Renderer\")) {","    console.warn(\"!\");","    return;","}","const Scene = gdjs.__WithThreeJS.get(\"Scene\");","const Id = eventsFunctionContext.getArgument(\"Id\");","const Operator = eventsFunctionContext.getArgument(\"Operator\");","const X = eventsFunctionContext.getArgument(\"X\");","const Y = eventsFunctionContext.getArgument(\"Y\");","const Z = eventsFunctionContext.getArgument(\"Z\");","//","const Obj = gdjs.__WithThreeJS.get(\"SearchObject\")(Id);","if (!Obj) {","    console.warn(\"3D Object not found: \" + Id);","    return;","}","//","if (Operator == \"=\") {","    Obj.position.set(X, Y, Z);","} else if (Operator == \"+\") {","    Obj.translateX(X);","    Obj.translateY(Y);","    Obj.translateZ(Z);","} else {","    Obj.translateX(-X);","    Obj.translateY(-Y);","    Obj.translateZ(-Z);","}","",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"parameters":[{"description":"3D Object ID","name":"Id","supplementaryInformation":"scene3D Object ID","type":"identifier"},{"description":"Operator","name":"Operator","supplementaryInformation":"[\"=\",\"+\",\"-\"]","type":"stringWithSelector"},{"description":"X","name":"X","type":"expression"},{"description":"Y","name":"Y","type":"expression"},{"description":"Z","name":"Z","type":"expression"}],"objectGroups":[]},{"description":"Move a 3D Object on the world axis.\n\"=\", \"+\" and \"-\" are relative to the world axis.","fullName":"Move 3D Object On World","functionType":"Action","group":"3D Object","name":"Move3DObjectOnWorld","sentence":"Move 3D Object On World (ID: _PARAM1_, _PARAM2_, X: _PARAM3_, Y: _PARAM4_, Z: _PARAM5_)","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["if (!gdjs.__WithThreeJS.has(\"Renderer\")) {","    console.warn(\"!\");","    return;","}","const Scene = gdjs.__WithThreeJS.get(\"Scene\");","const Id = eventsFunctionContext.getArgument(\"Id\");","const Operator = eventsFunctionContext.getArgument(\"Operator\");","const X = eventsFunctionContext.getArgument(\"X\");","const Y = eventsFunctionContext.getArgument(\"Y\");","const Z = eventsFunctionContext.getArgument(\"Z\");","//","const Obj = gdjs.__WithThreeJS.get(\"SearchObject\")(Id);","if (!Obj) {","    console.warn(\"3D Object not found: \" + Id);","    return;","}","//","const Parent = Obj.parent;","const WorldPosition = new THREE.Vector3();","Obj.getWorldPosition(WorldPosition);","if (Operator == \"=\") {","    WorldPosition.set(X, Y, Z);","} else if (Operator == \"+\") {","    WorldPosition.add(new THREE.Vector3(X, Y, Z));","} else {","    WorldPosition.sub(new THREE.Vector3(X, Y, Z));","}","Parent.worldToLocal(WorldPosition);","Obj.position.set(WorldPosition.x, WorldPosition.y, WorldPosition.z);","",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"parameters":[{"description":"3D Object ID","name":"Id","supplementaryInformation":"scene3D Object ID","type":"identifier"},{"description":"Operator","name":"Operator","supplementaryInformation":"[\"=\",\"+\",\"-\"]","type":"stringWithSelector"},{"description":"X","name":"X","type":"expression"},{"description":"Y","name":"Y","type":"expression"},{"description":"Z","name":"Z","type":"expression"}],"objectGroups":[]},{"description":"Rotate the 3D Object in the order X, Y, Z.","fullName":"Rotate 3D Object","functionType":"Action","group":"3D Object","name":"Rotate3DObject","sentence":"Rotate 3D Object (ID: _PARAM1_, _PARAM2_, X: _PARAM3_, Y: _PARAM4_, Z: _PARAM5_)","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["if (!gdjs.__WithThreeJS.has(\"Renderer\")) {","    console.warn(\"!\");","    return;","}","const Scene = gdjs.__WithThreeJS.get(\"Scene\");","const Id = eventsFunctionContext.getArgument(\"Id\");","const Operator = eventsFunctionContext.getArgument(\"Operator\");","const AngleX = eventsFunctionContext.getArgument(\"AngleX\");","const AngleY = eventsFunctionContext.getArgument(\"AngleY\");","const AngleZ = eventsFunctionContext.getArgument(\"AngleZ\");","//","const Obj = gdjs.__WithThreeJS.get(\"SearchObject\")(Id);","if (!Obj) {","    console.warn(\"3D Object not found: \" + Id);","    return;","}","//","if (Operator == \"=\") {","    Obj.rotation.set(gdjs.toRad(AngleX), gdjs.toRad(AngleY), gdjs.toRad(AngleZ));","} else if (Operator == \"+\") {","    Obj.rotateX(gdjs.toRad(AngleX));","    Obj.rotateY(gdjs.toRad(AngleY));","    Obj.rotateZ(gdjs.toRad(AngleZ));","} else {","    Obj.rotateX(gdjs.toRad(-AngleX));","    Obj.rotateY(gdjs.toRad(-AngleY));","    Obj.rotateZ(gdjs.toRad(-AngleZ));","}","",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"parameters":[{"description":"3D Object ID","name":"Id","supplementaryInformation":"scene3D Object ID","type":"identifier"},{"description":"Operator","name":"Operator","supplementaryInformation":"[\"=\",\"+\",\"-\"]","type":"stringWithSelector"},{"description":"Angle X","name":"AngleX","type":"expression"},{"description":"Angle Y","name":"AngleY","type":"expression"},{"description":"Angle Z","name":"AngleZ","type":"expression"}],"objectGroups":[]},{"description":"Rotate the 3D Object first in the world Y axis, then on the local X and Z axes.","fullName":"Rotate 3D Object Like Head","functionType":"Action","group":"3D Object","name":"Rotate3DObjectLikeHead","sentence":"Rotate 3D Object Like Head (ID: _PARAM1_, _PARAM2_, X: _PARAM3_, Y: _PARAM4_, Z: _PARAM5_)","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["if (!gdjs.__WithThreeJS.has(\"Renderer\")) {","    console.warn(\"!\");","    return;","}","const Scene = gdjs.__WithThreeJS.get(\"Scene\");","const Id = eventsFunctionContext.getArgument(\"Id\");","const Operator = eventsFunctionContext.getArgument(\"Operator\");","const AngleX = eventsFunctionContext.getArgument(\"AngleX\");","const AngleY = eventsFunctionContext.getArgument(\"AngleY\");","const AngleZ = eventsFunctionContext.getArgument(\"AngleZ\");","//","const Obj = gdjs.__WithThreeJS.get(\"SearchObject\")(Id);","if (!Obj) {","    console.warn(\"3D Object not found: \" + Id);","    return;","}","//","const Parent = Obj.parent;","Scene.attach(Obj);","if (Operator == \"=\") {","    Obj.rotation.set(0, 0, 0);","    Obj.rotateY(gdjs.toRad(AngleY));","    Obj.rotateX(gdjs.toRad(AngleX));","    Obj.rotateZ(gdjs.toRad(AngleZ));","} else if (Operator == \"+\") {","    Obj.rotateX(gdjs.toRad(AngleX));","    Obj.rotateOnWorldAxis(new THREE.Vector3(0, 1, 0), gdjs.toRad(AngleY));","    Obj.rotateZ(gdjs.toRad(AngleZ));","} else {","    Obj.rotateX(gdjs.toRad(-AngleX));","    Obj.rotateOnWorldAxis(new THREE.Vector3(0, 1, 0), gdjs.toRad(-AngleY));","    Obj.rotateZ(gdjs.toRad(-AngleZ));","}","Parent.attach(Obj);","",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"parameters":[{"description":"3D Object ID","name":"Id","supplementaryInformation":"scene3D Object ID","type":"identifier"},{"description":"Operator","name":"Operator","supplementaryInformation":"[\"=\",\"+\",\"-\"]","type":"stringWithSelector"},{"description":"Angle X","name":"AngleX","type":"expression"},{"description":"Angle Y","name":"AngleY","type":"expression"},{"description":"Angle Z","name":"AngleZ","type":"expression"}],"objectGroups":[]},{"description":"Rotate the 3D Object in the order X, Y, Z on the world axis.","fullName":"Rotate 3D Object On World","functionType":"Action","group":"3D Object","name":"Rotate3DObjectOnWorld","sentence":"Rotate 3D Object On World (ID: _PARAM1_, _PARAM2_, X: _PARAM3_, Y: _PARAM4_, Z: _PARAM5_)","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["if (!gdjs.__WithThreeJS.has(\"Renderer\")) {","    console.warn(\"!\");","    return;","}","const Scene = gdjs.__WithThreeJS.get(\"Scene\");","const Id = eventsFunctionContext.getArgument(\"Id\");","const Operator = eventsFunctionContext.getArgument(\"Operator\");","const AngleX = eventsFunctionContext.getArgument(\"AngleX\");","const AngleY = eventsFunctionContext.getArgument(\"AngleY\");","const AngleZ = eventsFunctionContext.getArgument(\"AngleZ\");","//","const Obj = gdjs.__WithThreeJS.get(\"SearchObject\")(Id);","if (!Obj) {","    console.warn(\"3D Object not found: \" + Id);","    return;","}","//","const Parent = Obj.parent;","Scene.attach(Obj);","if (Operator == \"=\") {","    Obj.rotation.set(0, 0, 0);","    Obj.rotateOnWorldAxis(new THREE.Vector3(1, 0, 0), gdjs.toRad(AngleX));","    Obj.rotateOnWorldAxis(new THREE.Vector3(0, 1, 0), gdjs.toRad(AngleY));","    Obj.rotateOnWorldAxis(new THREE.Vector3(0, 0, 1), gdjs.toRad(AngleZ));","} else if (Operator == \"+\") {","    Obj.rotateOnWorldAxis(new THREE.Vector3(1, 0, 0), gdjs.toRad(AngleX));","    Obj.rotateOnWorldAxis(new THREE.Vector3(0, 1, 0), gdjs.toRad(AngleY));","    Obj.rotateOnWorldAxis(new THREE.Vector3(0, 0, 1), gdjs.toRad(AngleZ));","} else {","    Obj.rotateOnWorldAxis(new THREE.Vector3(1, 0, 0), gdjs.toRad(-AngleX));","    Obj.rotateOnWorldAxis(new THREE.Vector3(0, 1, 0), gdjs.toRad(-AngleY));","    Obj.rotateOnWorldAxis(new THREE.Vector3(0, 0, 1), gdjs.toRad(-AngleZ));","}","Parent.attach(Obj);","",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"parameters":[{"description":"3D Object ID","name":"Id","supplementaryInformation":"scene3D Object ID","type":"identifier"},{"description":"Operator","name":"Operator","supplementaryInformation":"[\"=\",\"+\",\"-\"]","type":"stringWithSelector"},{"description":"Angle X","name":"AngleX","type":"expression"},{"description":"Angle Y","name":"AngleY","type":"expression"},{"description":"Angle Z","name":"AngleZ","type":"expression"}],"objectGroups":[]},{"fullName":"Look At 3D Object","functionType":"Action","group":"3D Object","name":"LookAt3DObject","sentence":"Look At 3D Object (ID: _PARAM1_, Target ID: _PARAM2_)","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["if (!gdjs.__WithThreeJS.has(\"Renderer\")) {","    console.warn(\"!\");","    return;","}","const Scene = gdjs.__WithThreeJS.get(\"Scene\");","const Id = eventsFunctionContext.getArgument(\"Id\");","const TargetId = eventsFunctionContext.getArgument(\"TargetId\");","//","const Obj = gdjs.__WithThreeJS.get(\"SearchObject\")(Id);","const TargetObj = gdjs.__WithThreeJS.get(\"SearchObject\")(TargetId);","if (!Obj || !TargetObj) {","    console.warn(\"3D Object not found: \" + Id + \" or \" + TargetId);","    return;","}","//","const WPos = new THREE.Vector3();","TargetObj.getWorldPosition(WPos);","Obj.lookAt(WPos);","",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"parameters":[{"description":"3D Object ID","name":"Id","supplementaryInformation":"scene3D Object ID","type":"identifier"},{"description":"Target 3D Object ID","name":"TargetId","supplementaryInformation":"scene3D Object ID","type":"identifier"}],"objectGroups":[]},{"fullName":"Look At 3D Camera","functionType":"Action","group":"3D Object","name":"LookAt3DCamera","sentence":"Look At 3D Camera (Object ID: _PARAM1_, Camera ID: _PARAM2_)","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["if (!gdjs.__WithThreeJS.has(\"Renderer\")) {","    console.warn(\"!\");","    return;","}","const Scene = gdjs.__WithThreeJS.get(\"Scene\");","const Id = eventsFunctionContext.getArgument(\"Id\");","// const Camera = gdjs.__WithThreeJS.get(\"Camera\");","const CameraId = eventsFunctionContext.getArgument(\"CameraId\");","const Camera = gdjs.__WithThreeJS.get(\"GetCamera\")(CameraId);","//","const Obj = gdjs.__WithThreeJS.get(\"SearchObject\")(Id);","if (!Obj) {","    console.warn(\"3D Object not found: \" + Id);","    return;","}","//","Obj.lookAt(Camera.position);","",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"parameters":[{"description":"3D Object ID","name":"Id","supplementaryInformation":"scene3D Object ID","type":"identifier"},{"description":"3D Camera ID (1 to 4)","name":"CameraId","type":"expression"}],"objectGroups":[]},{"description":"Remove a 3D Object from the 3D Scene.\nThis action cannot remove 3D Objects created by 3D Projection Behaviors.\nThis action does not clear the loaded 3D Texture data and the loaded 3D Model data.\nThey will continue to be accessible by ID.","fullName":"Remove 3D Object","functionType":"Action","group":"3D Object","name":"Remove3DObject","sentence":"Remove 3D Object (ID: _PARAM1_)","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["if (!gdjs.__WithThreeJS.has(\"Renderer\")) {","    console.warn(\"!\");","    return;","}","const Scene = gdjs.__WithThreeJS.get(\"Scene\");","const Id = eventsFunctionContext.getArgument(\"Id\");","//","const Obj = gdjs.__WithThreeJS.get(\"SearchObject\")(Id);","if (!Obj) {","    console.warn(\"3D Object not found: \" + Id);","    return;","}","if (Obj.userData.Use3DProjectionBehavior) {","    console.warn(\"3D Object could not be removed.\");","    return;","}","//","// Obj.clear();","gdjs.__WithThreeJS.get(\"DisposeChildren\")(Obj);","Obj.removeFromParent();","",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"parameters":[{"description":"3D Object ID","name":"Id","supplementaryInformation":"scene3D Object ID","type":"identifier"}],"objectGroups":[]},{"description":"Change the 3D Texture of a 3D Object.","fullName":"Change 3D Texture","functionType":"Action","group":"3D Object","name":"Change3DTexture","sentence":"Change 3D Texture (ID: _PARAM1_, Texture: _PARAM2_)","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["if (!gdjs.__WithThreeJS.has(\"Renderer\")) {","    console.warn(\"!\");","    return;","}","if (!gdjs.__WithThreeJS.has(\"Textures\")) {","    console.warn(\"!\");","    return;","}","const Scene = gdjs.__WithThreeJS.get(\"Scene\");","const Textures = gdjs.__WithThreeJS.get(\"Textures\");","//","const Id = eventsFunctionContext.getArgument(\"Id\");","const TextureIdList = eventsFunctionContext.getArgument(\"TextureIdList\");","//","const Obj = gdjs.__WithThreeJS.get(\"SearchObject\")(Id);","if (!Obj) {","    console.warn(\"3D Object not found: \" + Id);","    return;","}","let TextureList = [];","for (const V of TextureIdList.split(\"\\n\")) {","    if (V != \"\") {","        if (!Textures.has(V)) {","            console.warn(\"3D Texture not found: \" + V);","        } else {","            TextureList.push(Textures.get(V));","        }","    }","}","//","gdjs.__WithThreeJS.get(\"SetAllTextures\")(Obj, TextureList);","",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"parameters":[{"description":"3D Object ID","name":"Id","supplementaryInformation":"scene3D Object ID","type":"identifier"},{"description":"3D Texture ID List","longDescription":"One Texture ID per line.","name":"TextureIdList","supplementaryInformation":"scene3D Texture ID","type":"identifier"}],"objectGroups":[]},{"description":"Change the visibility of a 3D Object.","fullName":"Change 3D Object Visibility","functionType":"Action","group":"3D Object","name":"ChangeVisibility","sentence":"Change 3D Object Visibility (ID: _PARAM1_, Visible: _PARAM2_, Inherit: _PARAM3_)","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["if (!gdjs.__WithThreeJS.has(\"Renderer\")) {","    console.warn(\"!\");","    return;","}","const Scene = gdjs.__WithThreeJS.get(\"Scene\");","//","const Id = eventsFunctionContext.getArgument(\"Id\");","const Visible = eventsFunctionContext.getArgument(\"Visible\");","const Inherit = eventsFunctionContext.getArgument(\"Inherit\");","//","const Obj = gdjs.__WithThreeJS.get(\"SearchObject\")(Id);","if (!Obj) {","    console.warn(\"3D Object not found: \" + Id);","    return;","}","//","if (Inherit) {","    Obj.visible = Visible;","} else {","    if (Obj.material) {","        if (Array.isArray(Obj.material)) {","            for (let i = 0; i < Obj.material.length; i++) {","                Obj.material[i].visible = Visible;","            }","        } else {","            Obj.material.visible = Visible;","        }","    } else {","        // Obj.visible = Visible;","    }","}","",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"parameters":[{"description":"3D Object ID","name":"Id","supplementaryInformation":"scene3D Object ID","type":"identifier"},{"defaultValue":"yes","description":"Visible","name":"Visible","optional":true,"type":"yesorno"},{"defaultValue":"no","description":"Inherit to Children","longDescription":"The visibility of a child 3D Object that has been changed by inheritance cannot be changed individually.  \nSimilarly, the visibility of an individually changed child 3D Object cannot be changed by inheritance.","name":"Inherit","optional":true,"type":"yesorno"}],"objectGroups":[]},{"description":"Change the Opacity of a 3D Object.\nThe same value is set for multiple textures.","fullName":"Change 3D Object Opacity","functionType":"Action","group":"3D Object","name":"ChangeOpacity","sentence":"Change 3D Object Opacity (ID: _PARAM1_, _PARAM2_, Opacity: _PARAM3_)","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["if (!gdjs.__WithThreeJS.has(\"Renderer\")) {","    console.warn(\"!\");","    return;","}","const Scene = gdjs.__WithThreeJS.get(\"Scene\");","//","const Id = eventsFunctionContext.getArgument(\"Id\");","const Operator = eventsFunctionContext.getArgument(\"Operator\");","const Opacity = eventsFunctionContext.getArgument(\"Opacity\");","//","const Obj = gdjs.__WithThreeJS.get(\"SearchObject\")(Id);","if (!Obj) {","    console.warn(\"3D Object not found: \" + Id);","    return;","}","//","Obj.traverse((Child) => {","    if (Child.material) {","        if (Array.isArray(Child.material)) {","            for (let i = 0; i < Child.material.length; i++) {","                if (!Child.material[i].transparent) {","                    Child.material[i].transparent = true;","                    Child.material[i].needsUpdate = true;","                }","                if (Operator == \"=\") {","                    Child.material[i].opacity = Opacity;","                } else if (Operator == \"+\") {","                    Child.material[i].opacity += Opacity;","                } else {","                    Child.material[i].opacity -= Opacity;","                }","                if (Child.material[i].opacity < 0) Child.material[i].opacity = 0;","                if (Child.material[i].opacity > 1) Child.material[i].opacity = 1;","            }","        } else {","            if (!Child.material.transparent) {","                Child.material.transparent = true;","                Child.material.needsUpdate = true;","            }","            if (Operator == \"=\") {","                Child.material.opacity = Opacity;","            } else if (Operator == \"+\") {","                Child.material.opacity += Opacity;","            } else {","                Child.material.opacity -= Opacity;","            }","            if (Child.material.opacity < 0) Child.material.opacity = 0;","            if (Child.material.opacity > 1) Child.material.opacity = 1;","        }","    }","});","",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"parameters":[{"description":"3D Object ID","name":"Id","supplementaryInformation":"scene3D Object ID","type":"identifier"},{"description":"Operator","name":"Operator","supplementaryInformation":"[\"=\",\"+\",\"-\"]","type":"stringWithSelector"},{"description":"Opacity (0 to 1)","longDescription":"1 is fully opaque.","name":"Opacity","type":"expression"}],"objectGroups":[]},{"description":"Change the Scale of a 3D Object.\nNote that 3D Sprite and 3D Model were scaled when created.","fullName":"Change 3D Object Scale","functionType":"Action","group":"3D Object","name":"ChangeScale","sentence":"Change 3D Object Scale (ID: _PARAM1_, _PARAM2_, X: _PARAM3_, Y: _PARAM4_, Z: _PARAM5_)","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["if (!gdjs.__WithThreeJS.has(\"Renderer\")) {","    console.warn(\"!\");","    return;","}","const Scene = gdjs.__WithThreeJS.get(\"Scene\");","const Id = eventsFunctionContext.getArgument(\"Id\");","const Operator = eventsFunctionContext.getArgument(\"Operator\");","const X = eventsFunctionContext.getArgument(\"X\");","const Y = eventsFunctionContext.getArgument(\"Y\");","const Z = eventsFunctionContext.getArgument(\"Z\");","//","const Obj = gdjs.__WithThreeJS.get(\"SearchObject\")(Id);","if (!Obj) {","    console.warn(\"3D Object not found: \" + Id);","    return;","}","//","if (Obj.isSprite) {","    const Texture = Obj.material.map;","    const TextureWidth = Texture.image.width;","    const TextureHeight = Texture.image.height;","    if (Operator == \"=\") {","        Obj.scale.set(TextureWidth * X, TextureHeight * Y, 1);","    } else if (Operator == \"+\") {","        Obj.scale.x += TextureWidth * X;","        Obj.scale.y += TextureHeight * Y;","    } else if (Operator == \"-\") {","        Obj.scale.x -= TextureWidth * X;","        Obj.scale.y -= TextureHeight * Y;","    } else {","        Obj.scale.x *= TextureWidth * X;","        Obj.scale.y *= TextureHeight * Y;","    }","} else {","    if (Operator == \"=\") {","        Obj.scale.set(X, Y, Z);","    } else if (Operator == \"+\") {","        Obj.scale.x += X;","        Obj.scale.y += Y;","        Obj.scale.z += Z;","    } else if (Operator == \"-\") {","        Obj.scale.x -= X;","        Obj.scale.y -= Y;","        Obj.scale.z -= Z;","    } else {","        Obj.scale.x *= X;","        Obj.scale.y *= Y;","        Obj.scale.z *= Z;","    }","}","",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"parameters":[{"description":"3D Object ID","name":"Id","supplementaryInformation":"scene3D Object ID","type":"identifier"},{"description":"Operator","name":"Operator","supplementaryInformation":"[\"=\",\"+\",\"-\",\"*\"]","type":"stringWithSelector"},{"description":"Scale X Axis","name":"X","type":"expression"},{"description":"Scale Y Axis","name":"Y","type":"expression"},{"description":"Scale Z Axis","name":"Z","type":"expression"}],"objectGroups":[]},{"description":"Change the DepthWrite of a 3D Object.\nWhether rendering this 3D Object has any effect on the depth buffer.\nIf transparent 3D Objects overlap and render incorrectly, you may be able to obtain ideal rendering results by setting the DepthWrite of that 3D Object to No.\nDefault is Yes.","fullName":"Change 3D Object DepthWrite","functionType":"Action","group":"3D Object","name":"ChangeDepthWrite","sentence":"Change 3D Object DepthWrite (ID: _PARAM1_, Write: _PARAM2_)","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["if (!gdjs.__WithThreeJS.has(\"Renderer\")) {","    console.warn(\"!\");","    return;","}","const Scene = gdjs.__WithThreeJS.get(\"Scene\");","//","const Id = eventsFunctionContext.getArgument(\"Id\");","const Write = eventsFunctionContext.getArgument(\"Write\");","//","const Obj = gdjs.__WithThreeJS.get(\"SearchObject\")(Id);","if (!Obj) {","    console.warn(\"3D Object not found: \" + Id);","    return;","}","//","Obj.traverse((Child) => {","  if (Child.material) {","    if (Array.isArray(Child.material)) {","      for (let i = 0; i < Child.material.length; i++) {","        Child.material[i].depthWrite = Write;","      }","    } else {","      Child.material.depthWrite = Write;","    }","  }","});","",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"parameters":[{"description":"3D Object ID","name":"Id","supplementaryInformation":"scene3D Object ID","type":"identifier"},{"defaultValue":"yes","description":"Depth Write","name":"Write","optional":true,"type":"yesorno"}],"objectGroups":[]},{"description":"Change all animations speed scale of a 3D Object.\n0 is pause.\nNegative values play backwards.","fullName":"Change 3D Object All Animations Speed Scale","functionType":"Action","group":"3D Object","name":"ChangeAllAnimationsSpeedScale","sentence":"Change All Animations Speed Scale (ID: _PARAM1_, _PARAM2_, Speed: _PARAM3_)","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["if (!gdjs.__WithThreeJS.has(\"Renderer\")) {","    console.warn(\"!\");","    return;","}","const Scene = gdjs.__WithThreeJS.get(\"Scene\");","const AnimationActions = gdjs.__WithThreeJS.get(\"AnimationActions\");","const Id = eventsFunctionContext.getArgument(\"Id\");","const Operator = eventsFunctionContext.getArgument(\"Operator\");","const Speed = eventsFunctionContext.getArgument(\"Speed\");","//","const Obj = gdjs.__WithThreeJS.get(\"SearchObject\")(Id);","if (!Obj) {","    console.warn(\"3D Object not found: \" + Id);","    return;","}","//","const OBJ_UUID = Obj.uuid;","if (AnimationActions.has(OBJ_UUID)) {","    for (const [K, V] of AnimationActions.get(OBJ_UUID)) {","        if (Operator == \"=\") {","            V.timeScale = Speed;","        } else if (Operator == \"+\") {","            V.timeScale += Speed;","        } else {","            V.timeScale -= Speed;","        }","    }","}","",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"parameters":[{"description":"3D Object ID","name":"Id","supplementaryInformation":"scene3D Object ID","type":"identifier"},{"description":"Operator","name":"Operator","supplementaryInformation":"[\"=\",\"+\",\"-\"]","type":"stringWithSelector"},{"description":"Animation Speed Scale (Default: 1)","name":"Speed","type":"expression"}],"objectGroups":[]},{"description":"Change the Blend Mode of a 3D Object.","fullName":"Change 3D Object Blend Mode","functionType":"Action","group":"3D Object","name":"ChangeBlendMode","sentence":"Change 3D Object Blend Mode (ID: _PARAM1_, Blend Mode: _PARAM2_)","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["if (!gdjs.__WithThreeJS.has(\"Renderer\")) {","    console.warn(\"!\");","    return;","}","const Scene = gdjs.__WithThreeJS.get(\"Scene\");","const Id = eventsFunctionContext.getArgument(\"Id\");","let Blend = THREE.NormalBlending;","if (eventsFunctionContext.getArgument(\"Blend\") == \"Additive\") {","    Blend = THREE.AdditiveBlending;","} else if (eventsFunctionContext.getArgument(\"Blend\") == \"Subtractive\") {","    Blend = THREE.SubtractiveBlending;","} else if (eventsFunctionContext.getArgument(\"Blend\") == \"Multiply\") {","    Blend = THREE.MultiplyBlending;","}","//","const Obj = gdjs.__WithThreeJS.get(\"SearchObject\")(Id);","if (!Obj) {","    console.warn(\"3D Object not found: \" + Id);","    return;","}","//","Obj.traverse((Child) => {","    if (Child.material) {","        if (Array.isArray(Child.material)) {","            for (let i = 0; i < Child.material.length; i++) {","                Child.material[i].blending = Blend;","            }","        } else {","            Child.material.blending = Blend;","        }","    }","});","",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"parameters":[{"description":"3D Object ID","name":"Id","supplementaryInformation":"scene3D Object ID","type":"identifier"},{"description":"Blend Mode","longDescription":"The same value is set for multiple textures.","name":"Blend","supplementaryInformation":"[\"Normal\",\"Additive\",\"Subtractive\",\"Multiply\"]","type":"stringWithSelector"}],"objectGroups":[]},{"description":"Resolve collisions between Bounding Boxes.\nIt is not necessary to use the \"Check Bounding Box Collision\" condition beforehand. (It will do almost the same processing)\nNote that the 3D Objects are still in contact after resolution. (\"Check Bounding Box Collision\" condition will not be false.)\n3D Object thickness too thin for the amount of movement will not resolve correctly.\nThis action updates the \"Bounding Box Collision Result\".\n\"Bounding Box Collision Result\" stores the value when the Target 3D Object is unmoved.","fullName":"Resolve Bounding Box Collision","functionType":"Action","group":"3D Object","name":"ResolveBoundingBoxCollisionV2","sentence":"Resolve Bounding Box Collision (ID: _PARAM1_, Target: _PARAM2_, Unmoved: _PARAM3_)","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["if (!gdjs.__WithThreeJS.has(\"Renderer\")) {","    console.warn(\"!\");","    return;","}","const Scene = gdjs.__WithThreeJS.get(\"Scene\");","const Id = eventsFunctionContext.getArgument(\"Id\");","const TargetId = eventsFunctionContext.getArgument(\"TargetId\");","const Unmoved = eventsFunctionContext.getArgument(\"Unmoved\");","//","const Obj = gdjs.__WithThreeJS.get(\"SearchObject\")(Id);","const TargetObj = gdjs.__WithThreeJS.get(\"SearchObject\")(TargetId);","if (!Obj || !TargetObj) {","    console.warn(\"3D Object not found: \" + Id + \" or \" + TargetId);","    return;","}","//","const BoundingBoxCollisionResult = gdjs.__WithThreeJS.get(\"SetBoundingBoxCollisionResult\")(Obj, TargetObj);","const Move3 = new THREE.Vector3(BoundingBoxCollisionResult.MoveX, BoundingBoxCollisionResult.MoveY, BoundingBoxCollisionResult.MoveZ);","if (Unmoved) {","    const WorldPosition = new THREE.Vector3();","    Obj.getWorldPosition(WorldPosition);","    WorldPosition.add(Move3);","    Obj.position.copy(Obj.parent.worldToLocal(WorldPosition));","} else {","    Move3.divideScalar(2);","    const Move3Neg = Move3.clone().negate();","    //","    const WorldPosition1 = new THREE.Vector3();","    const WorldPosition2 = new THREE.Vector3();","    Obj.getWorldPosition(WorldPosition1);","    TargetObj.getWorldPosition(WorldPosition2);","    WorldPosition1.add(Move3);","    WorldPosition2.add(Move3Neg);","    Obj.position.copy(Obj.parent.worldToLocal(WorldPosition1));","    TargetObj.position.copy(TargetObj.parent.worldToLocal(WorldPosition2));","}","",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"parameters":[{"description":"3D Object ID","name":"Id","supplementaryInformation":"scene3D Object ID","type":"identifier"},{"description":"Target 3D Object ID","name":"TargetId","supplementaryInformation":"scene3D Object ID","type":"identifier"},{"defaultValue":"True","description":"Target 3D Object is unmoved","name":"Unmoved","optional":true,"type":"trueorfalse"}],"objectGroups":[]},{"description":"Add 3D Object as child to 3D object.","fullName":"Add Child","functionType":"Action","group":"3D Object","name":"AddChild","sentence":"Add Child (ID: _PARAM1_, Child: _PARAM2_)","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["if (!gdjs.__WithThreeJS.has(\"Renderer\")) {","    console.warn(\"!\");","    return;","}","const Scene = gdjs.__WithThreeJS.get(\"Scene\");","const ParentId = eventsFunctionContext.getArgument(\"ParentId\");","const ChildId = eventsFunctionContext.getArgument(\"ChildId\");","//","const Parent = gdjs.__WithThreeJS.get(\"SearchObject\")(ParentId);","const Child = gdjs.__WithThreeJS.get(\"SearchObject\")(ChildId);","if (!Parent || !Child) {","    console.warn(\"3D Object not found: \" + ParentId + \" or \" + ChildId);","    return;","}","Parent.attach(Child);","",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"parameters":[{"description":"Parent 3D Object ID","name":"ParentId","supplementaryInformation":"scene3D Object ID","type":"identifier"},{"description":"Child 3D Object ID","name":"ChildId","supplementaryInformation":"scene3D Object ID","type":"identifier"}],"objectGroups":[]},{"description":"Detach a 3D Object from its parent.\n(Set Parent to Scene)","fullName":"Detach From Parent","functionType":"Action","group":"3D Object","name":"DetachFromParent","sentence":"Detach From Parent (ID: _PARAM1_)","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["if (!gdjs.__WithThreeJS.has(\"Renderer\")) {","    console.warn(\"!\");","    return;","}","const Scene = gdjs.__WithThreeJS.get(\"Scene\");","const Id = eventsFunctionContext.getArgument(\"Id\");","//","const Obj = gdjs.__WithThreeJS.get(\"SearchObject\")(Id);","if (!Obj) {","    console.warn(\"3D Object not found: \" + Id);","    return;","}","Scene.attach(Obj);","",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"parameters":[{"description":"3D Object ID","name":"Id","supplementaryInformation":"scene3D Object ID","type":"identifier"}],"objectGroups":[]},{"description":"Set 3D Object ID of all children to scene variable as array.","fullName":"Set 3D Object ID Of Children To Scene Variable (Deprecated)","functionType":"Action","group":"3D Object","name":"SetChildrenIdToSceneVariable","sentence":"Set 3D Object ID Of Children To Scene Variable (ID: _PARAM1_, Variable: _PARAM2_)","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["if (!gdjs.__WithThreeJS.has(\"Renderer\")) {","    console.warn(\"!\");","    return;","}","const Scene = gdjs.__WithThreeJS.get(\"Scene\");","const Id = eventsFunctionContext.getArgument(\"Id\");","const SceneVariable = eventsFunctionContext.getArgument(\"Variable\");","//","const Obj = gdjs.__WithThreeJS.get(\"SearchObject\")(Id);","if (!Obj) {","    console.warn(\"3D Object not found: \" + Id);","    return;","}","//","let Children = [];","for (const V of Obj.children) {","    Children.push(V.name);","}","SceneVariable.fromJSObject(Children);","",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"parameters":[{"description":"Parent 3D Object ID","name":"Id","supplementaryInformation":"scene3D Object ID","type":"identifier"},{"description":"Scene Variable","name":"Variable","type":"scenevar"}],"objectGroups":[]},{"description":"Set 3D Object ID of all children to variable (Global, Scene or Local) as array.","fullName":"Set 3D Object ID Of Children To Variable","functionType":"Action","group":"3D Object","name":"SetChildrenIdToVariable","sentence":"Set 3D Object ID Of Children To Variable (ID: _PARAM1_, Variable: _PARAM2_)","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["if (!gdjs.__WithThreeJS.has(\"Renderer\")) {","    console.warn(\"!\");","    return;","}","const Scene = gdjs.__WithThreeJS.get(\"Scene\");","const Id = eventsFunctionContext.getArgument(\"Id\");","const GeneralVariable = eventsFunctionContext.getArgument(\"Variable\");","//","const Obj = gdjs.__WithThreeJS.get(\"SearchObject\")(Id);","if (!Obj) {","    console.warn(\"3D Object not found: \" + Id);","    return;","}","//","let Children = [];","for (const V of Obj.children) {","    Children.push(V.name);","}","GeneralVariable.fromJSObject(Children);","",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"parameters":[{"description":"Parent 3D Object ID","name":"Id","supplementaryInformation":"scene3D Object ID","type":"identifier"},{"description":"Variable","name":"Variable","type":"variable"}],"objectGroups":[]},{"description":"Play 3D animation.\nIf already playing, only the \"Animation Speed Scale\" and \"Loop\" properties are updated.","fullName":"Play 3D Animation","functionType":"Action","group":"3D Object","name":"Play3DAnimation","sentence":"Play 3D Animation (ID: _PARAM1_, Animation: _PARAM2_, Speed: _PARAM3_, Loop: _PARAM4_, Fade: _PARAM5_)","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["if (!gdjs.__WithThreeJS.has(\"Renderer\")) {","    console.warn(\"!\");","    return;","}","const Scene = gdjs.__WithThreeJS.get(\"Scene\");","const AnimationMixer = gdjs.__WithThreeJS.get(\"AnimationMixer\");","const AnimationActions = gdjs.__WithThreeJS.get(\"AnimationActions\");","const Id = eventsFunctionContext.getArgument(\"Id\");","const ANumber = eventsFunctionContext.getArgument(\"ANumber\");","const Speed = eventsFunctionContext.getArgument(\"Speed\");","const Duration = eventsFunctionContext.getArgument(\"Duration\");","let Loop = eventsFunctionContext.getArgument(\"Loop\");","if (Loop == \"Once\") {","    Loop = THREE.LoopOnce;","} else if (Loop == \"PingPong\") {","    Loop = THREE.LoopPingPong;","} else {","    Loop = THREE.LoopRepeat;","}","//","const Obj = gdjs.__WithThreeJS.get(\"SearchObject\")(Id);","if (!Obj) {","    console.warn(\"3D Object not found: \" + Id);","    return;","}","const Clip = Obj.animations[ANumber];","if (!Clip) {","    console.warn(\"3D Animation not found: \" + ANumber);","    return;","}","//","let Action;","const OBJ_UUID = Obj.uuid;","const Clip_UUID = Clip.uuid;","if (AnimationActions.has(OBJ_UUID)) {","    if (AnimationActions.get(OBJ_UUID).has(Clip_UUID)) {","        Action = AnimationActions.get(OBJ_UUID).get(Clip_UUID);","        if (Action.isRunning()) {","            Action.timeScale = Speed;","            Action.setLoop(Loop, Infinity);","            return;","        }","    }","}","//","if (AnimationActions.has(OBJ_UUID)) {","    for (const [K, V] of AnimationActions.get(OBJ_UUID)) {","        if (K != Clip_UUID) {","            if (Duration === 0) {","                V.stop();","            } else {","                V.fadeOut(Duration);  ","            }","        }","    }","} else {","    AnimationActions.set(OBJ_UUID, new Map());","}","if (Action === undefined) {","    Action = AnimationMixer.clipAction(Clip, Obj);","    AnimationActions.get(OBJ_UUID).set(Clip_UUID, Action);","}","Action.timeScale = Speed;","Action.setLoop(Loop, Infinity);","Action.clampWhenFinished = true;","if (Speed >= 0) {","    Action.reset().play().fadeIn(Duration);","} else {","    Action.reset();","    Action.time = Clip.duration;","    Action.play().fadeIn(Duration);","}","",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"parameters":[{"description":"3D Object ID","name":"Id","supplementaryInformation":"scene3D Object ID","type":"identifier"},{"description":"Original Animation Number","name":"ANumber","type":"expression"},{"description":"Animation Speed Scale (Default: 1)","longDescription":"0 is pause. Negative values play backwards.","name":"Speed","type":"expression"},{"description":"Loop","name":"Loop","supplementaryInformation":"[\"Once\",\"Repeat\",\"PingPong\"]","type":"stringWithSelector"},{"description":"Cross-Fade Duration (in seconds)","name":"Duration","type":"expression"}],"objectGroups":[]},{"fullName":"Stop 3D Animation","functionType":"Action","group":"3D Object","name":"Stop3DAnimation","sentence":"Stop 3D Animation (ID: _PARAM1_, Animation: _PARAM2_, Fade: _PARAM3_)","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["if (!gdjs.__WithThreeJS.has(\"Renderer\")) {","    console.warn(\"!\");","    return;","}","const Scene = gdjs.__WithThreeJS.get(\"Scene\");","const AnimationActions = gdjs.__WithThreeJS.get(\"AnimationActions\");","const Id = eventsFunctionContext.getArgument(\"Id\");","const ANumber = eventsFunctionContext.getArgument(\"ANumber\");","const Duration = eventsFunctionContext.getArgument(\"Duration\");","//","const Obj = gdjs.__WithThreeJS.get(\"SearchObject\")(Id);","if (!Obj) {","    console.warn(\"3D Object not found: \" + Id);","    return;","}","const Clip = Obj.animations[ANumber];","if (!Clip) {","    console.warn(\"3D Animation not found: \" + ANumber);","    return;","}","//","let Action;","const OBJ_UUID = Obj.uuid;","const Clip_UUID = Clip.uuid;","if (AnimationActions.has(OBJ_UUID)) {","    if (AnimationActions.get(OBJ_UUID).has(Clip_UUID)) {","        const Action = AnimationActions.get(OBJ_UUID).get(Clip_UUID);","        if (Duration === 0) {","            Action.stop();","        } else {","            Action.fadeOut(Duration);  ","        }","    }","}","",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"parameters":[{"description":"3D Object ID","name":"Id","supplementaryInformation":"scene3D Object ID","type":"identifier"},{"description":"Original Animation Number","name":"ANumber","type":"expression"},{"description":"Cross-Fade Duration (in seconds)","name":"Duration","type":"expression"}],"objectGroups":[]},{"fullName":"Set number to 3D Object Variable","functionType":"Action","group":"3D Object","name":"SetNumberVariable","sentence":"Set number to 3D Object Variable (ID: _PARAM1_, Variable: _PARAM2_, _PARAM3_, _PARAM4_)","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["if (!gdjs.__WithThreeJS.has(\"Renderer\")) {","    console.warn(\"!\");","    return;","}","const Scene = gdjs.__WithThreeJS.get(\"Scene\");","const Id = eventsFunctionContext.getArgument(\"Id\");","const VariableName = eventsFunctionContext.getArgument(\"VariableName\");","const Operator = eventsFunctionContext.getArgument(\"Operator\");","const Value = eventsFunctionContext.getArgument(\"Value\");","//","const Obj = gdjs.__WithThreeJS.get(\"SearchObject\")(Id);","if (!Obj) {","    console.warn(\"3D Object not found: \" + Id);","    return;","}","//","if (!Obj.userData.Variable) {","    Obj.userData.Variable = {};","}","if (!Obj.userData.Variable[VariableName]) {","    // false, 0, \"\", undefined ...","    Obj.userData.Variable[VariableName] = 0;","}","if (Operator == \"=\") {","    Obj.userData.Variable[VariableName] = Value;","} else if (Operator == \"+\") {","    Obj.userData.Variable[VariableName] += Value;","} else if (Operator == \"-\") {","    Obj.userData.Variable[VariableName] -= Value;","} else {","    Obj.userData.Variable[VariableName] *= Value;","}","",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"parameters":[{"description":"3D Object ID","name":"Id","supplementaryInformation":"scene3D Object ID","type":"identifier"},{"description":"3D Object Variable Name","name":"VariableName","supplementaryInformation":"scene3D Object Variable Name","type":"identifier"},{"description":"Operator","name":"Operator","supplementaryInformation":"[\"=\",\"+\",\"-\",\"*\"]","type":"stringWithSelector"},{"description":"Value","name":"Value","type":"expression"}],"objectGroups":[]},{"fullName":"Set string to 3D Object Variable","functionType":"Action","group":"3D Object","name":"SetStringVariable","sentence":"Set string to 3D Object Variable (ID: _PARAM1_, Variable: _PARAM2_, _PARAM3_, _PARAM4_)","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["if (!gdjs.__WithThreeJS.has(\"Renderer\")) {","    console.warn(\"!\");","    return;","}","const Scene = gdjs.__WithThreeJS.get(\"Scene\");","const Id = eventsFunctionContext.getArgument(\"Id\");","const VariableName = eventsFunctionContext.getArgument(\"VariableName\");","const Operator = eventsFunctionContext.getArgument(\"Operator\");","const Value = eventsFunctionContext.getArgument(\"Value\");","//","const Obj = gdjs.__WithThreeJS.get(\"SearchObject\")(Id);","if (!Obj) {","    console.warn(\"3D Object not found: \" + Id);","    return;","}","//","if (!Obj.userData.Variable) {","    Obj.userData.Variable = {};","}","if (!Obj.userData.Variable[VariableName]) {","    // false, 0, \"\", undefined ...","    Obj.userData.Variable[VariableName] = \"\";","}","if (Operator == \"=\") {","    Obj.userData.Variable[VariableName] = Value;","} else {","    Obj.userData.Variable[VariableName] += Value;","}","",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"parameters":[{"description":"3D Object ID","name":"Id","supplementaryInformation":"scene3D Object ID","type":"identifier"},{"description":"3D Object Variable Name","name":"VariableName","supplementaryInformation":"scene3D Object Variable Name","type":"identifier"},{"description":"Operator","name":"Operator","supplementaryInformation":"[\"=\",\"+\"]","type":"stringWithSelector"},{"description":"Value","name":"Value","type":"string"}],"objectGroups":[]},{"fullName":"Linearly interpolate 3D Object","functionType":"Action","group":"3D Object","name":"Lerp3DObject","sentence":"Linearly Interpolate 3D Object (ID: _PARAM1_, Target ID: _PARAM2_, Position: _PARAM3_, Rotation: _PARAM4_)","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["if (!gdjs.__WithThreeJS.has(\"Renderer\")) {","    console.warn(\"!\");","    return;","}","const Scene = gdjs.__WithThreeJS.get(\"Scene\");","const Id = eventsFunctionContext.getArgument(\"Id\");","const TargetId = eventsFunctionContext.getArgument(\"TargetId\");","const FactorP = eventsFunctionContext.getArgument(\"FactorP\");","const FactorR = eventsFunctionContext.getArgument(\"FactorR\");","//","const Obj = gdjs.__WithThreeJS.get(\"SearchObject\")(Id);","const TargetObj = gdjs.__WithThreeJS.get(\"SearchObject\")(TargetId);","if (!Obj || !TargetObj) {","    console.warn(\"3D Object not found: \" + Id + \" or \" + TargetId);","    return;","}","//","const Parent = Obj.parent;","Scene.attach(Obj);","if (FactorP) {","    const WPos = new THREE.Vector3();","    TargetObj.getWorldPosition(WPos);","    Obj.position.lerp(WPos, FactorP);","}","if (FactorR) {","    const WQua = new THREE.Quaternion();","    TargetObj.getWorldQuaternion(WQua);","    Obj.quaternion.slerp(WQua, FactorR);","}","Parent.attach(Obj);","",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"parameters":[{"description":"3D Object ID","name":"Id","supplementaryInformation":"scene3D Object ID","type":"identifier"},{"description":"Target 3D Object ID","name":"TargetId","supplementaryInformation":"scene3D Object ID","type":"identifier"},{"description":"Position interpolation factor (0 to 1)","longDescription":"Disable with 0","name":"FactorP","type":"expression"},{"description":"Rotation interpolation factor (0 to 1)","longDescription":"Disable with 0","name":"FactorR","type":"expression"}],"objectGroups":[]},{"description":"Adds a suffix to the IDs of the specified 3D object and its children.\nNote that if lights or sounds are included as children, their IDs will also change.","fullName":"Add Suffix To 3D Object ID","functionType":"Action","group":"3D Object","name":"AddSuffixToId","sentence":"Add Suffix To 3D Object ID (ID: _PARAM1_, Suffix: _PARAM2_)","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["if (!gdjs.__WithThreeJS.has(\"Renderer\")) {","    console.warn(\"!\");","    return;","}","const Scene = gdjs.__WithThreeJS.get(\"Scene\");","//","const Id = eventsFunctionContext.getArgument(\"Id\");","const Suffix = eventsFunctionContext.getArgument(\"Suffix\");","//","const Obj = gdjs.__WithThreeJS.get(\"SearchObject\")(Id);","if (!Obj) {","    console.warn(\"3D Object not found: \" + Id);","    return;","}","//","Obj.traverse((Child) => {","    // !Obj.isLight && !Obj.isLine && !Obj.isSkinnedMesh && !Obj.isBone","    // Obj.type != \"Audio\"","    if (!Child.isCamera && !Child.isScene && !Child.isBone) {","        if (gdjs.__WithThreeJS.get(\"ObjectList\").has(Child.name)) {","            gdjs.__WithThreeJS.get(\"ObjectList\").delete(Child.name);","        }","        Child.name += Suffix;","    }","});"],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"parameters":[{"description":"3D Object ID","name":"Id","supplementaryInformation":"scene3D Object ID","type":"identifier"},{"description":"Suffix","name":"Suffix","supplementaryInformation":"scene3D Object ID","type":"string"}],"objectGroups":[]},{"description":"If both \"Cast Shadow\" and \"Receive Shadow\" are enabled, striped patterns are likely to occur in the shadow.","fullName":"Set 3D Object Shadow","functionType":"Action","group":"3D Object","name":"Set3DShadow","sentence":"Set 3D Object Shadow (ID: _PARAM1_, Cast: _PARAM2_, Receive: _PARAM3_)","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["if (!gdjs.__WithThreeJS.has(\"Renderer\")) {","    console.warn(\"!\");","    return;","}","const Scene = gdjs.__WithThreeJS.get(\"Scene\");","//","const Id = eventsFunctionContext.getArgument(\"Id\");","const CastShadow = eventsFunctionContext.getArgument(\"CastShadow\");","const ReceiveShadow = eventsFunctionContext.getArgument(\"ReceiveShadow\");","//","const Obj = gdjs.__WithThreeJS.get(\"SearchObject\")(Id);","if (!Obj) {","    console.warn(\"3D Object not found: \" + Id);","    return;","}","//","Obj.traverse((Child) => {","    if (Child.isMesh) {","        Child.castShadow = CastShadow;","        Child.receiveShadow = ReceiveShadow;","    }","});","",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"parameters":[{"description":"3D Object ID","name":"Id","supplementaryInformation":"scene3D Object ID","type":"identifier"},{"description":"Cast Shadow","name":"CastShadow","supplementaryInformation":"scene3D Object ID","type":"yesorno"},{"description":"Receive Shadow","name":"ReceiveShadow","type":"yesorno"}],"objectGroups":[]},{"fullName":"3D Object Position","functionType":"Expression","group":"3D Object","name":"ObjectPosition","sentence":"","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["if (!gdjs.__WithThreeJS.has(\"Renderer\")) {","    console.warn(\"!\");","    return;","}","const Scene = gdjs.__WithThreeJS.get(\"Scene\");","const Id = eventsFunctionContext.getArgument(\"Id\");","const Axis = eventsFunctionContext.getArgument(\"Axis\");","//","const Obj = gdjs.__WithThreeJS.get(\"SearchObject\")(Id);","if (!Obj) {","    console.warn(\"3D Object not found: \" + Id);","    return;","}","//","if (Axis == \"X\") {","    eventsFunctionContext.returnValue = Obj.position.x;","} else if (Axis == \"Y\") {","    eventsFunctionContext.returnValue = Obj.position.y;","} else {","    eventsFunctionContext.returnValue = Obj.position.z;","}","",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"expressionType":{"type":"expression"},"parameters":[{"description":"3D Object ID","name":"Id","supplementaryInformation":"scene3D Object ID","type":"identifier"},{"description":"Axis","name":"Axis","supplementaryInformation":"[\"X\",\"Y\",\"Z\"]","type":"stringWithSelector"}],"objectGroups":[]},{"fullName":"3D Object Position On World","functionType":"Expression","group":"3D Object","name":"ObjectPositionOnWorld","sentence":"","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["if (!gdjs.__WithThreeJS.has(\"Renderer\")) {","    console.warn(\"!\");","    return;","}","const Scene = gdjs.__WithThreeJS.get(\"Scene\");","const Id = eventsFunctionContext.getArgument(\"Id\");","const Axis = eventsFunctionContext.getArgument(\"Axis\");","//","const Obj = gdjs.__WithThreeJS.get(\"SearchObject\")(Id);","if (!Obj) {","    console.warn(\"3D Object not found: \" + Id);","    return;","}","//","const WorldPosition = new THREE.Vector3();","Obj.getWorldPosition(WorldPosition);","if (Axis == \"X\") {","    eventsFunctionContext.returnValue = WorldPosition.x;","} else if (Axis == \"Y\") {","    eventsFunctionContext.returnValue = WorldPosition.y;","} else {","    eventsFunctionContext.returnValue = WorldPosition.z;","}","",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"expressionType":{"type":"expression"},"parameters":[{"description":"3D Object ID","name":"Id","supplementaryInformation":"scene3D Object ID","type":"identifier"},{"description":"Axis","name":"Axis","supplementaryInformation":"[\"X\",\"Y\",\"Z\"]","type":"stringWithSelector"}],"objectGroups":[]},{"fullName":"3D Object Rotation","functionType":"Expression","group":"3D Object","name":"ObjectRotation","sentence":"","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["if (!gdjs.__WithThreeJS.has(\"Renderer\")) {","    console.warn(\"!\");","    return;","}","const Scene = gdjs.__WithThreeJS.get(\"Scene\");","const Id = eventsFunctionContext.getArgument(\"Id\");","const Axis = eventsFunctionContext.getArgument(\"Axis\");","//","const Obj = gdjs.__WithThreeJS.get(\"SearchObject\")(Id);","if (!Obj) {","    console.warn(\"3D Object not found: \" + Id);","    return;","}","//","if (Axis == \"X\") {","    eventsFunctionContext.returnValue = gdjs.toDegrees(Obj.rotation.x);","} else if (Axis == \"Y\") {","    eventsFunctionContext.returnValue = gdjs.toDegrees(Obj.rotation.y);","} else {","    eventsFunctionContext.returnValue = gdjs.toDegrees(Obj.rotation.z);","}","",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"expressionType":{"type":"expression"},"parameters":[{"description":"3D Object ID","name":"Id","supplementaryInformation":"scene3D Object ID","type":"identifier"},{"description":"Axis","name":"Axis","supplementaryInformation":"[\"X\",\"Y\",\"Z\"]","type":"stringWithSelector"}],"objectGroups":[]},{"fullName":"3D Object Rotation On World","functionType":"Expression","group":"3D Object","name":"ObjectRotationOnWorld","sentence":"","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["if (!gdjs.__WithThreeJS.has(\"Renderer\")) {","    console.warn(\"!\");","    return;","}","const Scene = gdjs.__WithThreeJS.get(\"Scene\");","const Id = eventsFunctionContext.getArgument(\"Id\");","const Axis = eventsFunctionContext.getArgument(\"Axis\");","//","const Obj = gdjs.__WithThreeJS.get(\"SearchObject\")(Id);","if (!Obj) {","    console.warn(\"3D Object not found: \" + Id);","    return;","}","//","const WorldQuaternion = new THREE.Quaternion();","Obj.getWorldQuaternion(WorldQuaternion);","const Euler = new THREE.Euler();","Euler.setFromQuaternion(WorldQuaternion);","if (Axis == \"X\") {","    eventsFunctionContext.returnValue = gdjs.toDegrees(Euler.x);","} else if (Axis == \"Y\") {","    eventsFunctionContext.returnValue = gdjs.toDegrees(Euler.y);","} else {","    eventsFunctionContext.returnValue = gdjs.toDegrees(Euler.z);","}","",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"expressionType":{"type":"expression"},"parameters":[{"description":"3D Object ID","name":"Id","supplementaryInformation":"scene3D Object ID","type":"identifier"},{"description":"Axis","name":"Axis","supplementaryInformation":"[\"X\",\"Y\",\"Z\"]","type":"stringWithSelector"}],"objectGroups":[]},{"description":"Normalized direction vector of 3D Object.\n(Z axis direction)","fullName":"3D Object Direction","functionType":"Expression","group":"3D Object","name":"ObjectDirection","sentence":"","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["if (!gdjs.__WithThreeJS.has(\"Renderer\")) {","    console.warn(\"!\");","    return;","}","const Scene = gdjs.__WithThreeJS.get(\"Scene\");","const Id = eventsFunctionContext.getArgument(\"Id\");","const Axis = eventsFunctionContext.getArgument(\"Axis\");","//","const Obj = gdjs.__WithThreeJS.get(\"SearchObject\")(Id);","if (!Obj) {","    console.warn(\"3D Object not found: \" + Id);","    return;","}","//","const WorldDirection = new THREE.Vector3();","Obj.getWorldDirection(WorldDirection);","//","if (Axis == \"X\") {","    eventsFunctionContext.returnValue = WorldDirection.x;","} else if (Axis == \"Y\") {","    eventsFunctionContext.returnValue = WorldDirection.y;","} else {","    eventsFunctionContext.returnValue = WorldDirection.z;","}","",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"expressionType":{"type":"expression"},"parameters":[{"description":"3D Object ID","name":"Id","supplementaryInformation":"scene3D Object ID","type":"identifier"},{"description":"Axis","name":"Axis","supplementaryInformation":"[\"X\",\"Y\",\"Z\"]","type":"stringWithSelector"}],"objectGroups":[]},{"description":"Returns the opacity of the 3D Object, or the first opacity found among its children.","fullName":"3D Object Opacity","functionType":"Expression","group":"3D Object","name":"ObjectOpacity","sentence":"","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["if (!gdjs.__WithThreeJS.has(\"Renderer\")) {","    console.warn(\"!\");","    return;","}","const Scene = gdjs.__WithThreeJS.get(\"Scene\");","const Id = eventsFunctionContext.getArgument(\"Id\");","let Opacity = null;","//","const Obj = gdjs.__WithThreeJS.get(\"SearchObject\")(Id);","if (!Obj) {","    console.warn(\"3D Object not found: \" + Id);","    return;","}","//","Obj.traverse((Child) => {","    if (Opacity === null) {","        if (Child.material) {","            if (Array.isArray(Child.material)) {","                Opacity = Child.material[0].opacity;","            } else {","                Opacity = Child.material.opacity;","            }","        }","    }","});","eventsFunctionContext.returnValue = (Opacity === null)? 1 : Opacity;","",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"expressionType":{"type":"expression"},"parameters":[{"description":"3D Object ID","name":"Id","supplementaryInformation":"scene3D Object ID","type":"identifier"}],"objectGroups":[]},{"fullName":"3D Object Scale","functionType":"Expression","group":"3D Object","name":"ObjectScale","sentence":"","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["if (!gdjs.__WithThreeJS.has(\"Renderer\")) {","    console.warn(\"!\");","    return;","}","const Scene = gdjs.__WithThreeJS.get(\"Scene\");","const Id = eventsFunctionContext.getArgument(\"Id\");","const Axis = eventsFunctionContext.getArgument(\"Axis\");","//","const Obj = gdjs.__WithThreeJS.get(\"SearchObject\")(Id);","if (!Obj) {","    console.warn(\"3D Object not found: \" + Id);","    return;","}","//","if (Obj.isSprite) {","    const Texture = Obj.material.map;","    const TextureWidth = Texture.image.width;","    const TextureHeight = Texture.image.height;","    if (Axis == \"Scale X Axis\") {","        eventsFunctionContext.returnValue = Obj.scale.x / TextureWidth;","    } else if (Axis == \"Scale Y Axis\") {","        eventsFunctionContext.returnValue = Obj.scale.y / TextureHeight;","    } else {","        eventsFunctionContext.returnValue = 1;","    }","} else {","    if (Axis == \"Scale X Axis\") {","        eventsFunctionContext.returnValue = Obj.scale.x;","    } else if (Axis == \"Scale Y Axis\") {","        eventsFunctionContext.returnValue = Obj.scale.y;","    } else {","        eventsFunctionContext.returnValue = Obj.scale.z;","    }","}","",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"expressionType":{"type":"expression"},"parameters":[{"description":"3D Object ID","name":"Id","supplementaryInformation":"scene3D Object ID","type":"identifier"},{"description":"Axis","name":"Axis","supplementaryInformation":"[\"Scale X Axis\",\"Scale Y Axis\",\"Scale Z Axis\"]","type":"stringWithSelector"}],"objectGroups":[]},{"fullName":"3D Object Parent","functionType":"StringExpression","group":"3D Object","name":"ObjectParent","sentence":"","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["if (!gdjs.__WithThreeJS.has(\"Renderer\")) {","    console.warn(\"!\");","    return;","}","const Scene = gdjs.__WithThreeJS.get(\"Scene\");","const Id = eventsFunctionContext.getArgument(\"Id\");","//","const Obj = gdjs.__WithThreeJS.get(\"SearchObject\")(Id);","if (!Obj) {","    console.warn(\"3D Object not found: \" + Id);","    return;","}","//","eventsFunctionContext.returnValue = Obj.parent.name;",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"expressionType":{"supplementaryInformation":"scene","type":"string"},"parameters":[{"description":"3D Object ID","name":"Id","supplementaryInformation":"scene3D Object ID","type":"identifier"}],"objectGroups":[]},{"fullName":"3D Object Animation Speed Scale","functionType":"Expression","group":"3D Object","name":"ObjectAnimationSpeedScale","sentence":"","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["if (!gdjs.__WithThreeJS.has(\"Renderer\")) {","    console.warn(\"!\");","    return;","}","const Scene = gdjs.__WithThreeJS.get(\"Scene\");","const AnimationActions = gdjs.__WithThreeJS.get(\"AnimationActions\");","const Id = eventsFunctionContext.getArgument(\"Id\");","const ANumber = eventsFunctionContext.getArgument(\"ANumber\");","//","const Obj = gdjs.__WithThreeJS.get(\"SearchObject\")(Id);","if (!Obj) {","    console.warn(\"3D Object not found: \" + Id);","    return;","}","const Clip = Obj.animations[ANumber];","if (!Clip) {","    return;","}","//","const OBJ_UUID = Obj.uuid;","const Clip_UUID = Clip.uuid;","if (AnimationActions.has(OBJ_UUID)) {","    if (AnimationActions.get(OBJ_UUID).has(Clip_UUID)) {","        const Action = AnimationActions.get(OBJ_UUID).get(Clip_UUID);","        eventsFunctionContext.returnValue = Action.timeScale;","    }","}","",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"expressionType":{"supplementaryInformation":"scene","type":"expression"},"parameters":[{"description":"3D Object ID","name":"Id","supplementaryInformation":"scene3D Object ID","type":"identifier"},{"description":"Original Animation Number","name":"ANumber","type":"expression"}],"objectGroups":[]},{"fullName":"3D Object Animation Time","functionType":"Expression","group":"3D Object","name":"ObjectAnimationTime","sentence":"","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["if (!gdjs.__WithThreeJS.has(\"Renderer\")) {","    console.warn(\"!\");","    return;","}","const Scene = gdjs.__WithThreeJS.get(\"Scene\");","const AnimationActions = gdjs.__WithThreeJS.get(\"AnimationActions\");","const Id = eventsFunctionContext.getArgument(\"Id\");","const ANumber = eventsFunctionContext.getArgument(\"ANumber\");","//","const Obj = gdjs.__WithThreeJS.get(\"SearchObject\")(Id);","if (!Obj) {","    console.warn(\"3D Object not found: \" + Id);","    return;","}","const Clip = Obj.animations[ANumber];","if (!Clip) {","    return;","}","//","const OBJ_UUID = Obj.uuid;","const Clip_UUID = Clip.uuid;","if (AnimationActions.has(OBJ_UUID)) {","    if (AnimationActions.get(OBJ_UUID).has(Clip_UUID)) {","        const Action = AnimationActions.get(OBJ_UUID).get(Clip_UUID);","        eventsFunctionContext.returnValue = Action.time;","    }","}","",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"expressionType":{"supplementaryInformation":"scene","type":"expression"},"parameters":[{"description":"3D Object ID","name":"Id","supplementaryInformation":"scene3D Object ID","type":"identifier"},{"description":"Original Animation Number","name":"ANumber","type":"expression"}],"objectGroups":[]},{"fullName":"3D Object Animation Duration","functionType":"Expression","group":"3D Object","name":"ObjectAnimationDuration","sentence":"","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["if (!gdjs.__WithThreeJS.has(\"Renderer\")) {","    console.warn(\"!\");","    return;","}","const Scene = gdjs.__WithThreeJS.get(\"Scene\");","const AnimationActions = gdjs.__WithThreeJS.get(\"AnimationActions\");","const Id = eventsFunctionContext.getArgument(\"Id\");","const ANumber = eventsFunctionContext.getArgument(\"ANumber\");","//","const Obj = gdjs.__WithThreeJS.get(\"SearchObject\")(Id);","if (!Obj) {","    console.warn(\"3D Object not found: \" + Id);","    return;","}","const Clip = Obj.animations[ANumber];","if (!Clip) {","    return;","}","eventsFunctionContext.returnValue = Clip.duration;","",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"expressionType":{"supplementaryInformation":"scene","type":"expression"},"parameters":[{"description":"3D Object ID","name":"Id","supplementaryInformation":"scene3D Object ID","type":"identifier"},{"description":"Original Animation Number","name":"ANumber","type":"expression"}],"objectGroups":[]},{"fullName":"3D Object Number Variable","functionType":"Expression","group":"3D Object","name":"ObjectNumberVariable","sentence":"","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["if (!gdjs.__WithThreeJS.has(\"Renderer\")) {","    console.warn(\"!\");","    return;","}","const Scene = gdjs.__WithThreeJS.get(\"Scene\");","const Id = eventsFunctionContext.getArgument(\"Id\");","const VariableName = eventsFunctionContext.getArgument(\"VariableName\");","//","const Obj = gdjs.__WithThreeJS.get(\"SearchObject\")(Id);","if (!Obj) {","    console.warn(\"3D Object not found: \" + Id);","    return;","}","//","if (!Obj.userData.Variable) {","    Obj.userData.Variable = {};","}","if (!Obj.userData.Variable[VariableName]) {","    // false, 0, \"\", undefined ...","    Obj.userData.Variable[VariableName] = 0;","}","eventsFunctionContext.returnValue = Obj.userData.Variable[VariableName];","",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"expressionType":{"supplementaryInformation":"scene","type":"expression"},"parameters":[{"description":"3D Object ID","name":"Id","supplementaryInformation":"scene3D Object ID","type":"identifier"},{"description":"3D Object Variable Name","name":"VariableName","supplementaryInformation":"scene3D Object Variable Name","type":"identifier"}],"objectGroups":[]},{"fullName":"3D Object String Variable","functionType":"StringExpression","group":"3D Object","name":"ObjectStringVariable","sentence":"","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["if (!gdjs.__WithThreeJS.has(\"Renderer\")) {","    console.warn(\"!\");","    return;","}","const Scene = gdjs.__WithThreeJS.get(\"Scene\");","const Id = eventsFunctionContext.getArgument(\"Id\");","const VariableName = eventsFunctionContext.getArgument(\"VariableName\");","//","const Obj = gdjs.__WithThreeJS.get(\"SearchObject\")(Id);","if (!Obj) {","    console.warn(\"3D Object not found: \" + Id);","    return;","}","//","if (!Obj.userData.Variable) {","    Obj.userData.Variable = {};","}","if (!Obj.userData.Variable[VariableName]) {","    // false, 0, \"\", undefined ...","    Obj.userData.Variable[VariableName] = \"\";","}","eventsFunctionContext.returnValue = Obj.userData.Variable[VariableName];","",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"expressionType":{"supplementaryInformation":"scene","type":"string"},"parameters":[{"description":"3D Object ID","name":"Id","supplementaryInformation":"scene3D Object ID","type":"identifier"},{"description":"3D Object Variable Name","name":"VariableName","supplementaryInformation":"scene3D Object Variable Name","type":"identifier"}],"objectGroups":[]},{"fullName":"Distance From 3D Object To 3D Object","functionType":"Expression","group":"3D Object","name":"DistanceFrom3DObjectTo3DObject","sentence":"","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["if (!gdjs.__WithThreeJS.has(\"Renderer\")) {","    console.warn(\"!\");","    return;","}","const Scene = gdjs.__WithThreeJS.get(\"Scene\");","const Id1 = eventsFunctionContext.getArgument(\"Id1\");","const Id2 = eventsFunctionContext.getArgument(\"Id2\");","//","const Obj1 = gdjs.__WithThreeJS.get(\"SearchObject\")(Id1);","const Obj2 = gdjs.__WithThreeJS.get(\"SearchObject\")(Id2);","if (!Obj1 || !Obj2) {","    console.warn(\"3D Object not found: \" + Id1 + \" or \" + Id2);","    return;","}","//","const WPos1 = new THREE.Vector3();","const WPos2 = new THREE.Vector3();","Obj1.getWorldPosition(WPos1);","Obj2.getWorldPosition(WPos2);","eventsFunctionContext.returnValue = WPos1.distanceTo(WPos2);","",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"expressionType":{"type":"expression"},"parameters":[{"description":"From 3D Object ID","name":"Id1","supplementaryInformation":"scene3D Object ID","type":"identifier"},{"description":"To 3D Object ID","name":"Id2","supplementaryInformation":"scene3D Object ID","type":"identifier"}],"objectGroups":[]},{"fullName":"Bounding Box Collision Result Number","functionType":"Expression","group":"3D Object","name":"BoundingBoxCollisionResultNumber","sentence":"Raycast (From: _PARAM1_, _PARAM2_, _PARAM3_, To: _PARAM4_, _PARAM5_, _PARAM6_)","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["if (!gdjs.__WithThreeJS.has(\"Renderer\")) {","    console.warn(\"!\");","    return;","}","if (!gdjs.__WithThreeJS.has(\"BoundingBoxCollisionResult\")) {","    gdjs.__WithThreeJS.set(\"BoundingBoxCollisionResult\", {Hit:false, CenterX:0, CenterY:0, CenterZ:0, SizeX:0, SizeY:0, SizeZ:0, MoveX:0, MoveY:0, MoveZ:0});","}","const BoundingBoxCollisionResult = gdjs.__WithThreeJS.get(\"BoundingBoxCollisionResult\");","const Item = eventsFunctionContext.getArgument(\"Item\");","//","if (Item == \"Center X\") {","    eventsFunctionContext.returnValue = BoundingBoxCollisionResult.CenterX;","} else if (Item == \"Center Y\") {","    eventsFunctionContext.returnValue = BoundingBoxCollisionResult.CenterY;","} else if (Item == \"Center Z\") {","    eventsFunctionContext.returnValue = BoundingBoxCollisionResult.CenterZ;","} else if (Item == \"Size X\") {","    eventsFunctionContext.returnValue = BoundingBoxCollisionResult.SizeX;","} else if (Item == \"Size Y\") {","    eventsFunctionContext.returnValue = BoundingBoxCollisionResult.SizeY;","} else if (Item == \"Size Z\") {","    eventsFunctionContext.returnValue = BoundingBoxCollisionResult.SizeZ;","} else if (Item == \"Move X\") {","    eventsFunctionContext.returnValue = BoundingBoxCollisionResult.MoveX;","} else if (Item == \"Move Y\") {","    eventsFunctionContext.returnValue = BoundingBoxCollisionResult.MoveY;","} else if (Item == \"Move Z\") {","    eventsFunctionContext.returnValue = BoundingBoxCollisionResult.MoveZ;","}","",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"expressionType":{"type":"expression"},"parameters":[{"description":"Item","name":"Item","supplementaryInformation":"[\"Center X\",\"Center Y\",\"Center Z\",\"Size X\",\"Size Y\",\"Size Z\",\"Move X\",\"Move Y\",\"Move Z\"]","type":"stringWithSelector"}],"objectGroups":[]},{"fullName":"Check Existence Of 3D Object","functionType":"Condition","group":"3D Object","name":"CheckExistenceOf3DObject","sentence":"Check Existence Of 3D Object (ID: _PARAM1_)","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["if (!gdjs.__WithThreeJS.has(\"Renderer\")) {","    console.warn(\"!\");","    return;","}","const Scene = gdjs.__WithThreeJS.get(\"Scene\");","const Id = eventsFunctionContext.getArgument(\"Id\");","//","const Obj = gdjs.__WithThreeJS.get(\"SearchObject\")(Id);","if (Obj && Id !== \"\") {","    eventsFunctionContext.returnValue = true;","} else {","    eventsFunctionContext.returnValue = false;","}","",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"parameters":[{"description":"3D Object ID","name":"Id","supplementaryInformation":"scene3D Object ID","type":"identifier"}],"objectGroups":[]},{"description":"Check the visibility of a 3D Object.\nThis condition cannot be tested correctly if the visibility of the 3D object is changed by inheritance.","fullName":"Check Visibility Of 3D Object","functionType":"Condition","group":"3D Object","name":"CheckVisibilityOf3DObject","sentence":"Check Visibility Of 3D Object (ID: _PARAM1_, Visible: _PARAM2_)","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["if (!gdjs.__WithThreeJS.has(\"Renderer\")) {","    console.warn(\"!\");","    return;","}","const Scene = gdjs.__WithThreeJS.get(\"Scene\");","const Id = eventsFunctionContext.getArgument(\"Id\");","const Visible = eventsFunctionContext.getArgument(\"Visible\");","//","const Obj = gdjs.__WithThreeJS.get(\"SearchObject\")(Id);","if (!Obj) {","    console.warn(\"3D Object not found: \" + Id);","    return;","}","//","let VisibilityResult = Obj.visible;","if (VisibilityResult) {","    if (Obj.material) {","        if (Array.isArray(Obj.material)) {","            VisibilityResult = Obj.material.every((x) => x.visible === true);","        } else {","            VisibilityResult = Obj.material.visible;","        }","    }","}","eventsFunctionContext.returnValue = VisibilityResult === Visible;","",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"parameters":[{"description":"3D Object ID","name":"Id","supplementaryInformation":"scene3D Object ID","type":"identifier"},{"defaultValue":"yes","description":"Check if the visible is","name":"Visible","optional":true,"type":"yesorno"}],"objectGroups":[]},{"description":"Checks for collisions between the Bounding Boxes of two 3D Objects.\nThis condition updates the \"Bounding Box Collision Result\" when it returns True.","fullName":"Check Bounding Box Collision","functionType":"Condition","group":"3D Object","name":"CheckBoundingBoxCollision","sentence":"Check Bounding Box Collision (ID: _PARAM1_, Unmoved: _PARAM2_)","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["if (!gdjs.__WithThreeJS.has(\"Renderer\")) {","    console.warn(\"!\");","    return;","}","const Scene = gdjs.__WithThreeJS.get(\"Scene\");","const Id = eventsFunctionContext.getArgument(\"Id\");","const UnmovedId = eventsFunctionContext.getArgument(\"UnmovedId\");","//","const Obj = gdjs.__WithThreeJS.get(\"SearchObject\")(Id);","const UnmovedObj = gdjs.__WithThreeJS.get(\"SearchObject\")(UnmovedId);","if (!Obj || !UnmovedObj) {","    console.warn(\"3D Object not found: \" + Id + \" or \" + UnmovedId);","    return;","}","//","const BoundingBoxCollisionResult = gdjs.__WithThreeJS.get(\"SetBoundingBoxCollisionResult\")(Obj, UnmovedObj);","eventsFunctionContext.returnValue = BoundingBoxCollisionResult.Hit;","",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"parameters":[{"description":"3D Object ID","name":"Id","supplementaryInformation":"scene3D Object ID","type":"identifier"},{"description":"Unmoved 3D Object ID","name":"UnmovedId","supplementaryInformation":"scene3D Object ID","type":"identifier"}],"objectGroups":[]},{"description":"Checks for collisions between the Oriented Bounding Boxes of two 3D Objects.\nOBB cannot resolve collisions between OBBs or get collision results.","fullName":"Check Oriented Bounding Box Collision","functionType":"Condition","group":"3D Object","name":"CheckOrientedBoxCollision","sentence":"Check Oriented Bounding Box Collision (ID: _PARAM1_, _PARAM2_)","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["if (!gdjs.__WithThreeJS.has(\"Renderer\")) {","    console.warn(\"!\");","    return;","}","const Scene = gdjs.__WithThreeJS.get(\"Scene\");","const Id = eventsFunctionContext.getArgument(\"Id\");","const OtherId = eventsFunctionContext.getArgument(\"OtherId\");","//","const Obj = gdjs.__WithThreeJS.get(\"SearchObject\")(Id);","const OtherObj = gdjs.__WithThreeJS.get(\"SearchObject\")(OtherId);","if (!Obj || !OtherObj) {","    console.warn(\"3D Object not found: \" + Id + \" or \" + OtherId);","    return;","}","// geometrySpritegeometry","const Geo1 = Obj.geometry;","const Geo2 = OtherObj.geometry;","if (!Geo1 || !Geo2) {","    console.warn(\"Geometry not found: \" + Id + \" or \" + OtherId);","    return;","}","//","const OBB1 = new THREE.OBB().fromBox3(Geo1.boundingBox);","const OBB2 = new THREE.OBB().fromBox3(Geo2.boundingBox);","Obj.updateMatrixWorld(false);//?","OtherObj.updateMatrixWorld(false);//?","OBB1.applyMatrix4(Obj.matrixWorld);","OBB2.applyMatrix4(OtherObj.matrixWorld);","eventsFunctionContext.returnValue = OBB1.intersectsOBB(OBB2);","",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"parameters":[{"description":"3D Object ID","name":"Id","supplementaryInformation":"scene3D Object ID","type":"identifier"},{"description":"Other 3D Object ID","name":"OtherId","supplementaryInformation":"scene3D Object ID","type":"identifier"}],"objectGroups":[]},{"description":"Check if the 3D Animation is playing.","fullName":"Check 3D Animation Is Playing","functionType":"Condition","group":"3D Object","name":"Check3DAnimationIsPlaying","sentence":"Check 3D Animation Is Playing (ID: _PARAM1_, Animation: _PARAM2_)","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["if (!gdjs.__WithThreeJS.has(\"Renderer\")) {","    console.warn(\"!\");","    return;","}","const Scene = gdjs.__WithThreeJS.get(\"Scene\");","const AnimationMixer = gdjs.__WithThreeJS.get(\"AnimationMixer\");","const AnimationActions = gdjs.__WithThreeJS.get(\"AnimationActions\");","const Id = eventsFunctionContext.getArgument(\"Id\");","const ANumber = eventsFunctionContext.getArgument(\"ANumber\");","eventsFunctionContext.returnValue = false;","//","const Obj = gdjs.__WithThreeJS.get(\"SearchObject\")(Id);","if (!Obj) {","    console.warn(\"3D Object not found: \" + Id);","    return;","}","const Clip = Obj.animations[ANumber];","if (!Clip) {","    return;","}","//","const OBJ_UUID = Obj.uuid;","const Clip_UUID = Clip.uuid;","if (AnimationActions.has(OBJ_UUID)) {","    if (AnimationActions.get(OBJ_UUID).has(Clip_UUID)) {","        const Action = AnimationActions.get(OBJ_UUID).get(Clip_UUID);","        eventsFunctionContext.returnValue = Action.isRunning();","    }","}","",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"parameters":[{"description":"3D Object ID","name":"Id","supplementaryInformation":"scene3D Object ID","type":"identifier"},{"description":"Original Animation Number","name":"ANumber","supplementaryInformation":"scene3D Object ID","type":"expression"}],"objectGroups":[]},{"description":"Check if the 3D Animation is finished.\nThis condition is valid only for animations with \"Loop\" set to \"Once\".","fullName":"Check 3D Animation Is Finished","functionType":"Condition","group":"3D Object","name":"Check3DAnimationIsFinished","sentence":"Check 3D Animation Is Finished (ID: _PARAM1_, Animation: _PARAM2_)","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["if (!gdjs.__WithThreeJS.has(\"Renderer\")) {","    console.warn(\"!\");","    return;","}","const Scene = gdjs.__WithThreeJS.get(\"Scene\");","const AnimationMixer = gdjs.__WithThreeJS.get(\"AnimationMixer\");","const AnimationActions = gdjs.__WithThreeJS.get(\"AnimationActions\");","const Id = eventsFunctionContext.getArgument(\"Id\");","const ANumber = eventsFunctionContext.getArgument(\"ANumber\");","eventsFunctionContext.returnValue = false;","//","const Obj = gdjs.__WithThreeJS.get(\"SearchObject\")(Id);","if (!Obj) {","    console.warn(\"3D Object not found: \" + Id);","    return;","}","const Clip = Obj.animations[ANumber];","if (!Clip) {","    return;","}","//","const OBJ_UUID = Obj.uuid;","const Clip_UUID = Clip.uuid;","if (AnimationActions.has(OBJ_UUID)) {","    if (AnimationActions.get(OBJ_UUID).has(Clip_UUID)) {","        const Action = AnimationActions.get(OBJ_UUID).get(Clip_UUID);","        if (Action.loop === THREE.LoopOnce) {","            if (Action.timeScale >= 0) {","                if (Action.time >= Clip.duration) {","                    eventsFunctionContext.returnValue = true;","                }","            } else {","                if (Action.time <= 0) {","                    eventsFunctionContext.returnValue = true;","                }","            }","        }","    }","}","",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"parameters":[{"description":"3D Object ID","name":"Id","supplementaryInformation":"scene3D Object ID","type":"identifier"},{"description":"Original Animation Number","name":"ANumber","supplementaryInformation":"scene3D Object ID","type":"expression"}],"objectGroups":[]},{"description":"Play a 3D Positional Sound.\nThis action is deprecated but is still available. This is because the new action has issues with the editor and is difficult to use.","fullName":"Play 3D Sound V1 (Deprecated)","functionType":"Action","group":"3D Sound","name":"Play3DSound","sentence":" Play 3D Sound V1 (Resource: _PARAM1_, Sound ID: _PARAM2_, Parent ID: _PARAM3_, Loop: _PARAM4_, Volume: _PARAM5_, Pitch: _PARAM6_, Distance: _PARAM7_)","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["if (!gdjs.__WithThreeJS.has(\"Renderer\")) {","    console.warn(\"!\");","    return;","}","const Scene = gdjs.__WithThreeJS.get(\"Scene\");","const Listener = gdjs.__WithThreeJS.get(\"Listener\");","const ResourceName = eventsFunctionContext.getArgument(\"ResourceName\");","const SoundId = eventsFunctionContext.getArgument(\"SoundId\");","const Id = eventsFunctionContext.getArgument(\"Id\");","const Loop = eventsFunctionContext.getArgument(\"Loop\");","const Volume = eventsFunctionContext.getArgument(\"Volume\") || 1;","const Pitch = eventsFunctionContext.getArgument(\"Pitch\") || 1;","let MaxDistance = eventsFunctionContext.getArgument(\"MaxDistance\") || 1000;","//","const ResourceFileName = gdjs.__WithThreeJS.get(\"GetResourceFileName\")(ResourceName, \"audio\");","MaxDistance = MaxDistance <= 0 ? 0.0001 : MaxDistance;","//","const Obj = gdjs.__WithThreeJS.get(\"SearchObject\")(Id);","if (!Obj) {","    console.warn(\"3D Object not found: \" + Id);","    return;","}","//","let Sound = Obj.getObjectByName(SoundId);","if (!Sound) {","\tSound = new THREE.PositionalAudio(Listener);","\tSound.name = SoundId;","\tObj.add(Sound);","}","Sound.setRefDistance(1);//","Sound.setRolloffFactor(1)//","Sound.setDistanceModel(\"linear\");","Sound.setMaxDistance(MaxDistance);//","//","Sound.setLoop(Loop);","Sound.setVolume(Volume);","Sound.setPlaybackRate(Pitch);//","// Sound.setDetune(0);//","//","const audioLoader = new THREE.AudioLoader();","audioLoader.load(ResourceFileName, function(buffer) {","\tSound.setBuffer(buffer);","\tif (Sound.isPlaying) {","\t\tSound.stop();","\t}","\tSound.play();","});","",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"parameters":[{"description":"GDevelop Resource Name (Audio)","longDescription":"Escape is required. example: \"assets\\\\Sound.wav\" -> \"assets\\\\\\\\Sound.wav\"","name":"ResourceName","type":"string"},{"description":"3D Sound ID","name":"SoundId","supplementaryInformation":"scene3D Sound ID","type":"identifier"},{"description":"Parent 3D Object ID","name":"Id","supplementaryInformation":"scene3D Object ID","type":"identifier"},{"description":"Loop","name":"Loop","type":"yesorno"},{"description":"Volume (Default: 1)","name":"Volume","type":"expression"},{"description":"Pitch (Default: 1)","name":"Pitch","type":"expression"},{"description":"Max Distance (0 or more)","name":"MaxDistance","type":"expression"}],"objectGroups":[]},{"description":"Play a 3D Positional Sound.","fullName":"Play 3D Sound","functionType":"Action","group":"3D Sound","name":"Play3DSoundV2","sentence":"Play 3D Sound (Resource: _PARAM1_, Sound ID: _PARAM2_, Parent ID: _PARAM3_, Loop: _PARAM4_, Volume: _PARAM5_, Pitch: _PARAM6_, Distance: _PARAM7_)","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["if (!gdjs.__WithThreeJS.has(\"Renderer\")) {","    console.warn(\"!\");","    return;","}","const Scene = gdjs.__WithThreeJS.get(\"Scene\");","const Listener = gdjs.__WithThreeJS.get(\"Listener\");","const ResourceName = eventsFunctionContext.getArgument(\"ResourceName\");","const SoundId = eventsFunctionContext.getArgument(\"SoundId\");","const Id = eventsFunctionContext.getArgument(\"Id\");","const Loop = eventsFunctionContext.getArgument(\"Loop\");","const Volume = eventsFunctionContext.getArgument(\"Volume\") || 1;","const Pitch = eventsFunctionContext.getArgument(\"Pitch\") || 1;","let MaxDistance = eventsFunctionContext.getArgument(\"MaxDistance\") || 1000;","//","const ResourceFileName = gdjs.__WithThreeJS.get(\"GetResourceFileName\")(ResourceName, \"audio\");","MaxDistance = MaxDistance <= 0 ? 0.0001 : MaxDistance;","//","const Obj = gdjs.__WithThreeJS.get(\"SearchObject\")(Id);","if (!Obj) {","    console.warn(\"3D Object not found: \" + Id);","    return;","}","//","let Sound = Obj.getObjectByName(SoundId);","if (!Sound) {","\tSound = new THREE.PositionalAudio(Listener);","\tSound.name = SoundId;","\tObj.add(Sound);","}","Sound.setRefDistance(1);//","Sound.setRolloffFactor(1)//","Sound.setDistanceModel(\"linear\");","Sound.setMaxDistance(MaxDistance);//","//","Sound.setLoop(Loop);","Sound.setVolume(Volume);","Sound.setPlaybackRate(Pitch);//","// Sound.setDetune(0);//","//","const audioLoader = new THREE.AudioLoader();","audioLoader.load(ResourceFileName, function(buffer) {","\tSound.setBuffer(buffer);","\tif (Sound.isPlaying) {","\t\tSound.stop();","\t}","\tSound.play();","});","",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"parameters":[{"description":"GDevelop Resource Name (Audio)","name":"ResourceName","type":"audioResource"},{"description":"3D Sound ID","name":"SoundId","supplementaryInformation":"scene3D Sound ID","type":"identifier"},{"description":"Parent 3D Object ID","name":"Id","supplementaryInformation":"scene3D Object ID","type":"identifier"},{"description":"Loop","name":"Loop","type":"yesorno"},{"description":"Volume (Default: 1)","name":"Volume","type":"expression"},{"description":"Pitch (Default: 1)","name":"Pitch","type":"expression"},{"description":"Max Distance (0 or more)","name":"MaxDistance","type":"expression"}],"objectGroups":[]},{"description":"Stop a 3D Positional Sound.","fullName":"Stop 3D Sound","functionType":"Action","group":"3D Sound","name":"Stop3DSound","sentence":"Stop 3D Sound (Sound ID: _PARAM1_, Parent ID: _PARAM2_)","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["if (!gdjs.__WithThreeJS.has(\"Renderer\")) {","    console.warn(\"!\");","    return;","}","const Scene = gdjs.__WithThreeJS.get(\"Scene\");","const SoundId = eventsFunctionContext.getArgument(\"SoundId\");","const Id = eventsFunctionContext.getArgument(\"Id\");","//","const Obj = gdjs.__WithThreeJS.get(\"SearchObject\")(Id);","if (!Obj) {","    console.warn(\"3D Object not found: \" + Id);","    return;","}","//","const Sound = Obj.getObjectByName(SoundId);","if (!Sound) {","    console.warn(\"3D Sound not found: \" + SoundId);","    return;","}","if (Sound.isPlaying) {","\tSound.stop();","}","",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"parameters":[{"description":"3D Sound ID","name":"SoundId","supplementaryInformation":"scene3D Sound ID","type":"identifier"},{"description":"Parent 3D Object ID","name":"Id","supplementaryInformation":"scene3D Object ID","type":"identifier"}],"objectGroups":[]},{"fullName":"Change Master Volume Of 3D Scene","functionType":"Action","group":"3D Sound","name":"ChangeMasterVolumeOf3DScene","sentence":"Change Master Volume Of 3D Scene (_PARAM1_, Volume: _PARAM2_)","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["if (!gdjs.__WithThreeJS.has(\"Renderer\")) {","    console.warn(\"!\");","    return;","}","const Listener = gdjs.__WithThreeJS.get(\"Listener\");","const Operator = eventsFunctionContext.getArgument(\"Operator\");","const Volume = eventsFunctionContext.getArgument(\"Volume\");","//","if (Operator == \"=\") {","    Listener.setMasterVolume(Volume);","} else if (Operator == \"+\") {","    Listener.setMasterVolume(Listener.getMasterVolume() + Volume);","} else if (Operator == \"-\") {","    Listener.setMasterVolume(Listener.getMasterVolume() - Volume);","}","",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"parameters":[{"description":"Operator","name":"Operator","supplementaryInformation":"[\"=\",\"+\",\"-\"]","type":"stringWithSelector"},{"description":"Master Volume (Default: 1)","name":"Volume","type":"expression"}],"objectGroups":[]},{"fullName":"Master Volume Of 3D Scene","functionType":"Expression","group":"3D Sound","name":"MasterVolumeOf3DScene","sentence":"Master Volume of 3D Scene","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["if (!gdjs.__WithThreeJS.has(\"Renderer\")) {","    console.warn(\"!\");","    return;","}","const Listener = gdjs.__WithThreeJS.get(\"Listener\");","eventsFunctionContext.returnValue = Listener.getMasterVolume();","",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"expressionType":{"type":"expression"},"parameters":[],"objectGroups":[]},{"description":"Check if the 3D Sound is playing.","fullName":"Check 3D Sound Is Playing","functionType":"Condition","group":"3D Sound","name":"Check3DSoundIsPlaying","sentence":"Check 3D Sound Is Playing (Sound ID: _PARAM1_, Parent ID: _PARAM2_)","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["if (!gdjs.__WithThreeJS.has(\"Renderer\")) {","    console.warn(\"!\");","    return;","}","const Scene = gdjs.__WithThreeJS.get(\"Scene\");","const SoundId = eventsFunctionContext.getArgument(\"SoundId\");","const Id = eventsFunctionContext.getArgument(\"Id\");","//","const Obj = gdjs.__WithThreeJS.get(\"SearchObject\")(Id);","if (!Obj) {","    console.warn(\"3D Object not found: \" + Id);","    return;","}","//","const Sound = Obj.getObjectByName(SoundId);","if (!Sound) {","    console.warn(\"3D Sound not found: \" + SoundId);","    return;","}","eventsFunctionContext.returnValue = Sound.isPlaying;","",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"parameters":[{"description":"3D Sound ID","name":"SoundId","supplementaryInformation":"scene3D Sound ID","type":"identifier"},{"description":"Parent 3D Object ID","name":"Id","supplementaryInformation":"scene3D Object ID","type":"identifier"}],"objectGroups":[]},{"fullName":"Create 3D Axes Helper","functionType":"Action","group":"3D Debug","name":"Create3DAxesHelper","sentence":"Create 3D Axes Helper (Parent ID: _PARAM1_, Size: _PARAM2_)","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["if (!gdjs.__WithThreeJS.has(\"Renderer\")) {","    console.warn(\"!\");","    return;","}","const Scene = gdjs.__WithThreeJS.get(\"Scene\");","//","const ParentId = eventsFunctionContext.getArgument(\"ParentId\");","const Size = eventsFunctionContext.getArgument(\"Size\");","//","const Parent = gdjs.__WithThreeJS.get(\"SearchObject\")(ParentId);","if (!Parent) {","    console.warn(\"Parent 3D Object not found: \" + ParentId);","    return;","}","//","const AxesHelper = new THREE.AxesHelper(Size);","AxesHelper.name = ParentId + \"_AxesHelper\";","Parent.add(AxesHelper);"],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"parameters":[{"description":"Parent 3D Object ID","name":"ParentId","supplementaryInformation":"scene3D Object ID","type":"identifier"},{"description":"Size","name":"Size","type":"expression"}],"objectGroups":[]},{"description":"Create or update Helper to graphically display Bounding Box.","fullName":"Update Bounding Box Helper","functionType":"Action","group":"3D Debug","name":"UpdateBoundingBoxHelper","sentence":"Update Bounding Box Helper (ID: _PARAM1_, Color: _PARAM2_)","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["if (!gdjs.__WithThreeJS.has(\"Renderer\")) {","    console.warn(\"!\");","    return;","}","const Scene = gdjs.__WithThreeJS.get(\"Scene\");","//","const Id = eventsFunctionContext.getArgument(\"Id\");","const Color = eventsFunctionContext.getArgument(\"Color\") || \"0;0;0\";","const RGB = Color.split(\";\");","//","const Obj = gdjs.__WithThreeJS.get(\"SearchObject\")(Id);","if (!Obj) {","    console.warn(\"3D Object not found: \" + Id);","    return;","}","if (!Obj.geometry) {","    console.warn(\"Geometry not found: \" + Id);","    return;","}","//","// BoxHelper ","let Box3Helper = gdjs.__WithThreeJS.get(\"SearchObject\")(Id + \"_Box3Helper\");","if (Box3Helper) {","    Box3Helper.box.copy(Obj.geometry.boundingBox).applyMatrix4(Obj.matrixWorld);","} else {","    Obj.updateMatrixWorld(true);//","    const Box3 = new THREE.Box3();","    Box3.copy(Obj.geometry.boundingBox).applyMatrix4(Obj.matrixWorld);","    Box3Helper = new THREE.Box3Helper(Box3, `rgb(${RGB[0]}, ${RGB[1]}, ${RGB[2]})`);","    Box3Helper.name = Id + \"_Box3Helper\";","    Scene.add(Box3Helper);","}","",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"parameters":[{"description":"3D Object ID","name":"Id","supplementaryInformation":"scene3D Object ID","type":"identifier"},{"description":"Color","name":"Color","type":"color"}],"objectGroups":[]},{"fullName":"Output 3D Model Information To Console","functionType":"Action","group":"3D Debug","name":"OutputModelInformationToConsole","sentence":"Output 3D Model Information To Console (3D Model ID: _PARAM1_)","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["if (!gdjs.__WithThreeJS.has(\"Renderer\")) {","    console.warn(\"!\");","    return;","}","if (!gdjs.__WithThreeJS.has(\"Models\")) {","    console.warn(\"!\");","    return;","}","const Scene = gdjs.__WithThreeJS.get(\"Scene\");","const Models = gdjs.__WithThreeJS.get(\"Models\");","//","const ModelId = eventsFunctionContext.getArgument(\"ModelId\");","//","if (!Models.has(ModelId)) {","    console.warn(\"3D Model not found: \" + ModelId);","    return;","}","//","console.log(gdjs.__WithThreeJS.get(\"GetModelInfo\")(Models.get(ModelId), \"\", 0));","",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"parameters":[{"description":"3D Model ID","name":"ModelId","supplementaryInformation":"scene3D Model ID","type":"identifier"}],"objectGroups":[]},{"fullName":"Output All IDs To Console","functionType":"Action","group":"3D Debug","name":"OutputAllIdsToConsole","sentence":"Output All IDs To Console (Type: _PARAM1_)","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["if (!gdjs.__WithThreeJS.has(\"Renderer\")) {","    console.warn(\"!\");","    return;","}","const Scene = gdjs.__WithThreeJS.get(\"Scene\");","const Type = eventsFunctionContext.getArgument(\"Type\");","let Res = \"\";","//","if (Type == \"3D Object\") {","    Res = gdjs.__WithThreeJS.get(\"GetAllObjectsName\")(Scene, Res, 0);","} else if (Type == \"3D Texture\") {","    if (!gdjs.__WithThreeJS.has(\"Textures\")) {","        console.warn(\"3D Texture not found.\");","        return;","    }","    const Textures = gdjs.__WithThreeJS.get(\"Textures\");","    for (let K of Textures.keys()) {","        Res += \"ID: \" + K + \"\\n\";","    }","} else if (Type == \"3D Model\") {","    if (!gdjs.__WithThreeJS.has(\"Models\")) {","        console.warn(\"3D Model not found.\");","        return;","    }","    const Models = gdjs.__WithThreeJS.get(\"Models\");","    for (let K of Models.keys()) {","        Res += \"ID: \" + K + \"\\n\";","    }","}","//","console.log(Res);","",""],"parameterObjects":"","useStrict":true,"eventsSheetExpanded":true}],"parameters":[{"description":"Type","name":"Type","supplementaryInformation":"[\"3D Object\",\"3D Texture\",\"3D Model\"]","type":"stringWithSelector"}],"objectGroups":[]}],"eventsBasedBehaviors":[{"description":"Create 3D Sprite from Sprite object. Moving that Sprite will also move the 3D Sprite.","fullName":"3D Sprite Projection","name":"SpriteProjection","objectType":"Sprite","eventsFunctions":[{"fullName":"","functionType":"Action","name":"doStepPostEvents","sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"WithThreeJS::SpriteProjection::PropertyFirstFrame"},"parameters":["Object","Behavior"]}],"actions":[{"type":{"value":"WithThreeJS::SpriteProjection::SetPropertyFirstFrame"},"parameters":["Object","Behavior","no"]}],"events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["if (!gdjs.__WithThreeJS.has(\"Renderer\")) {","    console.warn(\"!\");","    return;","}","if (!gdjs.__WithThreeJS.has(\"Textures\")) {","    gdjs.__WithThreeJS.set(\"Textures\", new Map());","}","const Scene = gdjs.__WithThreeJS.get(\"Scene\");","let Textures = gdjs.__WithThreeJS.get(\"Textures\");","//","const Behavior = objects[0].getBehavior(\"SpriteProjection\");","const Id = objects[0].name + objects[0].id;","// const X = objects[0].x;","// const Y = objects[0].y;","// const Z = objects[0].zOrder;","const ProjectionScale = gdjs.__WithThreeJS.get(\"ProjectionScale\");","// const ViewMode = gdjs.__WithThreeJS.get(\"ViewMode\");","const AlphaTest = Behavior.AlphaTest();","const Transparent = AlphaTest !== 0;","const AntiAliasing = Behavior.AntiAliasing();","const Depth = Behavior.Depth();","const CastShadow = Behavior.CastShadow();","const ReceiveShadow = Behavior.ReceiveShadow();","// const Blend = THREE.NormalBlending;","// const Opacity = 1.0;","//","//","objects[0]._updateIfNotVisible = true;// ","let AllAnimationSources = [];","const Animations = objects[0]._animations ? objects[0]._animations : objects[0]._animator._animations;","for(const V of Animations) {","    for(const VV of V.directions[0].frames) {","        AllAnimationSources.push(VV.texture.baseTexture.resource);","    }","}","//Textures","for(const V of AllAnimationSources) {","    const TexId = \"_\" + V.url;","    if (!Textures.has(TexId)) {","        const T = new THREE.Texture();","        T.image = V.source;","        T.wrapS = THREE.MirroredRepeatWrapping;","        T.wrapT = THREE.MirroredRepeatWrapping;","        if (!AntiAliasing) {","            T.magFilter = THREE.NearestFilter;// THREE.LinearFilter","            T.minFilter = THREE.NearestFilter;// THREE.LinearMipmapLinearFilter","        }","        T.colorSpace = THREE.SRGBColorSpace;","        T.needsUpdate = true;//","        Textures.set(TexId, T);","        //FlipX","        const T_FlipX = T.clone();","        T_FlipX.offset.x = 1;","        Textures.set(TexId + \"_FlipX\", T_FlipX);","        //FlipY","        const T_FlipY = T.clone();","        T_FlipY.offset.y = 1;","        Textures.set(TexId + \"_FlipY\", T_FlipY);","        //FlipXY","        const T_FlipXY = T.clone();","        T_FlipXY.offset.x = 1;","        T_FlipXY.offset.y = 1;","        Textures.set(TexId + \"_FlipX_FlipY\", T_FlipXY);","    }","}","//","const TextureId = \"_\" + objects[0].getRendererObject().texture.baseTexture.resource.url;","Behavior.SetCurrentTextureId(TextureId);","const Texture = Textures.get(TextureId);","const TextureWidth = Texture.image.width;","const TextureHeight = Texture.image.height;","const Material = new THREE.SpriteMaterial({map:Texture, transparent:Transparent, alphaTest:AlphaTest});// blendingopacity2D","const Sprite = new THREE.Sprite(Material);","// ","const OriginalGeometry = Sprite.geometry.clone();","Sprite.geometry = OriginalGeometry;","Sprite.geometry.computeBoundingBox();","Sprite.geometry.boundingBox.expandByVector(new THREE.Vector3(0, 0, (Depth * ProjectionScale) / 2));","Sprite.name = Id;","Sprite.castShadow = CastShadow;// ","Sprite.receiveShadow = ReceiveShadow;","Sprite.userData.Use3DProjectionBehavior = true;","Sprite.scale.set(TextureWidth * ProjectionScale, TextureHeight * ProjectionScale, 1);","Behavior.SetId(Id);","Scene.add(Sprite);","",""],"parameterObjects":"Object","useStrict":true,"eventsSheetExpanded":true},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"WithThreeJS::SpriteProjection::PropertyHide"},"parameters":["Object","Behavior"]}],"actions":[{"type":{"value":"Cache"},"parameters":["Object"]}]}]},{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["if (!gdjs.__WithThreeJS.has(\"Renderer\")) {\r","    console.warn(\"!\");\r","    return;\r","}\r","if (!gdjs.__WithThreeJS.has(\"Textures\")) {\r","    console.warn(\"!\");\r","    return;\r","}\r","const Scene = gdjs.__WithThreeJS.get(\"Scene\");\r","let Textures = gdjs.__WithThreeJS.get(\"Textures\");\r","//\r","const Behavior = objects[0].getBehavior(\"SpriteProjection\");\r","const Id = Behavior.Id();\r","const X = objects[0].getCenterXInScene();\r","const Y = objects[0].getCenterYInScene();\r","const Z = objects[0].zOrder;\r","const ProjectionScale = gdjs.__WithThreeJS.get(\"ProjectionScale\");\r","const ViewMode = gdjs.__WithThreeJS.get(\"ViewMode\");\r","//\r","const Sprite = gdjs.__WithThreeJS.get(\"SearchObject\")(Id);\r","if (!Sprite) {\r","    console.warn(\"3D Object not found: \" + Id);\r","    return;\r","}\r","objects[0]._updateAnimationFrame();//v5.3.198 \r","let TextureId = \"_\" + objects[0].getRendererObject().texture.baseTexture.resource.url;\r","// Flip\r","if (objects[0].isFlippedX()) {\r","    TextureId += \"_FlipX\";\r","}\r","if (objects[0].isFlippedY()) {\r","    TextureId += \"_FlipY\";\r","}\r","// Animation\r","const Texture = Textures.get(TextureId);\r","if (TextureId !== Behavior.CurrentTextureId()) {\r","    Sprite.material.map = Texture;\r","    Behavior.SetCurrentTextureId(TextureId);\r","}\r","// Blend\r","Sprite.material.blending = gdjs.__WithThreeJS.get(\"Blend2Dto3D\")[objects[0].getBlendMode()];\r","// Opacity\r","const Opacity = objects[0].getOpacity() / 255;\r","if (!Sprite.material.transparent) {\r","    if (Sprite.material.alphaTest !== 0 || Opacity !== 1) {\r","        Sprite.material.transparent = true;\r","        Sprite.material.needsUpdate = true;\r","    }\r","}\r","Sprite.material.opacity = Opacity;\r","// Scale\r","const TextureWidth = Texture.image.width;\r","const TextureHeight = Texture.image.height;\r","Sprite.scale.set(TextureWidth * ProjectionScale * objects[0].getScaleX(), TextureHeight * ProjectionScale * objects[0].getScaleY(), 1);\r","// Move\r","if (ViewMode == \"Top Down\") {\r","    Sprite.position.set(X * ProjectionScale, Z * ProjectionScale, Y * ProjectionScale);\r","} else {\r","    // Side\r","    Sprite.position.set(X * ProjectionScale, -Y * ProjectionScale, Z * ProjectionScale);\r","}\r","\r",""],"parameterObjects":"Object","useStrict":true,"eventsSheetExpanded":true}],"parameters":[{"description":"Object","name":"Object","supplementaryInformation":"Sprite","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"WithThreeJS::SpriteProjection","type":"behavior"}],"objectGroups":[]},{"fullName":"","functionType":"Action","name":"onDestroy","sentence":"","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["// 3D\r","// FirstFrame == true  Id \r","const Behavior = objects[0].getBehavior(\"SpriteProjection\");\r","const Id = Behavior.Id();\r","if (Id === \"\") {\r","    return;\r","}\r","//\r","if (!gdjs.__WithThreeJS.has(\"Renderer\")) {\r","    console.warn(\"!\");\r","    return;\r","}\r","const Scene = gdjs.__WithThreeJS.get(\"Scene\");\r","const Sprite = gdjs.__WithThreeJS.get(\"SearchObject\")(Id);\r","//\r","gdjs.__WithThreeJS.get(\"DisposeChildren\")(Sprite);\r","Sprite.removeFromParent();\r","\r",""],"parameterObjects":"Object","useStrict":true,"eventsSheetExpanded":true}],"parameters":[{"description":"Object","name":"Object","supplementaryInformation":"Sprite","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"WithThreeJS::SpriteProjection","type":"behavior"}],"objectGroups":[]},{"fullName":"3D Object ID","functionType":"StringExpression","name":"Id","sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetReturnString"},"parameters":["Object.Behavior::PropertyId()"]}]}],"expressionType":{"type":"string"},"parameters":[{"description":"Object","name":"Object","supplementaryInformation":"Sprite","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"WithThreeJS::SpriteProjection","type":"behavior"}],"objectGroups":[]},{"fullName":"Alpha Channel Test","functionType":"Expression","name":"AlphaTest","sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetReturnNumber"},"parameters":["Object.Behavior::PropertyAlphaTest()"]}]}],"expressionType":{"type":"expression"},"parameters":[{"description":"Object","name":"Object","supplementaryInformation":"Sprite","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"WithThreeJS::SpriteProjection","type":"behavior"}],"objectGroups":[]},{"fullName":"Is Anti-Aliasing","functionType":"Condition","name":"AntiAliasing","private":true,"sentence":"Is Anti-Aliasing _PARAM0_","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"WithThreeJS::SpriteProjection::PropertyAntiAliasing"},"parameters":["Object","Behavior"]}],"actions":[{"type":{"value":"SetReturnBoolean"},"parameters":["True"]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"inverted":true,"value":"WithThreeJS::SpriteProjection::PropertyAntiAliasing"},"parameters":["Object","Behavior"]}],"actions":[{"type":{"value":"SetReturnBoolean"},"parameters":["False"]}]}],"parameters":[{"description":"Object","name":"Object","supplementaryInformation":"Sprite","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"WithThreeJS::SpriteProjection","type":"behavior"}],"objectGroups":[]},{"fullName":"Is Cast Shadow","functionType":"Condition","name":"CastShadow","private":true,"sentence":"Is Cast Shadow _PARAM0_","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"WithThreeJS::SpriteProjection::PropertyCastShadow"},"parameters":["Object","Behavior"]}],"actions":[{"type":{"value":"SetReturnBoolean"},"parameters":["True"]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"inverted":true,"value":"WithThreeJS::SpriteProjection::PropertyCastShadow"},"parameters":["Object","Behavior"]}],"actions":[{"type":{"value":"SetReturnBoolean"},"parameters":["False"]}]}],"parameters":[{"description":"Object","name":"Object","supplementaryInformation":"Sprite","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"WithThreeJS::SpriteProjection","type":"behavior"}],"objectGroups":[]},{"fullName":"Is Receive Shadow","functionType":"Condition","name":"ReceiveShadow","private":true,"sentence":"Is Receive Shadow _PARAM0_","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"WithThreeJS::SpriteProjection::PropertyReceiveShadow"},"parameters":["Object","Behavior"]}],"actions":[{"type":{"value":"SetReturnBoolean"},"parameters":["True"]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"inverted":true,"value":"WithThreeJS::SpriteProjection::PropertyReceiveShadow"},"parameters":["Object","Behavior"]}],"actions":[{"type":{"value":"SetReturnBoolean"},"parameters":["False"]}]}],"parameters":[{"description":"Object","name":"Object","supplementaryInformation":"Sprite","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"WithThreeJS::SpriteProjection","type":"behavior"}],"objectGroups":[]},{"fullName":"Current 3D Texture ID","functionType":"StringExpression","name":"CurrentTextureId","private":true,"sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetReturnString"},"parameters":["Object.Behavior::PropertyCurrentTextureId()"]}]}],"expressionType":{"type":"string"},"parameters":[{"description":"Object","name":"Object","supplementaryInformation":"Sprite","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"WithThreeJS::SpriteProjection","type":"behavior"}],"objectGroups":[]},{"fullName":"Depth for Bounding Box Collision","functionType":"Expression","name":"Depth","private":true,"sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetReturnNumber"},"parameters":["Object.Behavior::PropertyDepth()"]}]}],"expressionType":{"type":"expression"},"parameters":[{"description":"Object","name":"Object","supplementaryInformation":"Sprite","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"WithThreeJS::SpriteProjection","type":"behavior"}],"objectGroups":[]},{"fullName":"Set 3D Object ID","functionType":"Action","name":"SetId","private":true,"sentence":"Set 3D Object ID (_PARAM0_, ID: _PARAM2_)","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"WithThreeJS::SpriteProjection::SetPropertyId"},"parameters":["Object","Behavior","=","GetArgumentAsString(\"Id\")"]}]}],"parameters":[{"description":"Object","name":"Object","supplementaryInformation":"Sprite","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"WithThreeJS::SpriteProjection","type":"behavior"},{"description":"3D Object ID","name":"Id","type":"string"}],"objectGroups":[]},{"fullName":"Set Current 3D Texture ID","functionType":"Action","name":"SetCurrentTextureId","private":true,"sentence":"Set Current 3D Texture ID (_PARAM0_, ID: _PARAM2_)","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"WithThreeJS::SpriteProjection::SetPropertyCurrentTextureId"},"parameters":["Object","Behavior","=","GetArgumentAsString(\"Id\")"]}]}],"parameters":[{"description":"Object","name":"Object","supplementaryInformation":"Sprite","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"WithThreeJS::SpriteProjection","type":"behavior"},{"description":"3D Texture ID","name":"Id","type":"string"}],"objectGroups":[]}],"propertyDescriptors":[{"value":"","type":"String","label":"","description":"","group":"","extraInformation":[],"hidden":true,"name":"Id"},{"value":"true","type":"Boolean","label":"","description":"","group":"","extraInformation":[],"hidden":true,"name":"FirstFrame"},{"value":"","type":"String","label":"","description":"","group":"","extraInformation":[],"hidden":true,"name":"CurrentTextureId"},{"value":"true","type":"Boolean","label":"Hide 2D Object","description":"","group":"","extraInformation":[],"name":"Hide"},{"value":"0","type":"Number","label":"Alpha Channel Test","description":"Recommended values: 0 or 0.5. Default: 0.","group":"Texture","extraInformation":[],"name":"AlphaTest"},{"value":"true","type":"Boolean","label":"Anti-Aliasing","description":"","group":"Texture","extraInformation":["Antialiased","No Antialiasing"],"name":"AntiAliasing"},{"value":"0","type":"Number","label":"Depth for Bounding Box Collision","description":"Unit: Pixel","group":"Collision","extraInformation":[],"name":"Depth"},{"value":"","type":"Boolean","label":"Cast Shadow","description":"If both \"Cast Shadow\" and \"Receive Shadow\" are enabled, striped patterns are likely to occur in the shadow.","group":"Shadow","extraInformation":[],"hidden":true,"name":"CastShadow"},{"value":"","type":"Boolean","label":"Receive Shadow","description":"If both \"Cast Shadow\" and \"Receive Shadow\" are enabled, striped patterns are likely to occur in the shadow.","group":"Shadow","extraInformation":[],"hidden":true,"name":"ReceiveShadow"}],"sharedPropertyDescriptors":[]},{"description":"Create 3D Board (Plane) from Sprite object. Moving that Sprite will also move the 3D Object.","fullName":"3D Board Projection","name":"BoardProjection","objectType":"Sprite","eventsFunctions":[{"fullName":"","functionType":"Action","name":"doStepPostEvents","sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"WithThreeJS::BoardProjection::PropertyFirstFrame"},"parameters":["Object","Behavior"]}],"actions":[{"type":{"value":"WithThreeJS::BoardProjection::SetPropertyFirstFrame"},"parameters":["Object","Behavior","no"]}],"events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["if (!gdjs.__WithThreeJS.has(\"Renderer\")) {","    console.warn(\"!\");","    return;","}","if (!gdjs.__WithThreeJS.has(\"Textures\")) {","    gdjs.__WithThreeJS.set(\"Textures\", new Map());","}","const Scene = gdjs.__WithThreeJS.get(\"Scene\");","let Textures = gdjs.__WithThreeJS.get(\"Textures\");","//","const Behavior = objects[0].getBehavior(\"BoardProjection\");","const Id = objects[0].name + objects[0].id;","const ProjectionScale = gdjs.__WithThreeJS.get(\"ProjectionScale\");","// const ViewMode = gdjs.__WithThreeJS.get(\"ViewMode\");","const AlphaTest = Behavior.AlphaTest();","const Transparent = AlphaTest !== 0;","const AntiAliasing = Behavior.AntiAliasing();","const Depth = Behavior.Depth();","const CastShadow = Behavior.CastShadow();","const ReceiveShadow = Behavior.ReceiveShadow();","//","//","objects[0]._updateIfNotVisible = true;// ","let AllAnimationSources = [];","const Animations = objects[0]._animations ? objects[0]._animations : objects[0]._animator._animations;","for(const V of Animations) {","    for(const VV of V.directions[0].frames) {","        AllAnimationSources.push(VV.texture.baseTexture.resource);","    }","}","//Textures(SpriteProjection)","for(const V of AllAnimationSources) {","    const TexId = \"_\" + V.url;","    if (!Textures.has(TexId)) {","        const T = new THREE.Texture();","        T.image = V.source;","        T.wrapS = THREE.MirroredRepeatWrapping;","        T.wrapT = THREE.MirroredRepeatWrapping;","        if (!AntiAliasing) {","            T.magFilter = THREE.NearestFilter;// THREE.LinearFilter","            T.minFilter = THREE.NearestFilter;// THREE.LinearMipmapLinearFilter","        }","        T.colorSpace = THREE.SRGBColorSpace;","        T.needsUpdate = true;//","        Textures.set(TexId, T);","        //FlipX","        const T_FlipX = T.clone();","        T_FlipX.offset.x = 1;","        Textures.set(TexId + \"_FlipX\", T_FlipX);","        //FlipY","        const T_FlipY = T.clone();","        T_FlipY.offset.y = 1;","        Textures.set(TexId + \"_FlipY\", T_FlipY);","        //FlipXY","        const T_FlipXY = T.clone();","        T_FlipXY.offset.x = 1;","        T_FlipXY.offset.y = 1;","        Textures.set(TexId + \"_FlipX_FlipY\", T_FlipXY);","    }","}","//","const TextureId = \"_\" + objects[0].getRendererObject().texture.baseTexture.resource.url;","Behavior.SetCurrentTextureId(TextureId);","const Texture = Textures.get(TextureId);","const TextureWidth = Texture.image.width;","const TextureHeight = Texture.image.height;","//const Material = new THREE.MeshBasicMaterial({map:Texture, side:THREE.DoubleSide, transparent:Transparent, alphaTest:AlphaTest});// blendingopacity2D","const Material = new THREE.MeshLambertMaterial({map:Texture, side:THREE.DoubleSide, transparent:Transparent, alphaTest:AlphaTest});// blendingopacity2D","const Geometry = new THREE.PlaneGeometry(TextureWidth * ProjectionScale, TextureHeight * ProjectionScale, 1, 1);","Geometry.computeBoundingBox();","Geometry.boundingBox.expandByVector(new THREE.Vector3(0, 0, (Depth * ProjectionScale) / 2));","const Obj = new THREE.Mesh(Geometry, Material);","Obj.name = Id;","Obj.castShadow = CastShadow;","Obj.receiveShadow = ReceiveShadow;","Obj.userData.Use3DProjectionBehavior = true;","Behavior.SetId(Id);","Scene.add(Obj);","",""],"parameterObjects":"Object","useStrict":true,"eventsSheetExpanded":true},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"WithThreeJS::BoardProjection::PropertyHide"},"parameters":["Object","Behavior"]}],"actions":[{"type":{"value":"Cache"},"parameters":["Object"]}]}]},{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["if (!gdjs.__WithThreeJS.has(\"Renderer\")) {\r","    console.warn(\"!\");\r","    return;\r","}\r","if (!gdjs.__WithThreeJS.has(\"Textures\")) {\r","    console.warn(\"!\");\r","    return;\r","}\r","const Scene = gdjs.__WithThreeJS.get(\"Scene\");\r","let Textures = gdjs.__WithThreeJS.get(\"Textures\");\r","//\r","const Behavior = objects[0].getBehavior(\"BoardProjection\");\r","const Id = Behavior.Id();\r","const X = objects[0].getCenterXInScene();\r","const Y = objects[0].getCenterYInScene();\r","const Z = objects[0].zOrder;\r","const ProjectionScale = gdjs.__WithThreeJS.get(\"ProjectionScale\");\r","const ViewMode = gdjs.__WithThreeJS.get(\"ViewMode\");\r","const AngleAxis = Behavior.AngleAxis();\r","const Orientation = Behavior.Orientation();\r","//\r","const Obj = gdjs.__WithThreeJS.get(\"SearchObject\")(Id);\r","if (!Obj) {\r","    console.warn(\"3D Object not found: \" + Id);\r","    return;\r","}\r","objects[0]._updateAnimationFrame();//v5.3.198 \r","let TextureId = \"_\" + objects[0].getRendererObject().texture.baseTexture.resource.url;\r","// Flip\r","if (objects[0].isFlippedX()) {\r","    TextureId += \"_FlipX\";\r","}\r","if (objects[0].isFlippedY()) {\r","    TextureId += \"_FlipY\";\r","}\r","// Animation\r","const Texture = Textures.get(TextureId);\r","if (TextureId !== Behavior.CurrentTextureId()) {\r","    Obj.material.map = Texture;\r","    Behavior.SetCurrentTextureId(TextureId);\r","}\r","// Blend\r","Obj.material.blending = gdjs.__WithThreeJS.get(\"Blend2Dto3D\")[objects[0].getBlendMode()];\r","// Opacity\r","const Opacity = objects[0].getOpacity() / 255;\r","if (!Obj.material.transparent) {\r","    if (Obj.material.alphaTest !== 0 || Opacity !== 1) {\r","        Obj.material.transparent = true;\r","        Obj.material.needsUpdate = true;\r","    }\r","}\r","Obj.material.opacity = Opacity;\r","// Scale\r","Obj.scale.set(objects[0].getScaleX(), objects[0].getScaleY(), 1);\r","// Rotate\r","const BaseXAngle = (Orientation == \"Horizontal\") ? -90 : 0;\r","const Angle = objects[0].angle * -1;\r","if (AngleAxis == \"X Axis\") {\r","    Obj.rotation.set(gdjs.toRad(BaseXAngle + Angle), gdjs.toRad(0), gdjs.toRad(0));\r","} else if (AngleAxis == \"Y Axis\") {\r","    Obj.rotation.set(gdjs.toRad(BaseXAngle), gdjs.toRad(Angle), gdjs.toRad(0));\r","} else {\r","    Obj.rotation.set(gdjs.toRad(BaseXAngle), gdjs.toRad(0), gdjs.toRad(Angle));\r","}\r","// Move\r","if (ViewMode == \"Top Down\") {\r","    Obj.position.set(X * ProjectionScale, Z * ProjectionScale, Y * ProjectionScale);\r","} else {\r","    // Side\r","    Obj.position.set(X * ProjectionScale, -Y * ProjectionScale, Z * ProjectionScale);\r","}\r","\r",""],"parameterObjects":"Object","useStrict":true,"eventsSheetExpanded":true}],"parameters":[{"description":"Object","name":"Object","supplementaryInformation":"Sprite","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"WithThreeJS::BoardProjection","type":"behavior"}],"objectGroups":[]},{"fullName":"","functionType":"Action","name":"onDestroy","sentence":"","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["// 3D\r","// FirstFrame == true  Id \r","const Behavior = objects[0].getBehavior(\"BoardProjection\");\r","const Id = Behavior.Id();\r","if (Id === \"\") {\r","    return;\r","}\r","//\r","if (!gdjs.__WithThreeJS.has(\"Renderer\")) {\r","    console.warn(\"!\");\r","    return;\r","}\r","const Scene = gdjs.__WithThreeJS.get(\"Scene\");\r","const Sprite = gdjs.__WithThreeJS.get(\"SearchObject\")(Id);\r","//\r","gdjs.__WithThreeJS.get(\"DisposeChildren\")(Sprite);\r","Sprite.removeFromParent();"],"parameterObjects":"Object","useStrict":true,"eventsSheetExpanded":true}],"parameters":[{"description":"Object","name":"Object","supplementaryInformation":"Sprite","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"WithThreeJS::BoardProjection","type":"behavior"}],"objectGroups":[]},{"fullName":"3D Object ID","functionType":"StringExpression","name":"Id","sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetReturnString"},"parameters":["Object.Behavior::PropertyId()"]}]}],"expressionType":{"type":"string"},"parameters":[{"description":"Object","name":"Object","supplementaryInformation":"Sprite","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"WithThreeJS::BoardProjection","type":"behavior"}],"objectGroups":[]},{"fullName":"Alpha Channel Test","functionType":"Expression","name":"AlphaTest","sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetReturnNumber"},"parameters":["Object.Behavior::PropertyAlphaTest()"]}]}],"expressionType":{"type":"expression"},"parameters":[{"description":"Object","name":"Object","supplementaryInformation":"Sprite","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"WithThreeJS::BoardProjection","type":"behavior"}],"objectGroups":[]},{"fullName":"Axis linked to 2D Object Angle","functionType":"StringExpression","name":"AngleAxis","sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetReturnString"},"parameters":["Object.Behavior::PropertyAngleAxis()"]}]}],"expressionType":{"type":"string"},"parameters":[{"description":"Object","name":"Object","supplementaryInformation":"Sprite","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"WithThreeJS::BoardProjection","type":"behavior"}],"objectGroups":[]},{"fullName":"Orientation","functionType":"StringExpression","name":"Orientation","sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetReturnString"},"parameters":["Object.Behavior::PropertyOrientation()"]}]}],"expressionType":{"type":"string"},"parameters":[{"description":"Object","name":"Object","supplementaryInformation":"Sprite","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"WithThreeJS::BoardProjection","type":"behavior"}],"objectGroups":[]},{"fullName":"Is Anti-Aliasing","functionType":"Condition","name":"AntiAliasing","private":true,"sentence":"Is Anti-Aliasing _PARAM0_","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"WithThreeJS::BoardProjection::PropertyAntiAliasing"},"parameters":["Object","Behavior"]}],"actions":[{"type":{"value":"SetReturnBoolean"},"parameters":["True"]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"inverted":true,"value":"WithThreeJS::BoardProjection::PropertyAntiAliasing"},"parameters":["Object","Behavior"]}],"actions":[{"type":{"value":"SetReturnBoolean"},"parameters":["False"]}]}],"parameters":[{"description":"Object","name":"Object","supplementaryInformation":"Sprite","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"WithThreeJS::BoardProjection","type":"behavior"}],"objectGroups":[]},{"fullName":"Current 3D Texture ID","functionType":"StringExpression","name":"CurrentTextureId","private":true,"sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetReturnString"},"parameters":["Object.Behavior::PropertyCurrentTextureId()"]}]}],"expressionType":{"type":"string"},"parameters":[{"description":"Object","name":"Object","supplementaryInformation":"Sprite","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"WithThreeJS::BoardProjection","type":"behavior"}],"objectGroups":[]},{"fullName":"Depth for Bounding Box Collision","functionType":"Expression","name":"Depth","private":true,"sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetReturnNumber"},"parameters":["Object.Behavior::PropertyDepth()"]}]}],"expressionType":{"type":"expression"},"parameters":[{"description":"Object","name":"Object","supplementaryInformation":"Sprite","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"WithThreeJS::BoardProjection","type":"behavior"}],"objectGroups":[]},{"fullName":"Is Cast Shadow","functionType":"Condition","name":"CastShadow","private":true,"sentence":"Is Cast Shadow _PARAM0_","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"WithThreeJS::BoardProjection::PropertyCastShadow"},"parameters":["Object","Behavior"]}],"actions":[{"type":{"value":"SetReturnBoolean"},"parameters":["True"]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"inverted":true,"value":"WithThreeJS::BoardProjection::PropertyCastShadow"},"parameters":["Object","Behavior"]}],"actions":[{"type":{"value":"SetReturnBoolean"},"parameters":["False"]}]}],"parameters":[{"description":"Object","name":"Object","supplementaryInformation":"Sprite","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"WithThreeJS::BoardProjection","type":"behavior"}],"objectGroups":[]},{"fullName":"Is Receive Shadow","functionType":"Condition","name":"ReceiveShadow","private":true,"sentence":"Is Receive Shadow _PARAM0_","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"WithThreeJS::BoardProjection::PropertyReceiveShadow"},"parameters":["Object","Behavior"]}],"actions":[{"type":{"value":"SetReturnBoolean"},"parameters":["True"]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"inverted":true,"value":"WithThreeJS::BoardProjection::PropertyReceiveShadow"},"parameters":["Object","Behavior"]}],"actions":[{"type":{"value":"SetReturnBoolean"},"parameters":["False"]}]}],"parameters":[{"description":"Object","name":"Object","supplementaryInformation":"Sprite","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"WithThreeJS::BoardProjection","type":"behavior"}],"objectGroups":[]},{"fullName":"Set 3D Object ID","functionType":"Action","name":"SetId","private":true,"sentence":"Set 3D Object ID (_PARAM0_, ID: _PARAM2_)","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"WithThreeJS::BoardProjection::SetPropertyId"},"parameters":["Object","Behavior","=","GetArgumentAsString(\"Id\")"]}]}],"parameters":[{"description":"Object","name":"Object","supplementaryInformation":"Sprite","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"WithThreeJS::BoardProjection","type":"behavior"},{"description":"3D Object ID","name":"Id","type":"string"}],"objectGroups":[]},{"fullName":"Set Current 3D Texture ID","functionType":"Action","name":"SetCurrentTextureId","private":true,"sentence":"Set Current 3D Texture ID (_PARAM0_, ID: _PARAM2_)","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"WithThreeJS::BoardProjection::SetPropertyCurrentTextureId"},"parameters":["Object","Behavior","=","GetArgumentAsString(\"Id\")"]}]}],"parameters":[{"description":"Object","name":"Object","supplementaryInformation":"Sprite","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"WithThreeJS::BoardProjection","type":"behavior"},{"description":"3D Texture ID","name":"Id","type":"string"}],"objectGroups":[]}],"propertyDescriptors":[{"value":"","type":"String","label":"","description":"","group":"","extraInformation":[],"hidden":true,"name":"Id"},{"value":"true","type":"Boolean","label":"","description":"","group":"","extraInformation":[],"hidden":true,"name":"FirstFrame"},{"value":"","type":"String","label":"","description":"","group":"","extraInformation":[],"hidden":true,"name":"CurrentTextureId"},{"value":"true","type":"Boolean","label":"Hide 2D Object","description":"","group":"","extraInformation":[],"name":"Hide"},{"value":"0","type":"Number","label":"Alpha Channel Test","description":"Recommended values: 0 or 0.5. Default: 0.","group":"Texture","extraInformation":[],"name":"AlphaTest"},{"value":"true","type":"Boolean","label":"Anti-Aliasing","description":"","group":"Texture","extraInformation":["Antialiased","No Antialiasing"],"name":"AntiAliasing"},{"value":"Z Axis","type":"Choice","label":"Axis linked to 2D Object Angle","description":"Rotating a 2D object will rotate the 3D object around this axis.","group":"Angle","extraInformation":["X Axis","Y Axis","Z Axis"],"name":"AngleAxis"},{"value":"Vertical","type":"Choice","label":"Orientation","description":"For Horizontal, this 3D Object is rotated -90 degrees around the X axis.","group":"Angle","extraInformation":["Vertical","Horizontal"],"name":"Orientation"},{"value":"0","type":"Number","label":"Depth for Bounding Box Collision","description":"Unit: Pixel","group":"Collision","extraInformation":[],"name":"Depth"},{"value":"","type":"Boolean","label":"Cast Shadow","description":"If both \"Cast Shadow\" and \"Receive Shadow\" are enabled, striped patterns are likely to occur in the shadow.","group":"Shadow","extraInformation":[],"name":"CastShadow"},{"value":"","type":"Boolean","label":"Receive Shadow","description":"If both \"Cast Shadow\" and \"Receive Shadow\" are enabled, striped patterns are likely to occur in the shadow.","group":"Shadow","extraInformation":[],"name":"ReceiveShadow"}],"sharedPropertyDescriptors":[]},{"description":"Create 3D Plane from Tiled Sprite object. Moving that Tiled Sprite will also move the 3D Object.","fullName":"3D Plane Projection from Tiled Sprite","name":"PlaneProjectionFromTiled","objectType":"TiledSpriteObject::TiledSprite","eventsFunctions":[{"fullName":"","functionType":"Action","name":"doStepPostEvents","sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"WithThreeJS::PlaneProjectionFromTiled::PropertyFirstFrame"},"parameters":["Object","Behavior"]}],"actions":[{"type":{"value":"WithThreeJS::PlaneProjectionFromTiled::SetPropertyFirstFrame"},"parameters":["Object","Behavior","no"]}],"events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["if (!gdjs.__WithThreeJS.has(\"Renderer\")) {","    console.warn(\"!\");","    return;","}","if (!gdjs.__WithThreeJS.has(\"Textures\")) {","    gdjs.__WithThreeJS.set(\"Textures\", new Map());","}","const Scene = gdjs.__WithThreeJS.get(\"Scene\");","let Textures = gdjs.__WithThreeJS.get(\"Textures\");","//","const Behavior = objects[0].getBehavior(\"PlaneProjectionFromTiled\");","const Id = objects[0].name + objects[0].id;","// const X = objects[0].getCenterXInScene();","// const Y = objects[0].getCenterYInScene();","// const Z = objects[0].zOrder;","const Width = objects[0].getWidth();","const Height = objects[0].getHeight();","const ProjectionScale = gdjs.__WithThreeJS.get(\"ProjectionScale\");","const ViewMode = gdjs.__WithThreeJS.get(\"ViewMode\");","const AlphaTest = Behavior.AlphaTest();","const Transparent = AlphaTest !== 0;","const AntiAliasing = Behavior.AntiAliasing();","const Depth = Behavior.Depth();","let Blend = THREE.NormalBlending;","if (Behavior.Blend() == \"Additive\") {","    Blend = THREE.AdditiveBlending;","} else if (Behavior.Blend() == \"Subtractive\") {","    Blend = THREE.SubtractiveBlending;","} else if (Behavior.Blend() == \"Multiply\") {","    Blend = THREE.MultiplyBlending;","}","const CastShadow = Behavior.CastShadow();","const ReceiveShadow = Behavior.ReceiveShadow();","// const Opacity = 1.0;","//","//","const Resource = objects[0].getRendererObject().texture.baseTexture.resource;","const TextureWidth = Resource.width;","const TextureHeight = Resource.height;","//","// ","// Plane  FrontRear ","//","const RepeatU = Width / TextureWidth;","const RepeatV = Height / TextureHeight;","const TextureId = \"_\" + Id + \"_\" + Resource.url;","Behavior.SetTextureId(TextureId);","Behavior.SetOffsetV(1 - (RepeatV % 1));","//","const Texture = new THREE.Texture();","Texture.image = Resource.source;","Texture.wrapS = THREE.RepeatWrapping;","Texture.wrapT = THREE.RepeatWrapping;","if (!AntiAliasing) {","    Texture.magFilter = THREE.NearestFilter;// THREE.LinearFilter","    Texture.minFilter = THREE.NearestFilter;// THREE.LinearMipmapLinearFilter","}","Texture.repeat.set(RepeatU, RepeatV);","Texture.colorSpace = THREE.SRGBColorSpace;","Texture.needsUpdate = true;//","Textures.set(TextureId, Texture);","//","// const Material = new THREE.MeshBasicMaterial({map: Texture, side: THREE.DoubleSide, transparent:Transparent, alphaTest:AlphaTest, blending:Blend});","const Material = new THREE.MeshLambertMaterial({map: Texture, side: THREE.DoubleSide, transparent:Transparent, alphaTest:AlphaTest, blending:Blend});","const Geometry = new THREE.PlaneGeometry(Width * ProjectionScale, Height * ProjectionScale, 1, 1);","Geometry.computeBoundingBox();","Geometry.boundingBox.expandByVector(new THREE.Vector3(0, 0, (Depth * ProjectionScale) / 2));","const Obj = new THREE.Mesh(Geometry, Material);","Obj.name = Id;","Obj.castShadow = CastShadow;","Obj.receiveShadow = ReceiveShadow;","Obj.userData.Use3DProjectionBehavior = true;","Behavior.SetId(Id);","Scene.add(Obj);","",""],"parameterObjects":"Object","useStrict":true,"eventsSheetExpanded":true},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"WithThreeJS::PlaneProjectionFromTiled::PropertyHide"},"parameters":["Object","Behavior"]}],"actions":[{"type":{"value":"Cache"},"parameters":["Object"]}]}]},{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["if (!gdjs.__WithThreeJS.has(\"Renderer\")) {\r","    console.warn(\"!\");\r","    return;\r","}\r","if (!gdjs.__WithThreeJS.has(\"Textures\")) {\r","    console.warn(\"!\");\r","    return;\r","}\r","const Scene = gdjs.__WithThreeJS.get(\"Scene\");\r","let Textures = gdjs.__WithThreeJS.get(\"Textures\");\r","//\r","const Behavior = objects[0].getBehavior(\"PlaneProjectionFromTiled\");\r","const Id = Behavior.Id();\r","const X = objects[0].getCenterXInScene();\r","const Y = objects[0].getCenterYInScene();\r","const Z = objects[0].zOrder;\r","const ProjectionScale = gdjs.__WithThreeJS.get(\"ProjectionScale\");\r","const ViewMode = gdjs.__WithThreeJS.get(\"ViewMode\");\r","const Rotate90 = Behavior.Rotate90();\r","//\r","const Obj = gdjs.__WithThreeJS.get(\"SearchObject\")(Id);\r","if (!Obj) {\r","    console.warn(\"3D Object not found: \" + Id);\r","    return;\r","}\r","// Move & Rotate\r","const Angle = objects[0].angle;\r","if (ViewMode == \"Top Down\") {\r","    Obj.position.set(X * ProjectionScale, Z * ProjectionScale, Y * ProjectionScale);\r","    if (Rotate90) {\r","        Obj.rotation.set(gdjs.toRad(0), gdjs.toRad(Angle * -1), gdjs.toRad(0));\r","    } else {\r","        Obj.rotation.set(gdjs.toRad(-90), gdjs.toRad(0), gdjs.toRad(Angle * -1));\r","    }\r","} else {\r","    // Side\r","    Obj.position.set(X * ProjectionScale, -Y * ProjectionScale, Z * ProjectionScale);\r","    if (Rotate90) {\r","        Obj.rotation.set(gdjs.toRad(-90), gdjs.toRad(Angle), gdjs.toRad(0));\r","    } else {\r","        Obj.rotation.set(gdjs.toRad(0), gdjs.toRad(0), gdjs.toRad(Angle * -1));\r","    }\r","}\r","// Opacity\r","const Opacity = objects[0].getOpacity() / 255;\r","if (!Obj.material.transparent) {\r","    if (Obj.material.alphaTest !== 0 || Opacity !== 1) {\r","        Obj.material.transparent = true;\r","        Obj.material.needsUpdate = true;\r","    }\r","}\r","Obj.material.opacity = Opacity;\r","// Offset\r","const Texture = Textures.get(Behavior.TextureId());\r","const TextureWidth = Texture.image.width;\r","const TextureHeight = Texture.image.height;\r","Texture.offset.set(objects[0].getXOffset() / TextureWidth, -(objects[0].getYOffset() / TextureHeight) + Behavior.OffsetV());\r","\r",""],"parameterObjects":"Object","useStrict":true,"eventsSheetExpanded":true}],"parameters":[{"description":"Object","name":"Object","supplementaryInformation":"TiledSpriteObject::TiledSprite","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"WithThreeJS::PlaneProjectionFromTiled","type":"behavior"}],"objectGroups":[]},{"fullName":"","functionType":"Action","name":"onDestroy","sentence":"","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["// 3D\r","// FirstFrame == true  Id \r","const Behavior = objects[0].getBehavior(\"PlaneProjectionFromTiled\");\r","const Id = Behavior.Id();\r","if (Id === \"\") {\r","    return;\r","}\r","//\r","if (!gdjs.__WithThreeJS.has(\"Renderer\")) {\r","    console.warn(\"!\");\r","    return;\r","}\r","if (!gdjs.__WithThreeJS.has(\"Textures\")) {\r","    gdjs.__WithThreeJS.set(\"Textures\", new Map());\r","}\r","const Scene = gdjs.__WithThreeJS.get(\"Scene\");\r","const Textures = gdjs.__WithThreeJS.get(\"Textures\");\r","const Obj = gdjs.__WithThreeJS.get(\"SearchObject\")(Id);\r","if (!Obj) {\r","    console.warn(\"3D Object not found.\");\r","    return;\r","}\r","//\r","const TextureId = Behavior.TextureId();\r","const Texture = Textures.get(TextureId);\r","// \r","Texture.dispose();\r","Textures.delete(TextureId);\r","gdjs.__WithThreeJS.get(\"DisposeChildren\")(Obj);\r","Obj.removeFromParent();\r","\r",""],"parameterObjects":"Object","useStrict":true,"eventsSheetExpanded":true}],"parameters":[{"description":"Object","name":"Object","supplementaryInformation":"TiledSpriteObject::TiledSprite","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"WithThreeJS::PlaneProjectionFromTiled","type":"behavior"}],"objectGroups":[]},{"fullName":"3D Object ID","functionType":"StringExpression","name":"Id","sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetReturnString"},"parameters":["Object.Behavior::PropertyId()"]}]}],"expressionType":{"type":"string"},"parameters":[{"description":"Object","name":"Object","supplementaryInformation":"TiledSpriteObject::TiledSprite","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"WithThreeJS::PlaneProjectionFromTiled","type":"behavior"}],"objectGroups":[]},{"fullName":"Alpha Channel Test","functionType":"Expression","name":"AlphaTest","sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetReturnNumber"},"parameters":["Object.Behavior::PropertyAlphaTest()"]}]}],"expressionType":{"type":"expression"},"parameters":[{"description":"Object","name":"Object","supplementaryInformation":"TiledSpriteObject::TiledSprite","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"WithThreeJS::PlaneProjectionFromTiled","type":"behavior"}],"objectGroups":[]},{"fullName":"Blend Mode","functionType":"StringExpression","name":"Blend","sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetReturnString"},"parameters":["Object.Behavior::PropertyBlend()"]}]}],"expressionType":{"type":"string"},"parameters":[{"description":"Object","name":"Object","supplementaryInformation":"TiledSpriteObject::TiledSprite","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"WithThreeJS::PlaneProjectionFromTiled","type":"behavior"}],"objectGroups":[]},{"fullName":"Is Anti-Aliasing","functionType":"Condition","name":"AntiAliasing","private":true,"sentence":"Is Anti-Aliasing _PARAM0_","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"WithThreeJS::PlaneProjectionFromTiled::PropertyAntiAliasing"},"parameters":["Object","Behavior"]}],"actions":[{"type":{"value":"SetReturnBoolean"},"parameters":["True"]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"inverted":true,"value":"WithThreeJS::PlaneProjectionFromTiled::PropertyAntiAliasing"},"parameters":["Object","Behavior"]}],"actions":[{"type":{"value":"SetReturnBoolean"},"parameters":["False"]}]}],"parameters":[{"description":"Object","name":"Object","supplementaryInformation":"TiledSpriteObject::TiledSprite","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"WithThreeJS::PlaneProjectionFromTiled","type":"behavior"}],"objectGroups":[]},{"fullName":"Is Rotate -90 Degrees","functionType":"Condition","name":"Rotate90","private":true,"sentence":"Is Rotate -90 Degrees _PARAM0_","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"WithThreeJS::PlaneProjectionFromTiled::PropertyRotate90"},"parameters":["Object","Behavior"]}],"actions":[{"type":{"value":"SetReturnBoolean"},"parameters":["True"]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"inverted":true,"value":"WithThreeJS::PlaneProjectionFromTiled::PropertyRotate90"},"parameters":["Object","Behavior"]}],"actions":[{"type":{"value":"SetReturnBoolean"},"parameters":["False"]}]}],"parameters":[{"description":"Object","name":"Object","supplementaryInformation":"TiledSpriteObject::TiledSprite","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"WithThreeJS::PlaneProjectionFromTiled","type":"behavior"}],"objectGroups":[]},{"fullName":"Is Cast Shadow","functionType":"Condition","name":"CastShadow","private":true,"sentence":"Is Cast Shadow _PARAM0_","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"WithThreeJS::PlaneProjectionFromTiled::PropertyCastShadow"},"parameters":["Object","Behavior"]}],"actions":[{"type":{"value":"SetReturnBoolean"},"parameters":["True"]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"inverted":true,"value":"WithThreeJS::PlaneProjectionFromTiled::PropertyCastShadow"},"parameters":["Object","Behavior"]}],"actions":[{"type":{"value":"SetReturnBoolean"},"parameters":["False"]}]}],"parameters":[{"description":"Object","name":"Object","supplementaryInformation":"TiledSpriteObject::TiledSprite","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"WithThreeJS::PlaneProjectionFromTiled","type":"behavior"}],"objectGroups":[]},{"fullName":"Is Receive Shadow","functionType":"Condition","name":"ReceiveShadow","private":true,"sentence":"Is Receive Shadow _PARAM0_","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"WithThreeJS::PlaneProjectionFromTiled::PropertyReceiveShadow"},"parameters":["Object","Behavior"]}],"actions":[{"type":{"value":"SetReturnBoolean"},"parameters":["True"]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"inverted":true,"value":"WithThreeJS::PlaneProjectionFromTiled::PropertyReceiveShadow"},"parameters":["Object","Behavior"]}],"actions":[{"type":{"value":"SetReturnBoolean"},"parameters":["False"]}]}],"parameters":[{"description":"Object","name":"Object","supplementaryInformation":"TiledSpriteObject::TiledSprite","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"WithThreeJS::PlaneProjectionFromTiled","type":"behavior"}],"objectGroups":[]},{"fullName":"3D Texture ID","functionType":"StringExpression","name":"TextureId","private":true,"sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetReturnString"},"parameters":["Object.Behavior::PropertyTextureId()"]}]}],"expressionType":{"type":"string"},"parameters":[{"description":"Object","name":"Object","supplementaryInformation":"TiledSpriteObject::TiledSprite","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"WithThreeJS::PlaneProjectionFromTiled","type":"behavior"}],"objectGroups":[]},{"fullName":"Offset V","functionType":"Expression","name":"OffsetV","private":true,"sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetReturnNumber"},"parameters":["Object.Behavior::PropertyOffsetV()"]}]}],"expressionType":{"type":"expression"},"parameters":[{"description":"Object","name":"Object","supplementaryInformation":"TiledSpriteObject::TiledSprite","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"WithThreeJS::PlaneProjectionFromTiled","type":"behavior"}],"objectGroups":[]},{"fullName":"Depth for Bounding Box Collision","functionType":"Expression","name":"Depth","private":true,"sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetReturnNumber"},"parameters":["Object.Behavior::PropertyDepth()"]}]}],"expressionType":{"type":"expression"},"parameters":[{"description":"Object","name":"Object","supplementaryInformation":"TiledSpriteObject::TiledSprite","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"WithThreeJS::PlaneProjectionFromTiled","type":"behavior"}],"objectGroups":[]},{"fullName":"Set 3D Object ID","functionType":"Action","name":"SetId","private":true,"sentence":"Set 3D Object ID (_PARAM0_, ID: _PARAM2_)","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"WithThreeJS::PlaneProjectionFromTiled::SetPropertyId"},"parameters":["Object","Behavior","=","GetArgumentAsString(\"Id\")"]}]}],"parameters":[{"description":"Object","name":"Object","supplementaryInformation":"TiledSpriteObject::TiledSprite","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"WithThreeJS::PlaneProjectionFromTiled","type":"behavior"},{"description":"3D Object ID","name":"Id","type":"string"}],"objectGroups":[]},{"fullName":"Set 3D Texture ID","functionType":"Action","name":"SetTextureId","private":true,"sentence":"Set 3D Texture ID (_PARAM0_, ID: _PARAM2_)","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"WithThreeJS::PlaneProjectionFromTiled::SetPropertyTextureId"},"parameters":["Object","Behavior","=","GetArgumentAsString(\"Id\")"]}]}],"parameters":[{"description":"Object","name":"Object","supplementaryInformation":"TiledSpriteObject::TiledSprite","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"WithThreeJS::PlaneProjectionFromTiled","type":"behavior"},{"description":"3D Texture ID","name":"Id","type":"string"}],"objectGroups":[]},{"fullName":"Set Offset V","functionType":"Action","name":"SetOffsetV","private":true,"sentence":"Set Offset V (_PARAM0_, Value: _PARAM2_)","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"WithThreeJS::PlaneProjectionFromTiled::SetPropertyOffsetV"},"parameters":["Object","Behavior","=","GetArgumentAsNumber(\"Value\")"]}]}],"parameters":[{"description":"Object","name":"Object","supplementaryInformation":"TiledSpriteObject::TiledSprite","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"WithThreeJS::PlaneProjectionFromTiled","type":"behavior"},{"description":"Offset Value","name":"Value","type":"expression"}],"objectGroups":[]}],"propertyDescriptors":[{"value":"","type":"String","label":"","description":"","group":"","extraInformation":[],"hidden":true,"name":"Id"},{"value":"true","type":"Boolean","label":"","description":"","group":"","extraInformation":[],"hidden":true,"name":"FirstFrame"},{"value":"true","type":"Boolean","label":"Hide 2D Object","description":"","group":"","extraInformation":[],"name":"Hide"},{"value":"0","type":"Number","label":"Alpha Channel Test","description":"Recommended values: 0 or 0.5. Default: 0.","group":"Texture","extraInformation":[],"name":"AlphaTest"},{"value":"true","type":"Boolean","label":"Anti-Aliasing","description":"","group":"Texture","extraInformation":["Antialiased","No Antialiasing"],"name":"AntiAliasing"},{"value":"Normal","type":"Choice","label":"Blend Mode","description":"","group":"Texture","extraInformation":["Normal","Additive","Subtractive","Multiply"],"name":"Blend"},{"value":"","type":"Boolean","label":"Rotate -90 Degrees Around X Axis","description":"If checked, this 3D Object is rotated -90 degrees around the X axis. Note that this makes it less compatible with 2D collisions.","group":"Angle","extraInformation":[],"name":"Rotate90"},{"value":"0","type":"Number","label":"Depth for Bounding Box Collision","description":"Unit: Pixel","group":"Collision","extraInformation":[],"name":"Depth"},{"value":"","type":"Boolean","label":"Cast Shadow","description":"If both \"Cast Shadow\" and \"Receive Shadow\" are enabled, striped patterns are likely to occur in the shadow.","group":"Shadow","extraInformation":[],"name":"CastShadow"},{"value":"","type":"Boolean","label":"Receive Shadow","description":"If both \"Cast Shadow\" and \"Receive Shadow\" are enabled, striped patterns are likely to occur in the shadow.","group":"Shadow","extraInformation":[],"name":"ReceiveShadow"},{"value":"","type":"String","label":"","description":"","group":"","extraInformation":[],"hidden":true,"name":"TextureId"},{"value":"","type":"Number","label":"","description":"","group":"","extraInformation":[],"hidden":true,"name":"OffsetV"}],"sharedPropertyDescriptors":[]},{"description":"Create 3D Box from Tiled Sprite object. Moving that Tiled Sprite will also move the 3D Object.","fullName":"3D Box Projection from Tiled Sprite","name":"BoxProjectionFromTiled","objectType":"TiledSpriteObject::TiledSprite","eventsFunctions":[{"fullName":"","functionType":"Action","name":"doStepPostEvents","sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"WithThreeJS::BoxProjectionFromTiled::PropertyFirstFrame"},"parameters":["Object","Behavior"]}],"actions":[{"type":{"value":"WithThreeJS::BoxProjectionFromTiled::SetPropertyFirstFrame"},"parameters":["Object","Behavior","no"]}],"events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["if (!gdjs.__WithThreeJS.has(\"Renderer\")) {","    console.warn(\"!\");","    return;","}","if (!gdjs.__WithThreeJS.has(\"Textures\")) {","    gdjs.__WithThreeJS.set(\"Textures\", new Map());","}","const Scene = gdjs.__WithThreeJS.get(\"Scene\");","let Textures = gdjs.__WithThreeJS.get(\"Textures\");","//","const Behavior = objects[0].getBehavior(\"BoxProjectionFromTiled\");","const Id = objects[0].name + objects[0].id;","// const X = objects[0].getCenterXInScene();","// const Y = objects[0].getCenterYInScene();","// const Z = objects[0].zOrder;","const Width = objects[0].getWidth();","const Height = objects[0].getHeight();","const Depth = Behavior.Depth();","const ProjectionScale = gdjs.__WithThreeJS.get(\"ProjectionScale\");","const ViewMode = gdjs.__WithThreeJS.get(\"ViewMode\");","const AlphaTest = Behavior.AlphaTest();","const Transparent = AlphaTest !== 0;","const AntiAliasing = Behavior.AntiAliasing();","let Blend = THREE.NormalBlending;","if (Behavior.Blend() == \"Additive\") {","    Blend = THREE.AdditiveBlending;","} else if (Behavior.Blend() == \"Subtractive\") {","    Blend = THREE.SubtractiveBlending;","} else if (Behavior.Blend() == \"Multiply\") {","    Blend = THREE.MultiplyBlending;","}","const CastShadow = Behavior.CastShadow();","const ReceiveShadow = Behavior.ReceiveShadow();","// const Opacity = 1.0;","//","//","const Resource = objects[0].getRendererObject().texture.baseTexture.resource;","const TextureWidth = Resource.width;","const TextureHeight = Resource.height;","//","// ","// FrontRear 1 LeftRight, TopBottom, FrontRear 3","// FrontRear ","let FRRepeatU, FRRepeatV;","if (ViewMode == \"Top Down\") {","    FRRepeatU = Width / TextureWidth;","    FRRepeatV = Depth / TextureHeight;","} else {","    // Side","    FRRepeatU = Width / TextureWidth;","    FRRepeatV = Height / TextureHeight;","}","const FRTextureId = \"_\" + Id + \"_\" + Resource.url + \"_FR\";","Behavior.SetFRTextureId(FRTextureId);","Behavior.SetFROffsetV(1 - (FRRepeatV % 1));","//","const FRTexture = new THREE.Texture();","FRTexture.image = Resource.source;","FRTexture.wrapS = THREE.RepeatWrapping;","FRTexture.wrapT = THREE.RepeatWrapping;","if (!AntiAliasing) {","    FRTexture.magFilter = THREE.NearestFilter;// THREE.LinearFilter","    FRTexture.minFilter = THREE.NearestFilter;// THREE.LinearMipmapLinearFilter","}","FRTexture.repeat.set(FRRepeatU, FRRepeatV);","FRTexture.colorSpace = THREE.SRGBColorSpace;","FRTexture.needsUpdate = true;//","Textures.set(FRTextureId, FRTexture);","// const FRMaterial = new THREE.MeshBasicMaterial({map: FRTexture, transparent:Transparent, alphaTest:AlphaTest, blending:Blend});","const FRMaterial = new THREE.MeshLambertMaterial({map: FRTexture, transparent:Transparent, alphaTest:AlphaTest, blending:Blend});","//","// 132","const IsCube = (Width == Height && Width == Depth);","Behavior.SetIsCube(IsCube);","//  Material ","let Material;","if (IsCube) {","    Material = FRMaterial;","} else {","    // LeftRight","    let LRRepeatU, LRRepeatV;","    if (ViewMode == \"Top Down\") {","        LRRepeatU = Height / TextureWidth;","        LRRepeatV = Depth / TextureHeight;","    } else {","        // Side","        LRRepeatU = Depth / TextureWidth;","        LRRepeatV = Height / TextureHeight;","    }","    const LRTextureId = \"_\" + Id + \"_\" + Resource.url + \"_LR\";","    Behavior.SetLRTextureId(LRTextureId);","    Behavior.SetLROffsetV(1 - (LRRepeatV % 1));","    //","    const LRTexture = FRTexture.clone();","    LRTexture.repeat.set(LRRepeatU, LRRepeatV);","    LRTexture.colorSpace = THREE.SRGBColorSpace;","    LRTexture.needsUpdate = true;//","    Textures.set(LRTextureId, LRTexture);","    // const LRMaterial = new THREE.MeshBasicMaterial({map: LRTexture, transparent:Transparent, alphaTest:AlphaTest, blending:Blend});","    const LRMaterial = new THREE.MeshLambertMaterial({map: LRTexture, transparent:Transparent, alphaTest:AlphaTest, blending:Blend});","    //","    // TopBottom","    let TBRepeatU, TBRepeatV;","    if (ViewMode == \"Top Down\") {","        TBRepeatU = Width / TextureWidth;","        TBRepeatV = Height / TextureHeight;","    } else {","        // Side","        TBRepeatU = Width / TextureWidth;","        TBRepeatV = Depth / TextureHeight;","    }","    const TBTextureId = \"_\" + Id + \"_\" + Resource.url + \"_TB\";","    Behavior.SetTBTextureId(TBTextureId);","    Behavior.SetTBOffsetV(1 - (TBRepeatV % 1));","    //","    const TBTexture = FRTexture.clone();","    TBTexture.repeat.set(TBRepeatU, TBRepeatV);","    TBTexture.colorSpace = THREE.SRGBColorSpace;","    TBTexture.needsUpdate = true;//","    Textures.set(TBTextureId, TBTexture);","    // const TBMaterial = new THREE.MeshBasicMaterial({map: TBTexture, transparent:Transparent, alphaTest:AlphaTest, blending:Blend});","    const TBMaterial = new THREE.MeshLambertMaterial({map: TBTexture, transparent:Transparent, alphaTest:AlphaTest, blending:Blend});","    //","    Material = [LRMaterial, LRMaterial, TBMaterial, TBMaterial, FRMaterial, FRMaterial];","}","//","let Geometry;","if (ViewMode == \"Top Down\") {","    Geometry = new THREE.BoxGeometry(Width * ProjectionScale, Depth * ProjectionScale, Height * ProjectionScale);","} else {","    // Side","    Geometry = new THREE.BoxGeometry(Width * ProjectionScale, Height * ProjectionScale, Depth * ProjectionScale);","}","Geometry.computeBoundingBox();","const Obj = new THREE.Mesh(Geometry, Material);","Obj.name = Id;","Obj.castShadow = CastShadow;","Obj.receiveShadow = ReceiveShadow;","Obj.userData.Use3DProjectionBehavior = true;","Behavior.SetId(Id);","Scene.add(Obj);","",""],"parameterObjects":"Object","useStrict":true,"eventsSheetExpanded":true},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"WithThreeJS::BoxProjectionFromTiled::PropertyHide"},"parameters":["Object","Behavior"]}],"actions":[{"type":{"value":"Cache"},"parameters":["Object"]}]}]},{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["if (!gdjs.__WithThreeJS.has(\"Renderer\")) {\r","    console.warn(\"!\");\r","    return;\r","}\r","if (!gdjs.__WithThreeJS.has(\"Textures\")) {\r","    console.warn(\"!\");\r","    return;\r","}\r","const Scene = gdjs.__WithThreeJS.get(\"Scene\");\r","let Textures = gdjs.__WithThreeJS.get(\"Textures\");\r","//\r","const Behavior = objects[0].getBehavior(\"BoxProjectionFromTiled\");\r","const Id = Behavior.Id();\r","const X = objects[0].getCenterXInScene();\r","const Y = objects[0].getCenterYInScene();\r","const Z = objects[0].zOrder;\r","const ProjectionScale = gdjs.__WithThreeJS.get(\"ProjectionScale\");//Behavior.ProjectionScale();\r","const ViewMode = gdjs.__WithThreeJS.get(\"ViewMode\");//Behavior.ViewMode();\r","const IsCube = Behavior.IsCube();\r","//\r","const Obj = gdjs.__WithThreeJS.get(\"SearchObject\")(Id);\r","if (!Obj) {\r","    console.warn(\"3D Object not found: \" + Id);\r","    return;\r","}\r","// Move & Rotate\r","const Angle = objects[0].angle;\r","if (ViewMode == \"Top Down\") {\r","    Obj.position.set(X * ProjectionScale, Z * ProjectionScale, Y * ProjectionScale);\r","    Obj.rotation.set(gdjs.toRad(0), gdjs.toRad(Angle * -1), gdjs.toRad(0));\r","} else if (ViewMode == \"Side\") {\r","    Obj.position.set(X * ProjectionScale, -Y * ProjectionScale, Z * ProjectionScale);\r","    Obj.rotation.set(gdjs.toRad(0), gdjs.toRad(0), gdjs.toRad(Angle * -1));\r","} else {\r","    Obj.position.set(X * ProjectionScale, Y * ProjectionScale, Z * ProjectionScale);\r","    Obj.rotation.set(gdjs.toRad(-90), gdjs.toRad(Angle * -1), gdjs.toRad(0));\r","}\r","// Opacity\r","const Opacity = objects[0].getOpacity() / 255;\r","if (Array.isArray(Obj.material)) {\r","    for (let i = 0; i < Obj.material.length; i++) {\r","        if (!Obj.material[i].transparent) {\r","            if (Obj.material[i].alphaTest !== 0 || Opacity !== 1) {\r","                Obj.material[i].transparent = true;\r","                Obj.material[i].needsUpdate = true;\r","            }\r","        }\r","        Obj.material[i].opacity = Opacity;\r","    }\r","} else {\r","    if (!Obj.material.transparent) {\r","        if (Obj.material.alphaTest !== 0 || Opacity !== 1) {\r","            Obj.material.transparent = true;\r","            Obj.material.needsUpdate = true;\r","        }\r","    }\r","    Obj.material.opacity = Opacity;\r","}\r","// Offset\r","const FRTexture = Textures.get(Behavior.FRTextureId());\r","const TextureWidth = FRTexture.image.width;\r","const TextureHeight = FRTexture.image.height;\r","FRTexture.offset.set(objects[0].getXOffset() / TextureWidth, -(objects[0].getYOffset() / TextureHeight) + Behavior.FROffsetV());\r","if (!IsCube) {\r","    const LRTexture = Textures.get(Behavior.LRTextureId());\r","    const TBTexture = Textures.get(Behavior.TBTextureId());\r","    LRTexture.offset.set(objects[0].getXOffset() / TextureWidth, -(objects[0].getYOffset() / TextureHeight) + Behavior.LROffsetV());\r","    TBTexture.offset.set(objects[0].getXOffset() / TextureWidth, -(objects[0].getYOffset() / TextureHeight) + Behavior.TBOffsetV());\r","}\r","\r","\r",""],"parameterObjects":"Object","useStrict":true,"eventsSheetExpanded":true}],"parameters":[{"description":"Object","name":"Object","supplementaryInformation":"TiledSpriteObject::TiledSprite","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"WithThreeJS::BoxProjectionFromTiled","type":"behavior"}],"objectGroups":[]},{"fullName":"","functionType":"Action","name":"onDestroy","sentence":"","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["// 3D\r","// FirstFrame == true  Id \r","const Behavior = objects[0].getBehavior(\"BoxProjectionFromTiled\");\r","const Id = Behavior.Id();\r","if (Id === \"\") {\r","    return;\r","}\r","//\r","if (!gdjs.__WithThreeJS.has(\"Renderer\")) {\r","    console.warn(\"!\");\r","    return;\r","}\r","if (!gdjs.__WithThreeJS.has(\"Textures\")) {\r","    gdjs.__WithThreeJS.set(\"Textures\", new Map());\r","}\r","const Scene = gdjs.__WithThreeJS.get(\"Scene\");\r","const Textures = gdjs.__WithThreeJS.get(\"Textures\");\r","const Obj = gdjs.__WithThreeJS.get(\"SearchObject\")(Id);\r","if (!Obj) {\r","    console.warn(\"3D Object not found.\");\r","    return;\r","}\r","//\r","const IsCube = Behavior.IsCube();\r","const FRTextureId = Behavior.FRTextureId();\r","const FRTexture = Textures.get(FRTextureId);\r","// \r","FRTexture.dispose();\r","Textures.delete(FRTextureId);\r","if (!IsCube) {\r","    const LRTextureId = Behavior.LRTextureId();\r","    const TBTextureId = Behavior.TBTextureId();\r","    const LRTexture = Textures.get(LRTextureId);\r","    const TBTexture = Textures.get(TBTextureId);\r","    LRTexture.dispose();\r","    TBTexture.dispose();\r","    Textures.delete(LRTextureId);\r","    Textures.delete(TBTextureId);\r","}\r","//\r","gdjs.__WithThreeJS.get(\"DisposeChildren\")(Obj);\r","Obj.removeFromParent();\r","\r",""],"parameterObjects":"Object","useStrict":true,"eventsSheetExpanded":true}],"parameters":[{"description":"Object","name":"Object","supplementaryInformation":"TiledSpriteObject::TiledSprite","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"WithThreeJS::BoxProjectionFromTiled","type":"behavior"}],"objectGroups":[]},{"fullName":"3D Object ID","functionType":"StringExpression","name":"Id","sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetReturnString"},"parameters":["Object.Behavior::PropertyId()"]}]}],"expressionType":{"type":"string"},"parameters":[{"description":"Object","name":"Object","supplementaryInformation":"TiledSpriteObject::TiledSprite","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"WithThreeJS::BoxProjectionFromTiled","type":"behavior"}],"objectGroups":[]},{"fullName":"Depth","functionType":"Expression","name":"Depth","sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetReturnNumber"},"parameters":["Object.Behavior::PropertyDepth()"]}]}],"expressionType":{"type":"expression"},"parameters":[{"description":"Object","name":"Object","supplementaryInformation":"TiledSpriteObject::TiledSprite","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"WithThreeJS::BoxProjectionFromTiled","type":"behavior"}],"objectGroups":[]},{"fullName":"Alpha Channel Test","functionType":"Expression","name":"AlphaTest","sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetReturnNumber"},"parameters":["Object.Behavior::PropertyAlphaTest()"]}]}],"expressionType":{"type":"expression"},"parameters":[{"description":"Object","name":"Object","supplementaryInformation":"TiledSpriteObject::TiledSprite","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"WithThreeJS::BoxProjectionFromTiled","type":"behavior"}],"objectGroups":[]},{"fullName":"Blend Mode","functionType":"StringExpression","name":"Blend","sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetReturnString"},"parameters":["Object.Behavior::PropertyBlend()"]}]}],"expressionType":{"type":"string"},"parameters":[{"description":"Object","name":"Object","supplementaryInformation":"TiledSpriteObject::TiledSprite","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"WithThreeJS::BoxProjectionFromTiled","type":"behavior"}],"objectGroups":[]},{"fullName":"Is Anti-Aliasing","functionType":"Condition","name":"AntiAliasing","private":true,"sentence":"Is Anti-Aliasing _PARAM0_","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"WithThreeJS::BoxProjectionFromTiled::PropertyAntiAliasing"},"parameters":["Object","Behavior"]}],"actions":[{"type":{"value":"SetReturnBoolean"},"parameters":["True"]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"inverted":true,"value":"WithThreeJS::BoxProjectionFromTiled::PropertyAntiAliasing"},"parameters":["Object","Behavior"]}],"actions":[{"type":{"value":"SetReturnBoolean"},"parameters":["False"]}]}],"parameters":[{"description":"Object","name":"Object","supplementaryInformation":"TiledSpriteObject::TiledSprite","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"WithThreeJS::BoxProjectionFromTiled","type":"behavior"}],"objectGroups":[]},{"fullName":"Is Cube","functionType":"Condition","name":"IsCube","private":true,"sentence":"Is Cube _PARAM0_","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"WithThreeJS::BoxProjectionFromTiled::PropertyIsCube"},"parameters":["Object","Behavior"]}],"actions":[{"type":{"value":"SetReturnBoolean"},"parameters":["True"]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"inverted":true,"value":"WithThreeJS::BoxProjectionFromTiled::PropertyIsCube"},"parameters":["Object","Behavior"]}],"actions":[{"type":{"value":"SetReturnBoolean"},"parameters":["False"]}]}],"parameters":[{"description":"Object","name":"Object","supplementaryInformation":"TiledSpriteObject::TiledSprite","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"WithThreeJS::BoxProjectionFromTiled","type":"behavior"}],"objectGroups":[]},{"fullName":"Is Cast Shadow","functionType":"Condition","name":"CastShadow","private":true,"sentence":"Is Cast Shadow _PARAM0_","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"WithThreeJS::BoxProjectionFromTiled::PropertyCastShadow"},"parameters":["Object","Behavior"]}],"actions":[{"type":{"value":"SetReturnBoolean"},"parameters":["True"]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"inverted":true,"value":"WithThreeJS::BoxProjectionFromTiled::PropertyCastShadow"},"parameters":["Object","Behavior"]}],"actions":[{"type":{"value":"SetReturnBoolean"},"parameters":["False"]}]}],"parameters":[{"description":"Object","name":"Object","supplementaryInformation":"TiledSpriteObject::TiledSprite","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"WithThreeJS::BoxProjectionFromTiled","type":"behavior"}],"objectGroups":[]},{"fullName":"Is Receive Shadow","functionType":"Condition","name":"ReceiveShadow","private":true,"sentence":"Is Receive Shadow _PARAM0_","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"WithThreeJS::BoxProjectionFromTiled::PropertyReceiveShadow"},"parameters":["Object","Behavior"]}],"actions":[{"type":{"value":"SetReturnBoolean"},"parameters":["True"]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"inverted":true,"value":"WithThreeJS::BoxProjectionFromTiled::PropertyReceiveShadow"},"parameters":["Object","Behavior"]}],"actions":[{"type":{"value":"SetReturnBoolean"},"parameters":["False"]}]}],"parameters":[{"description":"Object","name":"Object","supplementaryInformation":"TiledSpriteObject::TiledSprite","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"WithThreeJS::BoxProjectionFromTiled","type":"behavior"}],"objectGroups":[]},{"fullName":"TopBottom 3D Texture ID","functionType":"StringExpression","name":"TBTextureId","private":true,"sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetReturnString"},"parameters":["Object.Behavior::PropertyTBTextureId()"]}]}],"expressionType":{"type":"string"},"parameters":[{"description":"Object","name":"Object","supplementaryInformation":"TiledSpriteObject::TiledSprite","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"WithThreeJS::BoxProjectionFromTiled","type":"behavior"}],"objectGroups":[]},{"fullName":"LeftRight 3D Texture ID","functionType":"StringExpression","name":"LRTextureId","private":true,"sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetReturnString"},"parameters":["Object.Behavior::PropertyLRTextureId()"]}]}],"expressionType":{"type":"string"},"parameters":[{"description":"Object","name":"Object","supplementaryInformation":"TiledSpriteObject::TiledSprite","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"WithThreeJS::BoxProjectionFromTiled","type":"behavior"}],"objectGroups":[]},{"fullName":"FrontRear 3D Texture ID","functionType":"StringExpression","name":"FRTextureId","private":true,"sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetReturnString"},"parameters":["Object.Behavior::PropertyFRTextureId()"]}]}],"expressionType":{"type":"string"},"parameters":[{"description":"Object","name":"Object","supplementaryInformation":"TiledSpriteObject::TiledSprite","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"WithThreeJS::BoxProjectionFromTiled","type":"behavior"}],"objectGroups":[]},{"fullName":"TopBottom Offset V","functionType":"Expression","name":"TBOffsetV","private":true,"sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetReturnNumber"},"parameters":["Object.Behavior::PropertyTBOffsetV()"]}]}],"expressionType":{"type":"expression"},"parameters":[{"description":"Object","name":"Object","supplementaryInformation":"TiledSpriteObject::TiledSprite","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"WithThreeJS::BoxProjectionFromTiled","type":"behavior"}],"objectGroups":[]},{"fullName":"LeftRight Offset V","functionType":"Expression","name":"LROffsetV","private":true,"sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetReturnNumber"},"parameters":["Object.Behavior::PropertyLROffsetV()"]}]}],"expressionType":{"type":"expression"},"parameters":[{"description":"Object","name":"Object","supplementaryInformation":"TiledSpriteObject::TiledSprite","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"WithThreeJS::BoxProjectionFromTiled","type":"behavior"}],"objectGroups":[]},{"fullName":"FrontRear Offset V","functionType":"Expression","name":"FROffsetV","private":true,"sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetReturnNumber"},"parameters":["Object.Behavior::PropertyFROffsetV()"]}]}],"expressionType":{"type":"expression"},"parameters":[{"description":"Object","name":"Object","supplementaryInformation":"TiledSpriteObject::TiledSprite","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"WithThreeJS::BoxProjectionFromTiled","type":"behavior"}],"objectGroups":[]},{"fullName":"Set 3D Object ID","functionType":"Action","name":"SetId","private":true,"sentence":"Set 3D Object ID (_PARAM0_, ID: _PARAM2_)","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"WithThreeJS::BoxProjectionFromTiled::SetPropertyId"},"parameters":["Object","Behavior","=","GetArgumentAsString(\"Id\")"]}]}],"parameters":[{"description":"Object","name":"Object","supplementaryInformation":"TiledSpriteObject::TiledSprite","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"WithThreeJS::BoxProjectionFromTiled","type":"behavior"},{"description":"3D Object ID","name":"Id","type":"string"}],"objectGroups":[]},{"fullName":"Set Is Cube","functionType":"Action","name":"SetIsCube","private":true,"sentence":"Set Is Cube (_PARAM0_ Cube: _PARAM2_)","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"GetArgumentAsBoolean"},"parameters":["\"Cube\""]}],"actions":[{"type":{"value":"WithThreeJS::BoxProjectionFromTiled::SetPropertyIsCube"},"parameters":["Object","Behavior","yes"]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"inverted":true,"value":"GetArgumentAsBoolean"},"parameters":["\"Cube\""]}],"actions":[{"type":{"value":"WithThreeJS::BoxProjectionFromTiled::SetPropertyIsCube"},"parameters":["Object","Behavior","no"]}]}],"parameters":[{"description":"Object","name":"Object","supplementaryInformation":"TiledSpriteObject::TiledSprite","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"WithThreeJS::BoxProjectionFromTiled","type":"behavior"},{"description":"Cube","name":"Cube","type":"trueorfalse"}],"objectGroups":[]},{"fullName":"Set TopBottom 3D Texture ID","functionType":"Action","name":"SetTBTextureId","private":true,"sentence":"Set TopBottom 3D Texture ID (_PARAM0_, ID: _PARAM2_)","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"WithThreeJS::BoxProjectionFromTiled::SetPropertyTBTextureId"},"parameters":["Object","Behavior","=","GetArgumentAsString(\"Id\")"]}]}],"parameters":[{"description":"Object","name":"Object","supplementaryInformation":"TiledSpriteObject::TiledSprite","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"WithThreeJS::BoxProjectionFromTiled","type":"behavior"},{"description":"3D Texture ID","name":"Id","type":"string"}],"objectGroups":[]},{"fullName":"Set LeftRight 3D Texture ID","functionType":"Action","name":"SetLRTextureId","private":true,"sentence":"Set LeftRight 3D Texture ID (_PARAM0_, ID: _PARAM2_)","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"WithThreeJS::BoxProjectionFromTiled::SetPropertyLRTextureId"},"parameters":["Object","Behavior","=","GetArgumentAsString(\"Id\")"]}]}],"parameters":[{"description":"Object","name":"Object","supplementaryInformation":"TiledSpriteObject::TiledSprite","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"WithThreeJS::BoxProjectionFromTiled","type":"behavior"},{"description":"3D Texture ID","name":"Id","type":"string"}],"objectGroups":[]},{"fullName":"Set FrontRear 3D Texture ID","functionType":"Action","name":"SetFRTextureId","private":true,"sentence":"Set FrontRear 3D Texture ID (_PARAM0_, ID: _PARAM2_)","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"WithThreeJS::BoxProjectionFromTiled::SetPropertyFRTextureId"},"parameters":["Object","Behavior","=","GetArgumentAsString(\"Id\")"]}]}],"parameters":[{"description":"Object","name":"Object","supplementaryInformation":"TiledSpriteObject::TiledSprite","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"WithThreeJS::BoxProjectionFromTiled","type":"behavior"},{"description":"3D Texture ID","name":"Id","type":"string"}],"objectGroups":[]},{"fullName":"Set TopBottom Offset V","functionType":"Action","name":"SetTBOffsetV","private":true,"sentence":"Set TopBottom Offset V (_PARAM0_, Value: _PARAM2_)","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"WithThreeJS::BoxProjectionFromTiled::SetPropertyTBOffsetV"},"parameters":["Object","Behavior","=","GetArgumentAsNumber(\"Value\")"]}]}],"parameters":[{"description":"Object","name":"Object","supplementaryInformation":"TiledSpriteObject::TiledSprite","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"WithThreeJS::BoxProjectionFromTiled","type":"behavior"},{"description":"Offset Value","name":"Value","type":"expression"}],"objectGroups":[]},{"fullName":"Set LeftRight Offset V","functionType":"Action","name":"SetLROffsetV","private":true,"sentence":"Set LeftRight Offset V (_PARAM0_, Value: _PARAM2_)","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"WithThreeJS::BoxProjectionFromTiled::SetPropertyLROffsetV"},"parameters":["Object","Behavior","=","GetArgumentAsNumber(\"Value\")"]}]}],"parameters":[{"description":"Object","name":"Object","supplementaryInformation":"TiledSpriteObject::TiledSprite","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"WithThreeJS::BoxProjectionFromTiled","type":"behavior"},{"description":"Offset Value","name":"Value","type":"expression"}],"objectGroups":[]},{"fullName":"Set FrontRear Offset V","functionType":"Action","name":"SetFROffsetV","private":true,"sentence":"Set FrontRear Offset V (_PARAM0_, Value: _PARAM2_)","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"WithThreeJS::BoxProjectionFromTiled::SetPropertyFROffsetV"},"parameters":["Object","Behavior","=","GetArgumentAsNumber(\"Value\")"]}]}],"parameters":[{"description":"Object","name":"Object","supplementaryInformation":"TiledSpriteObject::TiledSprite","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"WithThreeJS::BoxProjectionFromTiled","type":"behavior"},{"description":"Offset Value","name":"Value","type":"expression"}],"objectGroups":[]}],"propertyDescriptors":[{"value":"","type":"String","label":"","description":"","group":"","extraInformation":[],"hidden":true,"name":"Id"},{"value":"true","type":"Boolean","label":"","description":"","group":"","extraInformation":[],"hidden":true,"name":"FirstFrame"},{"value":"true","type":"Boolean","label":"Hide 2D Object","description":"","group":"","extraInformation":[],"name":"Hide"},{"value":"0","type":"Number","label":"Alpha Channel Test","description":"Recommended values: 0 or 0.5. Default: 0.","group":"Texture","extraInformation":[],"name":"AlphaTest"},{"value":"true","type":"Boolean","label":"Anti-Aliasing","description":"","group":"Texture","extraInformation":["Antialiased","No Antialiasing"],"name":"AntiAliasing"},{"value":"1","type":"Number","label":"Depth","description":"Unit: Pixel","group":"","extraInformation":[],"name":"Depth"},{"value":"","type":"Boolean","label":"","description":"","group":"","extraInformation":[],"hidden":true,"name":"IsCube"},{"value":"","type":"String","label":"","description":"","group":"","extraInformation":[],"hidden":true,"name":"TBTextureId"},{"value":"","type":"String","label":"","description":"","group":"","extraInformation":[],"hidden":true,"name":"LRTextureId"},{"value":"","type":"String","label":"","description":"","group":"","extraInformation":[],"hidden":true,"name":"FRTextureId"},{"value":"0","type":"Number","label":"","description":"","group":"","extraInformation":[],"hidden":true,"name":"TBOffsetV"},{"value":"","type":"Number","label":"","description":"","group":"","extraInformation":[],"hidden":true,"name":"LROffsetV"},{"value":"","type":"Number","label":"","description":"","group":"","extraInformation":[],"hidden":true,"name":"FROffsetV"},{"value":"Normal","type":"Choice","label":"Blend Mode","description":"","group":"Texture","extraInformation":["Normal","Additive","Subtractive","Multiply"],"name":"Blend"},{"value":"","type":"Boolean","label":"Cast Shadow","description":"If both \"Cast Shadow\" and \"Receive Shadow\" are enabled, striped patterns are likely to occur in the shadow.","group":"Shadow","extraInformation":[],"name":"CastShadow"},{"value":"","type":"Boolean","label":"Receive Shadow","description":"If both \"Cast Shadow\" and \"Receive Shadow\" are enabled, striped patterns are likely to occur in the shadow.","group":"Shadow","extraInformation":[],"name":"ReceiveShadow"}],"sharedPropertyDescriptors":[]},{"description":"Link a Sprite object and  a 3D Camera.","fullName":"Linked 3D Camera","name":"LinkedCamera","objectType":"Sprite","eventsFunctions":[{"fullName":"","functionType":"Action","name":"doStepPostEvents","sentence":"","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["if (!gdjs.__WithThreeJS.has(\"Renderer\")) {","    console.warn(\"!\");","    return;","}","const Behavior = objects[0].getBehavior(\"LinkedCamera\");","const Id = Behavior.Id();","const Camera = gdjs.__WithThreeJS.get(\"GetCamera\")(Id);","const Fov = Behavior.Fov();","const ProjectionScale = gdjs.__WithThreeJS.get(\"ProjectionScale\");","const ViewMode = gdjs.__WithThreeJS.get(\"ViewMode\");","const LinkAngle = Behavior.LinkAngle();","const Hide = Behavior.Hide();","const X = objects[0].getCenterXInScene();","const Y = objects[0].getCenterYInScene();","const Z = objects[0].zOrder;","//","if (ViewMode == \"Top Down\") {","    Camera.position.set(X * ProjectionScale, Z * ProjectionScale, Y * ProjectionScale);","} else {","    // Side","    Camera.position.set(X * ProjectionScale, -Y * ProjectionScale, Z * ProjectionScale);","}","//","if (LinkAngle) {","    const Angle = objects[0].angle;","    if (ViewMode == \"Top Down\") {","        Camera.rotation.set(gdjs.toRad(0), gdjs.toRad(Angle * -1 - 90), gdjs.toRad(0));","    } else {","        // Side","        Camera.rotation.set(gdjs.toRad(-Angle), gdjs.toRad(-90), gdjs.toRad(0), \"YXZ\");","    }","}","//","if (Camera.fov != Fov) {","    Camera.fov = Fov;","    Camera.updateProjectionMatrix();","}","//","objects[0].hide(Hide);","",""],"parameterObjects":"Object","useStrict":true,"eventsSheetExpanded":true}],"parameters":[{"description":"Object","name":"Object","supplementaryInformation":"Sprite","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"WithThreeJS::LinkedCamera","type":"behavior"}],"objectGroups":[]},{"fullName":"3D Camera ID","functionType":"Expression","name":"Id","sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetReturnNumber"},"parameters":["Object.Behavior::PropertyId()"]}]}],"expressionType":{"type":"expression"},"parameters":[{"description":"Object","name":"Object","supplementaryInformation":"Sprite","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"WithThreeJS::LinkedCamera","type":"behavior"}],"objectGroups":[]},{"fullName":"Field Of View","functionType":"Expression","name":"Fov","sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetReturnNumber"},"parameters":["Object.Behavior::PropertyFov()"]}]}],"expressionType":{"type":"expression"},"parameters":[{"description":"Object","name":"Object","supplementaryInformation":"Sprite","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"WithThreeJS::LinkedCamera","type":"behavior"}],"objectGroups":[]},{"fullName":"Is LinkAngle","functionType":"Condition","name":"LinkAngle","private":true,"sentence":"Is Link Angle _PARAM0_","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"WithThreeJS::LinkedCamera::PropertyLinkAngle"},"parameters":["Object","Behavior"]}],"actions":[{"type":{"value":"SetReturnBoolean"},"parameters":["True"]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"inverted":true,"value":"WithThreeJS::LinkedCamera::PropertyLinkAngle"},"parameters":["Object","Behavior"]}],"actions":[{"type":{"value":"SetReturnBoolean"},"parameters":["False"]}]}],"parameters":[{"description":"Object","name":"Object","supplementaryInformation":"Sprite","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"WithThreeJS::LinkedCamera","type":"behavior"}],"objectGroups":[]},{"fullName":"Is Hide","functionType":"Condition","name":"Hide","private":true,"sentence":"Is Hide _PARAM0_","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"WithThreeJS::LinkedCamera::PropertyHide"},"parameters":["Object","Behavior"]}],"actions":[{"type":{"value":"SetReturnBoolean"},"parameters":["True"]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"inverted":true,"value":"WithThreeJS::LinkedCamera::PropertyHide"},"parameters":["Object","Behavior"]}],"actions":[{"type":{"value":"SetReturnBoolean"},"parameters":["False"]}]}],"parameters":[{"description":"Object","name":"Object","supplementaryInformation":"Sprite","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"WithThreeJS::LinkedCamera","type":"behavior"}],"objectGroups":[]}],"propertyDescriptors":[{"value":"1","type":"Number","label":"3D Camera ID (1 to 4)","description":"Enter a number from 1 to 4. Up to four 3D Cameras can be installed. Use the \"Setup Multiple 3D Cameras\" action to switch 3D Cameras.","group":"","extraInformation":[],"name":"Id"},{"value":"50","type":"Number","label":"Field Of View","description":"Default: 50","group":"","extraInformation":[],"name":"Fov"},{"value":"true","type":"Boolean","label":"Link Angle","description":"Top Down: 2D Angle -> 3D Y axis or Side: 2D Angle -> 3D X axis","group":"","extraInformation":[],"name":"LinkAngle"},{"value":"true","type":"Boolean","label":"Hide 2D Object","description":"","group":"","extraInformation":[],"name":"Hide"}],"sharedPropertyDescriptors":[]},{"description":" 3D Lights are highly loaded.\nLink a Sprite object and  a 3D Light.","fullName":"Linked 3D Light","name":"LinkedLight","objectType":"Sprite","eventsFunctions":[{"fullName":"","functionType":"Action","name":"doStepPostEvents","sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"WithThreeJS::LinkedLight::PropertyFirstFrame"},"parameters":["Object","Behavior"]}],"actions":[{"type":{"value":"WithThreeJS::LinkedLight::SetPropertyFirstFrame"},"parameters":["Object","Behavior","no"]}],"events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["if (!gdjs.__WithThreeJS.has(\"Renderer\")) {","    console.warn(\"!\");","    return;","}","const Scene = gdjs.__WithThreeJS.get(\"Scene\");","const Renderer = gdjs.__WithThreeJS.get(\"Renderer\");","//","const Behavior = objects[0].getBehavior(eventsFunctionContext.getBehaviorName(\"Behavior\"));","const Id = objects[0].name + objects[0].id;","//","const LightType = Behavior._getType();","const Color = Behavior._getColor() || \"255;255;255\";","let Intensity = Behavior._getIntensity();","const Distance = Behavior._getDistance();","const Decay = 2;","const SpotAngle = Behavior._getSpotAngle();","const SpotPenumbra = Behavior._getSpotPenumbra();","const CastShadow = Behavior._getCastShadow();","const ShadowMapSize = gdjs.__WithThreeJS.get(\"ShadowMapSizeStringToValue\")[Behavior._getShadowMapSize()];","const ShadowRange = Behavior._getShadowRange();","const ShadowBias = Behavior._getShadowDepthBias();","const ShadowNormalBias = Behavior._getShadowNormalBias();","const LightHelper = Behavior._getLightHelper();","const ShadowHelper = Behavior._getShadowHelper();","//","const RGB = Color.split(\";\");","let Light;","if (LightType == \"Directional Light\") {","    Intensity *= gdjs.__WithThreeJS.get(\"LightIntensityScale\");// Three.js r160","    Light = new THREE.DirectionalLight(`rgb(${RGB[0]}, ${RGB[1]}, ${RGB[2]})`, Intensity);","    const Target = new THREE.Group();","    Target.translateZ(-128);","    Light.add(Target);","    Light.target = Target;","    //","    Light.shadow.camera.top = ShadowRange / 2;","    Light.shadow.camera.right = ShadowRange / 2;","    Light.shadow.camera.bottom = -ShadowRange / 2;","    Light.shadow.camera.left = -ShadowRange / 2;","    Light.shadow.camera.near = 0.5;// default","    Light.shadow.camera.far = ShadowRange;","    //","    if (LightHelper) {","        const DirectionalLightHelper = new THREE.DirectionalLightHelper(Light, 128);","        DirectionalLightHelper.name = Id + \"_DirectionalLightHelper\";","        Scene.add(DirectionalLightHelper);","    }","} else if (LightType == \"Spot Light\") {","    Intensity *= gdjs.__WithThreeJS.get(\"LightIntensityCandela\");// Three.js r160","    Light = new THREE.SpotLight(`rgb(${RGB[0]}, ${RGB[1]}, ${RGB[2]})`, Intensity, Distance, gdjs.toRad(SpotAngle), SpotPenumbra, Decay);","    const Target = new THREE.Group();","    Target.translateZ(-1);","    Light.add(Target);","    Light.target = Target;","    //","    Light.shadow.camera.near = 0.5;// default","    Light.shadow.camera.far = ShadowRange;","    Light.shadow.focus = 1; // default","    //","    if (LightHelper) {","        const SpotLightHelper = new THREE.SpotLightHelper(Light);","        SpotLightHelper.name = Id + \"_SpotLightHelper\";","        Scene.add(SpotLightHelper);","    }","} else {","    // Point","    Intensity *= gdjs.__WithThreeJS.get(\"LightIntensityCandela\");// Three.js r160","    Light = new THREE.PointLight(`rgb(${RGB[0]}, ${RGB[1]}, ${RGB[2]})`, Intensity, Distance, Decay);","    //","    Light.shadow.camera.near = 0.5;// default","    Light.shadow.camera.far = ShadowRange;","    //","    if (LightHelper) {","        const PointLightHelper = new THREE.PointLightHelper(Light, 16);","        PointLightHelper.name = Id + \"_PointLightHelper\";","        Scene.add(PointLightHelper);","    }","}","Renderer.shadowMap.enabled = Renderer.shadowMap.enabled ? true : CastShadow;","Light.castShadow = CastShadow;","Light.shadow.mapSize.width = ShadowMapSize;","Light.shadow.mapSize.height = ShadowMapSize;","Light.shadow.bias = ShadowBias;","Light.shadow.normalBias = ShadowNormalBias;","Light.shadow.updateMatrices(Light);// ","Light.shadow.camera.updateProjectionMatrix();","//","Light.name = Id;","Behavior._setId(Id);","Light.userData.Use3DProjectionBehavior = true;","Scene.add(Light);","//","if (ShadowHelper && CastShadow) {","    let CameraHelper;","    if (LightType != \"Point Light\") {","        CameraHelper = new THREE.CameraHelper(Light.shadow.camera);","        Scene.add(CameraHelper);","    } else {","        const Geometry = new THREE.IcosahedronGeometry(Light.shadow.camera.far, 2); ","        const Material = new THREE.MeshBasicMaterial( {color: 0xffaa00, wireframe: true} );","        CameraHelper = new THREE.Mesh(Geometry, Material);","        Light.add(CameraHelper);","    }","    CameraHelper.name = Id + \"_CameraHelper\";","}","",""],"parameterObjects":"Object","useStrict":true,"eventsSheetExpanded":true},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"WithThreeJS::LinkedLight::PropertyHide"},"parameters":["Object","Behavior"]}],"actions":[{"type":{"value":"Cache"},"parameters":["Object"]}]}]},{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["if (!gdjs.__WithThreeJS.has(\"Renderer\")) {\r","    console.warn(\"!\");\r","    return;\r","}\r","const Scene = gdjs.__WithThreeJS.get(\"Scene\");\r","//\r","const Behavior = objects[0].getBehavior(eventsFunctionContext.getBehaviorName(\"Behavior\"));\r","const Id = Behavior.Id();\r","const Tilt = Behavior.Tilt();\r","const X = objects[0].getCenterXInScene();\r","const Y = objects[0].getCenterYInScene();\r","const Z = objects[0].zOrder;\r","const ProjectionScale = gdjs.__WithThreeJS.get(\"ProjectionScale\");\r","const ViewMode = gdjs.__WithThreeJS.get(\"ViewMode\");\r","//\r","const Obj = gdjs.__WithThreeJS.get(\"SearchObject\")(Id);\r","if (!Obj) {\r","    console.warn(\"3D Object not found: \" + Id);\r","    return;\r","}\r","// Move & Rotate\r","const Angle = objects[0].angle;\r","if (ViewMode == \"Top Down\") {\r","    Obj.position.set(X * ProjectionScale, Z * ProjectionScale, Y * ProjectionScale);\r","    Obj.rotation.set(gdjs.toRad(0), gdjs.toRad((Angle + 90) * -1), gdjs.toRad(0));\r","    Obj.rotateX(gdjs.toRad(Tilt));\r","} else {\r","    // Side\r","    Obj.position.set(X * ProjectionScale, -Y * ProjectionScale, Z * ProjectionScale);\r","    Obj.rotation.set(0, gdjs.toRad(-90), gdjs.toRad(0));\r","    Obj.rotateY(gdjs.toRad(Tilt));\r","    Obj.rotateX(gdjs.toRad(Angle * -1));\r","}\r","\r",""],"parameterObjects":"Object","useStrict":true,"eventsSheetExpanded":true}],"parameters":[{"description":"Object","name":"Object","supplementaryInformation":"Sprite","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"WithThreeJS::LinkedLight","type":"behavior"}],"objectGroups":[]},{"fullName":"","functionType":"Action","name":"onDestroy","sentence":"","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["// 3D\r","// FirstFrame == true  Id \r","const Behavior = objects[0].getBehavior(eventsFunctionContext.getBehaviorName(\"Behavior\"));\r","const Id = Behavior.Id();\r","if (Id === \"\") {\r","    return;\r","}\r","//\r","if (!gdjs.__WithThreeJS.has(\"Renderer\")) {\r","    console.warn(\"!\");\r","    return;\r","}\r","const Scene = gdjs.__WithThreeJS.get(\"Scene\");\r","const Obj = gdjs.__WithThreeJS.get(\"SearchObject\")(Id);\r","const CastShadow = Behavior._getCastShadow();\r","//\r","gdjs.__WithThreeJS.get(\"DisposeChildren\")(Obj);\r","Obj.removeFromParent();\r","\r",""],"parameterObjects":"Object","useStrict":true,"eventsSheetExpanded":true}],"parameters":[{"description":"Object","name":"Object","supplementaryInformation":"Sprite","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"WithThreeJS::LinkedLight","type":"behavior"}],"objectGroups":[]},{"fullName":"3D Object ID","functionType":"StringExpression","name":"Id","sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetReturnString"},"parameters":["Object.Behavior::PropertyId()"]}]}],"expressionType":{"type":"string"},"parameters":[{"description":"Object","name":"Object","supplementaryInformation":"Sprite","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"WithThreeJS::LinkedLight","type":"behavior"}],"objectGroups":[]},{"fullName":"Type","functionType":"StringExpression","name":"Type","sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetReturnString"},"parameters":["Object.Behavior::PropertyType()"]}]}],"expressionType":{"type":"stringWithSelector"},"parameters":[{"description":"Object","name":"Object","supplementaryInformation":"Sprite","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"WithThreeJS::LinkedLight","type":"behavior"}],"objectGroups":[]},{"fullName":"Tilt","functionType":"Expression","name":"Tilt","sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetReturnNumber"},"parameters":["Object.Behavior::PropertyTilt()"]}]}],"expressionType":{"type":"expression"},"parameters":[{"description":"Object","name":"Object","supplementaryInformation":"Sprite","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"WithThreeJS::LinkedLight","type":"behavior"}],"objectGroups":[]},{"fullName":"Set Tilt","functionType":"Action","name":"SetTilt","private":true,"sentence":"Set Tilt (_PARAM0_, Value: _PARAM2_)","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"WithThreeJS::LinkedLight::SetPropertyTilt"},"parameters":["Object","Behavior","=","GetArgumentAsNumber(\"Value\")"]}]}],"parameters":[{"description":"Object","name":"Object","supplementaryInformation":"Sprite","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"WithThreeJS::LinkedLight","type":"behavior"},{"description":"Tilt Value (Recommended: -90 to 90)","name":"Value","type":"expression"}],"objectGroups":[]}],"propertyDescriptors":[{"value":"","type":"String","label":"","description":"","group":"","extraInformation":[],"hidden":true,"name":"Id"},{"value":"true","type":"Boolean","label":"","description":"","group":"","extraInformation":[],"hidden":true,"name":"FirstFrame"},{"value":"true","type":"Boolean","label":"Hide 2D Object","description":"","group":"","extraInformation":[],"name":"Hide"},{"value":"Directional Light","type":"Choice","label":"Type","description":"","group":"","extraInformation":["Directional Light","Point Light","Spot Light"],"name":"Type"},{"value":"255;255;255","type":"Color","label":"Color","description":"","group":"","extraInformation":[],"name":"Color"},{"value":"1","type":"Number","label":"Intensity (Default: 1)","description":"","group":"","extraInformation":[],"name":"Intensity"},{"value":"0","type":"Number","label":"Distance (Default: 0)","description":"For Point and Spot Lights. 0 is no limit.","group":"","extraInformation":[],"name":"Distance"},{"value":"45","type":"Number","label":"Spot Angle (0 to 180)","description":"For Spot Lights. The narrower the angle, the better the shadow quality. If it is a multiple of 90, the shadow will not be cast correctly.","group":"","extraInformation":[],"name":"SpotAngle"},{"value":"0.5","type":"Number","label":"Spot Penumbra (0 to 1)","description":"For Spot Lights.","group":"","extraInformation":[],"name":"SpotPenumbra"},{"value":"0","type":"Number","label":"Tilt (Recommended: -90 to 90)","description":"","group":"","extraInformation":[],"name":"Tilt"},{"value":"","type":"Boolean","label":"Cast Shadow","description":" This is expensive and requires tweaking to get shadows looking right.","group":"Shadow","extraInformation":[],"name":"CastShadow"},{"value":"512px","type":"Choice","label":"Shadow Map Size","description":"The larger the map, the better the shadow quality, but the greater the load.","group":"Shadow","extraInformation":["128px","256px","512px","1024px","2048px"],"name":"ShadowMapSize"},{"value":"256","type":"Number","label":"Range to Draw Shadows","description":"The smaller the range, the better the shadow quality. For Point and Spot Lights, this value is valid only if the Distance is 0.","group":"Shadow","extraInformation":[],"name":"ShadowRange"},{"value":"0.002","type":"Number","label":"Shadow Depth Bias (Default: 0.002)","description":"It is mainly effective for filling gaps between objects and shadows. Reference value: [Directional Light: 0.002] [Point Light: 0.001] [Spot Light: 0.00001]","group":"Shadow Bias","extraInformation":[],"name":"ShadowDepthBias"},{"value":"2","type":"Number","label":"Shadow Normal Bias (Default: 2)","description":"It is mainly effective in reducing striped patterns. Reference value: [Directional Light: 2] [Point Light: 1] [Spot Light: 1]","group":"Shadow Bias","extraInformation":[],"name":"ShadowNormalBias"},{"value":"","type":"Boolean","label":"Light Helper","description":"","group":"Helper","extraInformation":[],"name":"LightHelper"},{"value":"","type":"Boolean","label":"Shadow Range Helper","description":"","group":"Helper","extraInformation":[],"name":"ShadowHelper"}],"sharedPropertyDescriptors":[]}],"eventsBasedObjects":[{"areaMaxX":64,"areaMaxY":64,"areaMaxZ":64,"areaMinX":0,"areaMinY":0,"areaMinZ":0,"defaultName":"My3DBox","description":"This 3D Box can have different textures on 6 faces.\n This object is high load.","fullName":"3D Box","is3D":true,"isUsingLegacyInstancesRenderer":true,"name":"Box3D","eventsFunctions":[{"fullName":"","functionType":"Action","name":"onCreated","sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"Create"},"parameters":["","Front","0","0","\"\""]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"WithThreeJS::Box3D::PropertyHide"},"parameters":["Object"]}],"actions":[{"type":{"value":"Cache"},"parameters":["Object"]}]}],"parameters":[{"description":"Object","name":"Object","supplementaryInformation":"WithThreeJS::Box3D","type":"object"}],"objectGroups":[]},{"fullName":"","functionType":"Action","name":"doStepPostEvents","sentence":"","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["const Obj2D = objects[0];\r","if (!gdjs.__WithThreeJS.has(\"Renderer\") || !gdjs.__WithThreeJS.get(\"SceneIsReady\")) {\r","    // !PostEvent\r","    // console.warn(\"! (3D Box Object)\");\r","    return;\r","}\r","const Scene = gdjs.__WithThreeJS.get(\"Scene\");\r","//\r","if (Obj2D._getFirstFrame()) {\r","    Obj2D._setFirstFrame(false);\r","    //\r","    if (!gdjs.__WithThreeJS.has(\"Textures\")) {\r","        gdjs.__WithThreeJS.set(\"Textures\", new Map());\r","    }\r","    const Textures = gdjs.__WithThreeJS.get(\"Textures\");\r","    //\r","    const Id = Obj2D.name + Obj2D.id;\r","    const Width = Obj2D.getWidth();\r","    const Height = Obj2D.getHeight();\r","    const Depth = Obj2D._getDepth();\r","    const ProjectionScale = gdjs.__WithThreeJS.get(\"ProjectionScale\");\r","    const ViewMode = gdjs.__WithThreeJS.get(\"ViewMode\");\r","    const AlphaTest = Obj2D._getAlphaTest();\r","    const Transparent = AlphaTest !== 0;\r","    const AntiAliasing = Obj2D._getAntiAliasing();\r","    let Blend = THREE.NormalBlending;\r","    if (Obj2D._getBlend() == \"Additive\") {\r","        Blend = THREE.AdditiveBlending;\r","    } else if (Obj2D._getBlend() == \"Subtractive\") {\r","        Blend = THREE.SubtractiveBlending;\r","    } else if (Obj2D._getBlend() == \"Multiply\") {\r","        Blend = THREE.MultiplyBlending;\r","    }\r","    const CastShadow = Obj2D._getCastShadow();\r","    const ReceiveShadow = Obj2D._getReceiveShadow();\r","    //\r","    const Items = Obj2D._instanceContainer._objects.items;\r","    const ResourceNameTop = Items.Top.texture;\r","    const ResourceNameBottom = Items.Bottom.texture;\r","    const ResourceNameFront = Items.Front.texture;\r","    const ResourceNameBack = Items.Back.texture;\r","    const ResourceNameLeft = Items.Left.texture;\r","    const ResourceNameRight = Items.Right.texture;\r","    if (ResourceNameTop == \"\" || ResourceNameBottom == \"\" || ResourceNameFront == \"\" || ResourceNameBack == \"\" || ResourceNameLeft == \"\" || ResourceNameRight == \"\") {\r","        console.warn(\"Some faces have no image.\");\r","        return;\r","    }\r","    const ResourceTop = runtimeScene.getGame().getImageManager().getPIXITexture(ResourceNameTop).baseTexture.resource;\r","    const ResourceBottom = runtimeScene.getGame().getImageManager().getPIXITexture(ResourceNameBottom).baseTexture.resource;\r","    const ResourceFront = runtimeScene.getGame().getImageManager().getPIXITexture(ResourceNameFront).baseTexture.resource;\r","    const ResourceBack = runtimeScene.getGame().getImageManager().getPIXITexture(ResourceNameBack).baseTexture.resource;\r","    const ResourceLeft = runtimeScene.getGame().getImageManager().getPIXITexture(ResourceNameLeft).baseTexture.resource;\r","    const ResourceRight = runtimeScene.getGame().getImageManager().getPIXITexture(ResourceNameRight).baseTexture.resource;\r","    //\r","    Obj2D._setTextureIdTop(\"_\" + Id + \"_\" + ResourceTop.url + \"_Top\");\r","    Obj2D._setTextureIdBottom(\"_\" + Id + \"_\" + ResourceBottom.url + \"_Bottom\");\r","    Obj2D._setTextureIdFront(\"_\" + Id + \"_\" + ResourceFront.url + \"_Front\");\r","    Obj2D._setTextureIdBack(\"_\" + Id + \"_\" + ResourceBack.url + \"_Back\");\r","    Obj2D._setTextureIdLeft(\"_\" + Id + \"_\" + ResourceLeft.url + \"_Left\");\r","    Obj2D._setTextureIdRight(\"_\" + Id + \"_\" + ResourceRight.url + \"_Right\");\r","    //\r","    let RepeatTopU, RepeatTopV;\r","    let RepeatBottomU, RepeatBottomV;\r","    let RepeatFrontU, RepeatFrontV;\r","    let RepeatBackU, RepeatBackV;\r","    let RepeatLeftU, RepeatLeftV;\r","    let RepeatRightU, RepeatRightV;\r","    if (ViewMode == \"Top Down\") {\r","        RepeatTopU = Width / ResourceTop.width;\r","        RepeatTopV = Height / ResourceTop.height;\r","        RepeatBottomU = Width / ResourceBottom.width;\r","        RepeatBottomV = Height / ResourceBottom.height;\r","        //\r","        RepeatFrontU = Width / ResourceFront.width;\r","        RepeatFrontV = Depth / ResourceFront.height;\r","        RepeatBackU = Width / ResourceBack.width;\r","        RepeatBackV = Depth / ResourceBack.height;\r","        //\r","        RepeatLeftU = Height / ResourceLeft.width;\r","        RepeatLeftV = Depth / ResourceLeft.height;\r","        RepeatRightU = Height / ResourceRight.width;\r","        RepeatRightV = Depth / ResourceRight.height;\r","    } else {\r","        // Side\r","        RepeatTopU = Width / ResourceTop.width;\r","        RepeatTopV = Depth / ResourceTop.height;\r","        RepeatBottomU = Width / ResourceBottom.width;\r","        RepeatBottomV = Depth / ResourceBottom.height;\r","        //\r","        RepeatFrontU = Width / ResourceFront.width;\r","        RepeatFrontV = Height / ResourceFront.height;\r","        RepeatBackU = Width / ResourceBack.width;\r","        RepeatBackV = Height / ResourceBack.height;\r","        //\r","        RepeatLeftU = Depth / ResourceLeft.width;\r","        RepeatLeftV = Height / ResourceLeft.height;\r","        RepeatRightU = Depth / ResourceRight.width;\r","        RepeatRightV = Height / ResourceRight.height;\r","    }\r","    // Offset\r","    Obj2D._setTopOffsetV(1 - (RepeatTopV % 1));\r","    Obj2D._setBottomOffsetV(1 - (RepeatBottomV % 1));\r","    Obj2D._setFrontOffsetV(1 - (RepeatFrontV % 1));\r","    Obj2D._setBackOffsetV(1 - (RepeatBackV % 1));\r","    Obj2D._setLeftOffsetV(1 - (RepeatLeftV % 1));\r","    Obj2D._setRightOffsetV(1 - (RepeatRightV % 1));\r","    //\r","    const TextureTop = new THREE.Texture();\r","    TextureTop.image = ResourceTop.source;\r","    TextureTop.wrapS = THREE.RepeatWrapping;\r","    TextureTop.wrapT = THREE.RepeatWrapping;\r","    if (!AntiAliasing) {\r","        TextureTop.magFilter = THREE.NearestFilter;// THREE.LinearFilter\r","        TextureTop.minFilter = THREE.NearestFilter;// THREE.LinearMipmapLinearFilter\r","    }\r","    TextureTop.repeat.set(RepeatTopU, RepeatTopV);\r","    TextureTop.offset.set(0, Obj2D._getTopOffsetV());\r","    TextureTop.colorSpace = THREE.SRGBColorSpace;\r","    TextureTop.needsUpdate = true;//\r","    Textures.set(Obj2D._getTextureIdTop(), TextureTop);\r","    //\r","    const TextureBottom = new THREE.Texture();\r","    TextureBottom.image = ResourceBottom.source;\r","    TextureBottom.wrapS = THREE.RepeatWrapping;\r","    TextureBottom.wrapT = THREE.RepeatWrapping;\r","    if (!AntiAliasing) {\r","        TextureBottom.magFilter = THREE.NearestFilter;// THREE.LinearFilter\r","        TextureBottom.minFilter = THREE.NearestFilter;// THREE.LinearMipmapLinearFilter\r","    }\r","    TextureBottom.repeat.set(RepeatBottomU, RepeatBottomV);\r","    TextureBottom.offset.set(0, Obj2D._getBottomOffsetV());\r","    TextureBottom.colorSpace = THREE.SRGBColorSpace;\r","    TextureBottom.needsUpdate = true;//\r","    Textures.set(Obj2D._getTextureIdBottom(), TextureBottom);\r","    //\r","    const TextureFront = new THREE.Texture();\r","    TextureFront.image = ResourceFront.source;\r","    TextureFront.wrapS = THREE.RepeatWrapping;\r","    TextureFront.wrapT = THREE.RepeatWrapping;\r","    if (!AntiAliasing) {\r","        TextureFront.magFilter = THREE.NearestFilter;// THREE.LinearFilter\r","        TextureFront.minFilter = THREE.NearestFilter;// THREE.LinearMipmapLinearFilter\r","    }\r","    TextureFront.repeat.set(RepeatFrontU, RepeatFrontV);\r","    TextureFront.offset.set(0, Obj2D._getFrontOffsetV());\r","    TextureFront.colorSpace = THREE.SRGBColorSpace;\r","    TextureFront.needsUpdate = true;//\r","    Textures.set(Obj2D._getTextureIdFront(), TextureFront);\r","    //\r","    const TextureBack = new THREE.Texture();\r","    TextureBack.image = ResourceBack.source;\r","    TextureBack.wrapS = THREE.RepeatWrapping;\r","    TextureBack.wrapT = THREE.RepeatWrapping;\r","    if (!AntiAliasing) {\r","        TextureBack.magFilter = THREE.NearestFilter;// THREE.LinearFilter\r","        TextureBack.minFilter = THREE.NearestFilter;// THREE.LinearMipmapLinearFilter\r","    }\r","    TextureBack.repeat.set(RepeatBackU, RepeatBackV);\r","    TextureBack.offset.set(0, Obj2D._getBackOffsetV());\r","    TextureBack.colorSpace = THREE.SRGBColorSpace;\r","    TextureBack.needsUpdate = true;//\r","    Textures.set(Obj2D._getTextureIdBack(), TextureBack);\r","    //\r","    const TextureLeft = new THREE.Texture();\r","    TextureLeft.image = ResourceLeft.source;\r","    TextureLeft.wrapS = THREE.RepeatWrapping;\r","    TextureLeft.wrapT = THREE.RepeatWrapping;\r","    if (!AntiAliasing) {\r","        TextureLeft.magFilter = THREE.NearestFilter;// THREE.LinearFilter\r","        TextureLeft.minFilter = THREE.NearestFilter;// THREE.LinearMipmapLinearFilter\r","    }\r","    TextureLeft.repeat.set(RepeatLeftU, RepeatLeftV);\r","    TextureLeft.offset.set(0, Obj2D._getLeftOffsetV());\r","    TextureLeft.colorSpace = THREE.SRGBColorSpace;\r","    TextureLeft.needsUpdate = true;//\r","    Textures.set(Obj2D._getTextureIdLeft(), TextureLeft);\r","    //\r","    const TextureRight = new THREE.Texture();\r","    TextureRight.image = ResourceRight.source;\r","    TextureRight.wrapS = THREE.RepeatWrapping;\r","    TextureRight.wrapT = THREE.RepeatWrapping;\r","    if (!AntiAliasing) {\r","        TextureRight.magFilter = THREE.NearestFilter;// THREE.LinearFilter\r","        TextureRight.minFilter = THREE.NearestFilter;// THREE.LinearMipmapLinearFilter\r","    }\r","    TextureRight.repeat.set(RepeatRightU, RepeatRightV);\r","    TextureRight.offset.set(0, Obj2D._getRightOffsetV());\r","    TextureRight.colorSpace = THREE.SRGBColorSpace;\r","    TextureRight.needsUpdate = true;//\r","    Textures.set(Obj2D._getTextureIdRight(), TextureRight);\r","    //\r","    // const MaterialTop = new THREE.MeshBasicMaterial({map: TextureTop, transparent:Transparent, alphaTest:AlphaTest, blending:Blend});\r","    // const MaterialBottom = new THREE.MeshBasicMaterial({map: TextureBottom, transparent:Transparent, alphaTest:AlphaTest, blending:Blend});\r","    // const MaterialFront = new THREE.MeshBasicMaterial({map: TextureFront, transparent:Transparent, alphaTest:AlphaTest, blending:Blend});\r","    // const MaterialBack = new THREE.MeshBasicMaterial({map: TextureBack, transparent:Transparent, alphaTest:AlphaTest, blending:Blend});\r","    // const MaterialLeft = new THREE.MeshBasicMaterial({map: TextureLeft, transparent:Transparent, alphaTest:AlphaTest, blending:Blend});\r","    // const MaterialRight = new THREE.MeshBasicMaterial({map: TextureRight, transparent:Transparent, alphaTest:AlphaTest, blending:Blend});\r","    const MaterialTop = new THREE.MeshLambertMaterial({map: TextureTop, transparent:Transparent, alphaTest:AlphaTest, blending:Blend});\r","    const MaterialBottom = new THREE.MeshLambertMaterial({map: TextureBottom, transparent:Transparent, alphaTest:AlphaTest, blending:Blend});\r","    const MaterialFront = new THREE.MeshLambertMaterial({map: TextureFront, transparent:Transparent, alphaTest:AlphaTest, blending:Blend});\r","    const MaterialBack = new THREE.MeshLambertMaterial({map: TextureBack, transparent:Transparent, alphaTest:AlphaTest, blending:Blend});\r","    const MaterialLeft = new THREE.MeshLambertMaterial({map: TextureLeft, transparent:Transparent, alphaTest:AlphaTest, blending:Blend});\r","    const MaterialRight = new THREE.MeshLambertMaterial({map: TextureRight, transparent:Transparent, alphaTest:AlphaTest, blending:Blend});\r","    //\r","    const Material = [MaterialLeft, MaterialRight, MaterialTop, MaterialBottom, MaterialFront, MaterialBack];\r","    let Geometry;\r","    if (ViewMode == \"Top Down\") {\r","        Geometry = new THREE.BoxGeometry(Width * ProjectionScale, Depth * ProjectionScale, Height * ProjectionScale);\r","    } else {\r","        // Side\r","        Geometry = new THREE.BoxGeometry(Width * ProjectionScale, Height * ProjectionScale, Depth * ProjectionScale);\r","    }\r","    Geometry.computeBoundingBox();\r","    const Obj3D = new THREE.Mesh(Geometry, Material);\r","    Obj3D.name = Id;\r","    Obj3D.castShadow = CastShadow;\r","    Obj3D.receiveShadow = ReceiveShadow;\r","    Obj3D.userData.Use3DProjectionBehavior = true;\r","    Obj2D._setId(Id);\r","    Scene.add(Obj3D);\r","}\r","// ====================================\r","const Id = Obj2D._getId();\r","const X = Obj2D.getCenterXInScene();\r","const Y = Obj2D.getCenterYInScene();\r","const Z = Obj2D.zOrder;\r","const Angle = Obj2D.angle;\r","const Opacity = Obj2D.getOpacity() / 255;\r","const ProjectionScale = gdjs.__WithThreeJS.get(\"ProjectionScale\");\r","const ViewMode = gdjs.__WithThreeJS.get(\"ViewMode\");\r","//\r","const Obj3D = gdjs.__WithThreeJS.get(\"SearchObject\")(Id);\r","if (!Obj3D) {\r","    console.warn(\"3D Object not found: \" + Id);\r","    return;\r","}\r","// Move & Rotate\r","if (ViewMode == \"Top Down\") {\r","    Obj3D.position.set(X * ProjectionScale, Z * ProjectionScale, Y * ProjectionScale);\r","    Obj3D.rotation.set(gdjs.toRad(0), gdjs.toRad(Angle * -1), gdjs.toRad(0));\r","} else {\r","    // Side\r","    Obj3D.position.set(X * ProjectionScale, -Y * ProjectionScale, Z * ProjectionScale);\r","    Obj3D.rotation.set(gdjs.toRad(0), gdjs.toRad(0), gdjs.toRad(Angle * -1));\r","}\r","// Opacity\r","for (let i = 0; i < Obj3D.material.length; i++) {\r","    if (!Obj3D.material[i].transparent) {\r","        if (Obj3D.material[i].alphaTest !== 0 || Opacity !== 1) {\r","            Obj3D.material[i].transparent = true;\r","            Obj3D.material[i].needsUpdate = true;\r","        }\r","    }\r","    Obj3D.material[i].opacity = Opacity;\r","}\r","\r",""],"parameterObjects":"Object","useStrict":true,"eventsSheetExpanded":true}],"parameters":[{"description":"Object","name":"Object","supplementaryInformation":"WithThreeJS::Box3D","type":"object"}],"objectGroups":[]},{"fullName":"","functionType":"Action","name":"onDestroy","sentence":"","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":["// 3D\r","const Obj2D = objects[0];\r","if (Obj2D._getFirstFrame()) {\r","    return;\r","}\r","//\r","if (!gdjs.__WithThreeJS.has(\"Renderer\")) {\r","    console.warn(\"!\");\r","    return;\r","}\r","const Scene = gdjs.__WithThreeJS.get(\"Scene\");\r","const Textures = gdjs.__WithThreeJS.get(\"Textures\");\r","const Id = Obj2D._getId();\r","const Obj3D = gdjs.__WithThreeJS.get(\"SearchObject\")(Id);\r","if (!Obj3D) {\r","    console.warn(\"3D Object not found.\");\r","    return;\r","}\r","// Texture dispose\r","Textures.get(Obj2D._getTextureIdTop()).dispose();\r","Textures.delete(Obj2D._getTextureIdTop());\r","Textures.get(Obj2D._getTextureIdBottom()).dispose();\r","Textures.delete(Obj2D._getTextureIdBottom());\r","Textures.get(Obj2D._getTextureIdFront()).dispose();\r","Textures.delete(Obj2D._getTextureIdFront());\r","Textures.get(Obj2D._getTextureIdBack()).dispose();\r","Textures.delete(Obj2D._getTextureIdBack());\r","Textures.get(Obj2D._getTextureIdLeft()).dispose();\r","Textures.delete(Obj2D._getTextureIdLeft());\r","Textures.get(Obj2D._getTextureIdRight()).dispose();\r","Textures.delete(Obj2D._getTextureIdRight());\r","// material dispose OK\r","gdjs.__WithThreeJS.get(\"DisposeChildren\")(Obj3D);\r","//\r","Obj3D.removeFromParent();\r","\r",""],"parameterObjects":"Object","useStrict":true,"eventsSheetExpanded":true}],"parameters":[{"description":"Object","name":"Object","supplementaryInformation":"WithThreeJS::Box3D","type":"object"}],"objectGroups":[]},{"fullName":"3D Object ID","functionType":"StringExpression","name":"Id","sentence":"","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":"eventsFunctionContext.returnValue = objects[0]._getId();","parameterObjects":"Object","useStrict":true,"eventsSheetExpanded":false}],"expressionType":{"type":"string"},"parameters":[{"description":"Object","name":"Object","supplementaryInformation":"WithThreeJS::Box3D","type":"object"}],"objectGroups":[]},{"fullName":"Depth","functionType":"Expression","name":"Depth","sentence":"","events":[{"type":"BuiltinCommonInstructions::JsCode","inlineCode":"eventsFunctionContext.returnValue = objects[0]._getDepth();","parameterObjects":"Object","useStrict":true,"eventsSheetExpanded":false}],"expressionType":{"type":"expression"},"parameters":[{"description":"Object","name":"Object","supplementaryInformation":"WithThreeJS::Box3D","type":"object"}],"objectGroups":[]}],"propertyDescriptors":[{"value":"","type":"String","label":"","description":"","group":"","extraInformation":[],"hidden":true,"name":"Id"},{"value":"true","type":"Boolean","label":"","description":"","group":"","extraInformation":[],"hidden":true,"name":"FirstFrame"},{"value":"true","type":"Boolean","label":"Hide 2D Object","description":"","group":"","extraInformation":[],"name":"Hide"},{"value":"0","type":"Number","label":"Alpha Channel Test","description":"Recommended values: 0 or 0.5. Default: 0.","group":"Texture","extraInformation":[],"name":"AlphaTest"},{"value":"true","type":"Boolean","label":"Anti-Aliasing","description":"","group":"Texture","extraInformation":[],"name":"AntiAliasing"},{"value":"1","type":"Number","unit":"Pixel","label":"Depth","description":"Unit: Pixel","group":"","extraInformation":[],"name":"Depth"},{"value":"Normal","type":"Choice","label":"Blend Mode","description":"","group":"Texture","extraInformation":["Normal","Additive","Subtractive","Multiply"],"name":"Blend"},{"value":"0","type":"Number","label":"","description":"","group":"","extraInformation":[],"hidden":true,"name":"TopOffsetV"},{"value":"0","type":"Number","label":"","description":"","group":"","extraInformation":[],"hidden":true,"name":"BottomOffsetV"},{"value":"0","type":"Number","label":"","description":"","group":"","extraInformation":[],"hidden":true,"name":"FrontOffsetV"},{"value":"0","type":"Number","label":"","description":"","group":"","extraInformation":[],"hidden":true,"name":"BackOffsetV"},{"value":"0","type":"Number","label":"","description":"","group":"","extraInformation":[],"hidden":true,"name":"LeftOffsetV"},{"value":"0","type":"Number","label":"","description":"","group":"","extraInformation":[],"hidden":true,"name":"RightOffsetV"},{"value":"","type":"String","label":"","description":"","group":"","extraInformation":[],"hidden":true,"name":"TextureIdTop"},{"value":"","type":"String","label":"","description":"","group":"","extraInformation":[],"hidden":true,"name":"TextureIdBottom"},{"value":"","type":"String","label":"","description":"","group":"","extraInformation":[],"hidden":true,"name":"TextureIdFront"},{"value":"","type":"String","label":"","description":"","group":"","extraInformation":[],"hidden":true,"name":"TextureIdBack"},{"value":"","type":"String","label":"","description":"","group":"","extraInformation":[],"hidden":true,"name":"TextureIdLeft"},{"value":"","type":"String","label":"","description":"","group":"","extraInformation":[],"hidden":true,"name":"TextureIdRight"},{"value":"","type":"Boolean","label":"Cast Shadow","description":"","group":"Shadow","extraInformation":[],"name":"CastShadow"},{"value":"","type":"Boolean","label":"Receive Shadow","description":"","group":"Shadow","extraInformation":[],"name":"ReceiveShadow"}],"objects":[{"assetStoreId":"","height":32.0,"name":"Top","texture":"","type":"TiledSpriteObject::TiledSprite","width":32.0,"variables":[],"effects":[],"behaviors":[]},{"assetStoreId":"","height":32.0,"name":"Bottom","texture":"","type":"TiledSpriteObject::TiledSprite","width":32.0,"variables":[],"effects":[],"behaviors":[]},{"assetStoreId":"","height":32.0,"name":"Front","texture":"","type":"TiledSpriteObject::TiledSprite","width":32.0,"variables":[],"effects":[],"behaviors":[]},{"assetStoreId":"","height":32.0,"name":"Back","texture":"","type":"TiledSpriteObject::TiledSprite","width":32.0,"variables":[],"effects":[],"behaviors":[]},{"assetStoreId":"","height":32.0,"name":"Left","texture":"","type":"TiledSpriteObject::TiledSprite","width":32.0,"variables":[],"effects":[],"behaviors":[]},{"assetStoreId":"","height":32.0,"name":"Right","texture":"","type":"TiledSpriteObject::TiledSprite","width":32.0,"variables":[],"effects":[],"behaviors":[]}],"objectsFolderStructure":{"folderName":"__ROOT","children":[{"objectName":"Top"},{"objectName":"Bottom"},{"objectName":"Front"},{"objectName":"Back"},{"objectName":"Left"},{"objectName":"Right"}]},"objectsGroups":[],"layers":[{"ambientLightColorB":200,"ambientLightColorG":200,"ambientLightColorR":200,"camera3DFarPlaneDistance":10000.0,"camera3DFieldOfView":45.0,"camera3DNearPlaneDistance":3.0,"cameraType":"","followBaseLayerCamera":false,"isLightingLayer":false,"isLocked":false,"name":"","renderingType":"","visibility":true,"cameras":[{"defaultSize":true,"defaultViewport":true,"height":0.0,"viewportBottom":1.0,"viewportLeft":0.0,"viewportRight":1.0,"viewportTop":0.0,"width":0.0}],"effects":[]}],"instances":[]},{"areaMaxX":64,"areaMaxY":64,"areaMaxZ":64,"areaMinX":0,"areaMinY":0,"areaMinZ":0,"defaultName":"Enable_WithThreeJS","description":"Adding this object to your project will enable WithThreeJS in all scenes.\nThere is no need to place this in the scene.","fullName":"Enable WithThreeJS","is3D":true,"isUsingLegacyInstancesRenderer":true,"name":"EnableWithThreeJS","eventsFunctions":[],"propertyDescriptors":[],"objects":[],"objectsFolderStructure":{"folderName":"__ROOT"},"objectsGroups":[],"layers":[{"ambientLightColorB":200,"ambientLightColorG":200,"ambientLightColorR":200,"camera3DFarPlaneDistance":10000.0,"camera3DFieldOfView":45.0,"camera3DNearPlaneDistance":3.0,"cameraType":"","followBaseLayerCamera":false,"isLightingLayer":false,"isLocked":false,"name":"","renderingType":"","visibility":true,"cameras":[{"defaultSize":true,"defaultViewport":true,"height":0.0,"viewportBottom":1.0,"viewportLeft":0.0,"viewportRight":1.0,"viewportTop":0.0,"width":0.0}],"effects":[]}],"instances":[]}]},{"author":"","category":"User interface","extensionNamespace":"","fullName":"Button states and effects","helpPath":"/objects/button","iconUrl":"data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiBpZD0ibWRpLWdlc3R1cmUtdGFwLWJ1dHRvbiIgd2lkdGg9IjI0IiBoZWlnaHQ9IjI0IiB2aWV3Qm94PSIwIDAgMjQgMjQiPjxwYXRoIGQ9Ik0xMyA1QzE1LjIxIDUgMTcgNi43OSAxNyA5QzE3IDEwLjUgMTYuMiAxMS43NyAxNSAxMi40NlYxMS4yNEMxNS42MSAxMC42OSAxNiA5Ljg5IDE2IDlDMTYgNy4zNCAxNC42NiA2IDEzIDZTMTAgNy4zNCAxMCA5QzEwIDkuODkgMTAuMzkgMTAuNjkgMTEgMTEuMjRWMTIuNDZDOS44IDExLjc3IDkgMTAuNSA5IDlDOSA2Ljc5IDEwLjc5IDUgMTMgNU0yMCAyMC41QzE5Ljk3IDIxLjMyIDE5LjMyIDIxLjk3IDE4LjUgMjJIMTNDMTIuNjIgMjIgMTIuMjYgMjEuODUgMTIgMjEuNTdMOCAxNy4zN0w4Ljc0IDE2LjZDOC45MyAxNi4zOSA5LjIgMTYuMjggOS41IDE2LjI4SDkuN0wxMiAxOFY5QzEyIDguNDUgMTIuNDUgOCAxMyA4UzE0IDguNDUgMTQgOVYxMy40N0wxNS4yMSAxMy42TDE5LjE1IDE1Ljc5QzE5LjY4IDE2LjAzIDIwIDE2LjU2IDIwIDE3LjE0VjIwLjVNMjAgMkg0QzIuOSAyIDIgMi45IDIgNFYxMkMyIDEzLjExIDIuOSAxNCA0IDE0SDhWMTJMNCAxMkw0IDRIMjBMMjAgMTJIMThWMTRIMjBWMTMuOTZMMjAuMDQgMTRDMjEuMTMgMTQgMjIgMTMuMDkgMjIgMTJWNEMyMiAyLjkgMjEuMTEgMiAyMCAyWiIgLz48L3N2Zz4=","name":"ButtonStates","previewIconUrl":"https://asset-resources.gdevelop.io/public-resources/Icons/753a9a794bd885058159b7509f06f5a8f67f72decfccb9a1b0efee26f41c3c4c_gesture-tap-button.svg","shortDescription":"Use any object as a button and change appearance according to user interactions.","version":"1.1.1","description":["Use the \"Button states\" behavior to track user interactions with an object, including:","","- Hovered","- Pressed","- Clicked","- Idle","","Add additional behaviors to make juicy buttons with animated responses to user input:","","- Size","- Color","- Animation","- Object effects"],"origin":{"identifier":"ButtonStates","name":"gdevelop-extension-store"},"tags":["ui","button"],"authorIds":["IWykYNRvhCZBN3vEgKEbBPOR3Oc2","gqDaZjCfevOOxBYkK6zlhtZnXCg1"],"dependencies":[],"globalVariables":[],"sceneVariables":[],"eventsFunctions":[],"eventsBasedBehaviors":[{"description":"Use objects as buttons.","fullName":"Button states","name":"ButtonFSM","objectType":"","eventsFunctions":[{"fullName":"","functionType":"Action","name":"doStepPostEvents","sentence":"","events":[{"colorB":228,"colorG":176,"colorR":74,"creationTime":0,"name":"Finite state machine","source":"","type":"BuiltinCommonInstructions::Group","events":[{"type":"BuiltinCommonInstructions::Comment","color":{"b":109,"g":230,"r":255,"textB":0,"textG":0,"textR":0},"comment":"The \"Validated\" state only last one frame."},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"ButtonStates::ButtonFSM::PropertyState"},"parameters":["Object","Behavior","=","\"Validated\""]}],"actions":[{"type":{"value":"ButtonStates::ButtonFSM::SetPropertyState"},"parameters":["Object","Behavior","=","\"Idle\""]}]},{"colorB":228,"colorG":176,"colorR":74,"creationTime":0,"name":"Check position","source":"","type":"BuiltinCommonInstructions::Group","events":[{"type":"BuiltinCommonInstructions::Comment","color":{"b":109,"g":230,"r":255,"textB":0,"textG":0,"textR":0},"comment":"Make sure the cursor position is only checked once per frame."},{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"ButtonStates::ButtonFSM::SetPropertyMouseIsInside"},"parameters":["Object","Behavior","no"]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"ButtonStates::ButtonFSM::PropertyShouldCheckHovering"},"parameters":["Object","Behavior"]},{"type":{"value":"CollisionPoint"},"parameters":["Object","MouseOnlyCursorX(Object.Layer(), 0)","MouseOnlyCursorY(Object.Layer(), 0)"]}],"actions":[{"type":{"value":"ButtonStates::ButtonFSM::SetPropertyMouseIsInside"},"parameters":["Object","Behavior","yes"]}]},{"type":"BuiltinCommonInstructions::Comment","color":{"b":109,"g":230,"r":255,"textB":0,"textG":0,"textR":0},"comment":"Touches are always pressed, so ShouldCheckHovering doesn't matter."},{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"ButtonStates::ButtonFSM::SetPropertyTouchIsInside"},"parameters":["Object","Behavior","no"]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"ButtonStates::ButtonFSM::PropertyTouchId"},"parameters":["Object","Behavior","!=","0"]},{"type":{"value":"CollisionPoint"},"parameters":["Object","TouchX(TouchId, Object.Layer(), 0)","TouchY(TouchId, Object.Layer(), 0)"]}],"actions":[{"type":{"value":"ButtonStates::ButtonFSM::SetPropertyTouchIsInside"},"parameters":["Object","Behavior","yes"]}]}],"parameters":[]},{"colorB":228,"colorG":176,"colorR":74,"creationTime":0,"name":"Handle touch start","source":"","type":"BuiltinCommonInstructions::Group","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"HasAnyTouchOrMouseStarted"},"parameters":[""]}],"actions":[{"type":{"value":"ButtonStates::ButtonFSM::SetPropertyIndex"},"parameters":["Object","Behavior","=","0"]}],"events":[{"type":"BuiltinCommonInstructions::Repeat","repeatExpression":"StartedTouchOrMouseCount()","conditions":[],"actions":[],"events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"CollisionPoint"},"parameters":["Object","TouchX(StartedTouchOrMouseId(Index), Object.Layer(), 0)","TouchY(StartedTouchOrMouseId(Index), Object.Layer(), 0)"]}],"actions":[{"type":{"value":"ButtonStates::ButtonFSM::SetPropertyTouchId"},"parameters":["Object","Behavior","=","StartedTouchOrMouseId(Index)"]},{"type":{"value":"ButtonStates::ButtonFSM::SetPropertyTouchIsInside"},"parameters":["Object","Behavior","yes"]}],"events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"BuiltinCommonInstructions::Or"},"parameters":[],"subInstructions":[{"type":{"value":"ButtonStates::ButtonFSM::PropertyState"},"parameters":["Object","Behavior","=","\"Hovered\""]},{"type":{"value":"ButtonStates::ButtonFSM::PropertyState"},"parameters":["Object","Behavior","=","\"Idle\""]}]}],"actions":[{"type":{"value":"ButtonStates::ButtonFSM::SetPropertyState"},"parameters":["Object","Behavior","=","\"PressedInside\""]}]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"ButtonStates::ButtonFSM::SetPropertyIndex"},"parameters":["Object","Behavior","+","1"]}]}]}]}],"parameters":[]},{"colorB":228,"colorG":176,"colorR":74,"creationTime":0,"name":"Apply position changes","source":"","type":"BuiltinCommonInstructions::Group","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"inverted":true,"value":"ButtonStates::ButtonFSM::PropertyMouseIsInside"},"parameters":["Object","Behavior"]},{"type":{"value":"ButtonStates::ButtonFSM::PropertyState"},"parameters":["Object","Behavior","=","\"Hovered\""]}],"actions":[{"type":{"value":"ButtonStates::ButtonFSM::SetPropertyState"},"parameters":["Object","Behavior","=","\"Idle\""]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"ButtonStates::ButtonFSM::PropertyMouseIsInside"},"parameters":["Object","Behavior"]},{"type":{"value":"ButtonStates::ButtonFSM::PropertyState"},"parameters":["Object","Behavior","=","\"Idle\""]}],"actions":[{"type":{"value":"ButtonStates::ButtonFSM::SetPropertyState"},"parameters":["Object","Behavior","=","\"Hovered\""]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"inverted":true,"value":"ButtonStates::ButtonFSM::PropertyTouchIsInside"},"parameters":["Object","Behavior"]},{"type":{"value":"ButtonStates::ButtonFSM::PropertyState"},"parameters":["Object","Behavior","=","\"PressedInside\""]}],"actions":[{"type":{"value":"ButtonStates::ButtonFSM::SetPropertyState"},"parameters":["Object","Behavior","=","\"PressedOutside\""]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"ButtonStates::ButtonFSM::PropertyTouchIsInside"},"parameters":["Object","Behavior"]},{"type":{"value":"ButtonStates::ButtonFSM::PropertyState"},"parameters":["Object","Behavior","=","\"PressedOutside\""]}],"actions":[{"type":{"value":"ButtonStates::ButtonFSM::SetPropertyState"},"parameters":["Object","Behavior","=","\"PressedInside\""]}]}],"parameters":[]},{"colorB":228,"colorG":176,"colorR":74,"creationTime":0,"name":"Handle touch end","source":"","type":"BuiltinCommonInstructions::Group","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"HasTouchEnded"},"parameters":["","TouchId"]}],"actions":[{"type":{"value":"ButtonStates::ButtonFSM::SetPropertyTouchId"},"parameters":["Object","Behavior","=","0"]}],"events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"ButtonStates::ButtonFSM::PropertyState"},"parameters":["Object","Behavior","=","\"PressedInside\""]}],"actions":[{"type":{"value":"ButtonStates::ButtonFSM::SetPropertyState"},"parameters":["Object","Behavior","=","\"Validated\""]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"inverted":true,"value":"ButtonStates::ButtonFSM::PropertyState"},"parameters":["Object","Behavior","=","\"PressedInside\""]},{"type":{"inverted":true,"value":"ButtonStates::ButtonFSM::PropertyState"},"parameters":["Object","Behavior","=","\"Validated\""]}],"actions":[{"type":{"value":"ButtonStates::ButtonFSM::SetPropertyState"},"parameters":["Object","Behavior","=","\"Idle\""]}]}]}],"parameters":[]}],"parameters":[]}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"ButtonStates::ButtonFSM","type":"behavior"}],"objectGroups":[]},{"fullName":"","functionType":"Action","name":"onDeActivate","sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"ButtonStates::ButtonFSM::ResetState"},"parameters":["Object","Behavior",""]}]}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"ButtonStates::ButtonFSM","type":"behavior"}],"objectGroups":[]},{"description":"Reset the state of the button.","fullName":"Reset state","functionType":"Action","name":"ResetState","private":true,"sentence":"Reset the button state of _PARAM0_","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"ButtonStates::ButtonFSM::SetPropertyState"},"parameters":["Object","Behavior","=","\"Idle\""]},{"type":{"value":"ButtonStates::ButtonFSM::SetPropertyTouchId"},"parameters":["Object","Behavior","=","0"]}]}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"ButtonStates::ButtonFSM","type":"behavior"}],"objectGroups":[]},{"description":"Check if the button is not used.","fullName":"Is idle","functionType":"Condition","name":"IsIdle","sentence":"_PARAM0_ is idle","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"ButtonStates::ButtonFSM::PropertyState"},"parameters":["Object","Behavior","=","\"Idle\""]}],"actions":[{"type":{"value":"SetReturnBoolean"},"parameters":["True"]}]}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"ButtonStates::ButtonFSM","type":"behavior"}],"objectGroups":[]},{"description":"Check if the button was just clicked.","fullName":"Is clicked","functionType":"Condition","name":"IsClicked","sentence":"_PARAM0_ is clicked","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"ButtonStates::ButtonFSM::PropertyState"},"parameters":["Object","Behavior","=","\"Validated\""]}],"actions":[{"type":{"value":"SetReturnBoolean"},"parameters":["True"]}]}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"ButtonStates::ButtonFSM","type":"behavior"}],"objectGroups":[]},{"description":"Check if the cursor is hovered over the button.","fullName":"Is hovered","functionType":"Condition","name":"IsHovered","sentence":"_PARAM0_ is hovered","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"ButtonStates::ButtonFSM::PropertyState"},"parameters":["Object","Behavior","=","\"Hovered\""]}],"actions":[{"type":{"value":"SetReturnBoolean"},"parameters":["True"]}]}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"ButtonStates::ButtonFSM","type":"behavior"}],"objectGroups":[]},{"description":"Check if the button is either hovered or pressed but not hovered.","fullName":"Is focused","functionType":"Condition","name":"IsFocused","sentence":"_PARAM0_ is focused","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"ButtonStates::ButtonFSM::PropertyState"},"parameters":["Object","Behavior","=","\"Hovered\""]}],"actions":[{"type":{"value":"SetReturnBoolean"},"parameters":["True"]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"ButtonStates::ButtonFSM::PropertyState"},"parameters":["Object","Behavior","=","\"PressedOutside\""]}],"actions":[{"type":{"value":"SetReturnBoolean"},"parameters":["True"]}]}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"ButtonStates::ButtonFSM","type":"behavior"}],"objectGroups":[]},{"description":"Check if the button is currently being pressed with mouse or touch.","fullName":"Is pressed","functionType":"Condition","name":"IsPressed","sentence":"_PARAM0_ is pressed","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"ButtonStates::ButtonFSM::PropertyState"},"parameters":["Object","Behavior","=","\"PressedInside\""]}],"actions":[{"type":{"value":"SetReturnBoolean"},"parameters":["True"]}]}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"ButtonStates::ButtonFSM","type":"behavior"}],"objectGroups":[]},{"description":"Check if the button is currently being pressed outside with mouse or touch.","fullName":"Is held outside","functionType":"Condition","name":"IsPressedOutside","sentence":"_PARAM0_ is held outside","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"ButtonStates::ButtonFSM::PropertyState"},"parameters":["Object","Behavior","=","\"PressedOutside\""]}],"actions":[{"type":{"value":"SetReturnBoolean"},"parameters":["True"]}]}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"ButtonStates::ButtonFSM","type":"behavior"}],"objectGroups":[]},{"description":"the touch id that is using the button or 0 if none.","fullName":"Touch id","functionType":"ExpressionAndCondition","name":"TouchId","sentence":"the touch id","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetReturnNumber"},"parameters":["TouchId"]}]}],"expressionType":{"type":"expression"},"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"ButtonStates::ButtonFSM","type":"behavior"}],"objectGroups":[]}],"propertyDescriptors":[{"value":"true","type":"Boolean","label":"","description":"Should check hovering","group":"","extraInformation":[],"hidden":true,"name":"ShouldCheckHovering"},{"value":"Idle","type":"Choice","label":"State","description":"","group":"","extraInformation":["Idle","Hovered","PressedInside","PressedOutside","Validated"],"hidden":true,"name":"State"},{"value":"0","type":"Number","label":"Touch id","description":"","group":"","extraInformation":[],"hidden":true,"name":"TouchId"},{"value":"","type":"Boolean","label":"Touch is inside","description":"","group":"","extraInformation":[],"hidden":true,"name":"TouchIsInside"},{"value":"","type":"Boolean","label":"Mouse is inside","description":"","group":"","extraInformation":[],"hidden":true,"name":"MouseIsInside"},{"value":"","type":"Number","label":"","description":"","group":"","extraInformation":[],"hidden":true,"name":"Index"}],"sharedPropertyDescriptors":[]},{"description":"Enable effects on buttons based on their state.","fullName":"Button object effects","name":"ButtonObjectEffects","objectType":"","eventsFunctions":[{"fullName":"","functionType":"Action","name":"onCreated","sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"EffectCapability::EffectBehavior::EnableEffect"},"parameters":["Object","Effect","IdleEffect","yes"]},{"type":{"value":"EffectCapability::EffectBehavior::EnableEffect"},"parameters":["Object","Effect","FocusedEffect","no"]},{"type":{"value":"EffectCapability::EffectBehavior::EnableEffect"},"parameters":["Object","Effect","PressedEffect","no"]}]}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"ButtonStates::ButtonObjectEffects","type":"behavior"}],"objectGroups":[]},{"fullName":"","functionType":"Action","name":"doStepPreEvents","sentence":"","events":[{"colorB":228,"colorG":176,"colorR":74,"creationTime":0,"name":"States","source":"","type":"BuiltinCommonInstructions::Group","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"EffectCapability::EffectBehavior::EnableEffect"},"parameters":["Object","Effect","IdleEffect","no"]},{"type":{"value":"EffectCapability::EffectBehavior::EnableEffect"},"parameters":["Object","Effect","FocusedEffect","no"]},{"type":{"value":"EffectCapability::EffectBehavior::EnableEffect"},"parameters":["Object","Effect","PressedEffect","no"]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"ButtonStates::ButtonObjectEffects::PropertyIdleEffect"},"parameters":["Object","Behavior","!=","\"\""]},{"type":{"value":"ButtonStates::ButtonFSM::IsIdle"},"parameters":["Object","ButtonFSM",""]}],"actions":[{"type":{"value":"EffectCapability::EffectBehavior::EnableEffect"},"parameters":["Object","Effect","IdleEffect","yes"]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"ButtonStates::ButtonObjectEffects::PropertyFocusedEffect"},"parameters":["Object","Behavior","!=","\"\""]},{"type":{"value":"ButtonStates::ButtonFSM::IsFocused"},"parameters":["Object","ButtonFSM",""]}],"actions":[{"type":{"value":"EffectCapability::EffectBehavior::EnableEffect"},"parameters":["Object","Effect","FocusedEffect","yes"]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"ButtonStates::ButtonObjectEffects::PropertyPressedEffect"},"parameters":["Object","Behavior","!=","\"\""]},{"type":{"value":"ButtonStates::ButtonFSM::IsPressed"},"parameters":["Object","ButtonFSM",""]}],"actions":[{"type":{"value":"EffectCapability::EffectBehavior::EnableEffect"},"parameters":["Object","Effect","PressedEffect","yes"]}]}],"parameters":[]}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"ButtonStates::ButtonObjectEffects","type":"behavior"}],"objectGroups":[]},{"description":"the idle state effect of the object.","fullName":"Idle state effect","functionType":"ExpressionAndCondition","group":"Button object effects configuration","name":"IdleEffect","sentence":"the idle state effect","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetReturnString"},"parameters":["IdleEffect"]}]}],"expressionType":{"type":"string"},"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"ButtonStates::ButtonObjectEffects","type":"behavior"}],"objectGroups":[]},{"fullName":"","functionType":"ActionWithOperator","getterName":"IdleEffect","name":"SetIdleEffect","sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"ButtonStates::ButtonObjectEffects::SetPropertyIdleEffect"},"parameters":["Object","Behavior","=","Value"]}]}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"ButtonStates::ButtonObjectEffects","type":"behavior"}],"objectGroups":[]},{"description":"the focused state effect of the object. The state is Focused when the button is hovered or held outside.","fullName":"Focused state effect","functionType":"ExpressionAndCondition","group":"Button object effects configuration","name":"FocusedEffect","sentence":"the focused state effect","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetReturnString"},"parameters":["FocusedEffect"]}]}],"expressionType":{"type":"string"},"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"ButtonStates::ButtonObjectEffects","type":"behavior"}],"objectGroups":[]},{"fullName":"","functionType":"ActionWithOperator","getterName":"FocusedEffect","name":"SetFocusedEffect","sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"ButtonStates::ButtonObjectEffects::SetPropertyFocusedEffect"},"parameters":["Object","Behavior","=","Value"]}]}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"ButtonStates::ButtonObjectEffects","type":"behavior"}],"objectGroups":[]},{"description":"the pressed state effect of the object.","fullName":"Pressed state effect","functionType":"ExpressionAndCondition","group":"Button object effects configuration","name":"PressedEffect","sentence":"the pressed state effect","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetReturnString"},"parameters":["PressedEffect"]}]}],"expressionType":{"type":"string"},"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"ButtonStates::ButtonObjectEffects","type":"behavior"}],"objectGroups":[]},{"fullName":"","functionType":"ActionWithOperator","getterName":"PressedEffect","name":"SetPressedEffect","sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"ButtonStates::ButtonObjectEffects::SetPropertyPressedEffect"},"parameters":["Object","Behavior","=","Value"]}]}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"ButtonStates::ButtonObjectEffects","type":"behavior"}],"objectGroups":[]}],"propertyDescriptors":[{"value":"","type":"Behavior","label":"Button states","description":"","group":"","extraInformation":["ButtonStates::ButtonFSM"],"name":"ButtonFSM"},{"value":"","type":"Behavior","label":"Effect capability","description":"","group":"","extraInformation":["EffectCapability::EffectBehavior"],"name":"Effect"},{"value":"","type":"String","label":"Idle state effect","description":"","group":"Effects","extraInformation":[],"name":"IdleEffect"},{"value":"","type":"String","label":"Focused state effect","description":"The state is Focused when the button is hovered or held outside.","group":"Effects","extraInformation":[],"name":"FocusedEffect"},{"value":"","type":"String","label":"Pressed state effect","description":"","group":"Effects","extraInformation":[],"name":"PressedEffect"}],"sharedPropertyDescriptors":[]},{"description":"Change the animation of buttons according to their state.","fullName":"Button animation","name":"ButtonAnimationName","objectType":"","eventsFunctions":[{"fullName":"","functionType":"Action","name":"onCreated","sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"AnimatableCapability::AnimatableBehavior::SetName"},"parameters":["Object","Animation","=","IdleAnimationName"]}]}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"ButtonStates::ButtonAnimationName","type":"behavior"}],"objectGroups":[]},{"fullName":"","functionType":"Action","name":"doStepPreEvents","sentence":"","events":[{"colorB":228,"colorG":176,"colorR":74,"creationTime":0,"name":"Change based on state","source":"","type":"BuiltinCommonInstructions::Group","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"ButtonStates::ButtonFSM::IsIdle"},"parameters":["Object","ButtonFSM",""]}],"actions":[{"type":{"value":"AnimatableCapability::AnimatableBehavior::SetName"},"parameters":["Object","Animation","=","IdleAnimationName"]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"ButtonStates::ButtonFSM::IsFocused"},"parameters":["Object","ButtonFSM",""]}],"actions":[{"type":{"value":"AnimatableCapability::AnimatableBehavior::SetName"},"parameters":["Object","Animation","=","FocusedAnimationName"]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"ButtonStates::ButtonFSM::IsPressed"},"parameters":["Object","ButtonFSM",""]}],"actions":[{"type":{"value":"AnimatableCapability::AnimatableBehavior::SetName"},"parameters":["Object","Animation","=","PressedAnimationName"]}]}],"parameters":[]}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"ButtonStates::ButtonAnimationName","type":"behavior"}],"objectGroups":[]},{"description":"the idle state animation name of the object.","fullName":"Idle state animation name","functionType":"ExpressionAndCondition","group":"Button animation configuration","name":"IdleAnimationName","sentence":"the idle state animation name","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetReturnString"},"parameters":["IdleAnimationName"]}]}],"expressionType":{"type":"string"},"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"ButtonStates::ButtonAnimationName","type":"behavior"}],"objectGroups":[]},{"fullName":"","functionType":"ActionWithOperator","getterName":"IdleAnimationName","name":"SetIdleAnimationName","sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"ButtonStates::ButtonAnimationName::SetPropertyIdleAnimationName"},"parameters":["Object","Behavior","=","Value"]}]}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"ButtonStates::ButtonAnimationName","type":"behavior"}],"objectGroups":[]},{"description":"the focused state animation name of the object. The state is Focused when the button is hovered or held outside.","fullName":"Focused state animation name","functionType":"ExpressionAndCondition","group":"Button animation configuration","name":"FocusedAnimationName","sentence":"the focused state animation name","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetReturnString"},"parameters":["FocusedAnimationName"]}]}],"expressionType":{"type":"string"},"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"ButtonStates::ButtonAnimationName","type":"behavior"}],"objectGroups":[]},{"fullName":"","functionType":"ActionWithOperator","getterName":"FocusedAnimationName","name":"SetFocusedAnimationName","sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"ButtonStates::ButtonAnimationName::SetPropertyFocusedAnimationName"},"parameters":["Object","Behavior","=","Value"]}]}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"ButtonStates::ButtonAnimationName","type":"behavior"}],"objectGroups":[]},{"description":"the pressed state animation name of the object.","fullName":"Pressed state animation name","functionType":"ExpressionAndCondition","group":"Button animation configuration","name":"PressedAnimationName","sentence":"the pressed state animation name","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetReturnString"},"parameters":["PressedAnimationName"]}]}],"expressionType":{"type":"string"},"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"ButtonStates::ButtonAnimationName","type":"behavior"}],"objectGroups":[]},{"fullName":"","functionType":"ActionWithOperator","getterName":"PressedAnimationName","name":"SetPressedAnimationName","sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"ButtonStates::ButtonAnimationName::SetPropertyPressedAnimationName"},"parameters":["Object","Behavior","=","Value"]}]}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"ButtonStates::ButtonAnimationName","type":"behavior"}],"objectGroups":[]}],"propertyDescriptors":[{"value":"","type":"Behavior","label":"Animatable capability","description":"","group":"","extraInformation":["AnimatableCapability::AnimatableBehavior"],"name":"Animation"},{"value":"","type":"Behavior","label":"Button states","description":"","group":"","extraInformation":["ButtonStates::ButtonFSM"],"name":"ButtonFSM"},{"value":"Idle","type":"String","label":"Idle state animation name","description":"","group":"Animation","extraInformation":[],"name":"IdleAnimationName"},{"value":"Focused","type":"String","label":"Focused state animation name","description":"The state is Focused when the button is hovered or held outside.","group":"Animation","extraInformation":[],"name":"FocusedAnimationName"},{"value":"Pressed","type":"String","label":"Pressed state animation name","description":"","group":"Animation","extraInformation":[],"name":"PressedAnimationName"}],"sharedPropertyDescriptors":[]},{"description":"Smoothly change an effect on buttons according to their state.","fullName":"Button object effect tween","name":"ButtonObjectEffectTween","objectType":"","eventsFunctions":[{"fullName":"","functionType":"Action","name":"onCreated","sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"ButtonStates::ButtonObjectEffectTween::SetPropertyEffectValue"},"parameters":["Object","Behavior","=","IdleValue"]}]}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"ButtonStates::ButtonObjectEffectTween","type":"behavior"}],"objectGroups":[]},{"fullName":"","functionType":"Action","name":"doStepPreEvents","sentence":"","events":[{"colorB":228,"colorG":176,"colorR":74,"creationTime":0,"name":"States","source":"","type":"BuiltinCommonInstructions::Group","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"ButtonStates::ButtonFSM::IsIdle"},"parameters":["Object","ButtonFSM",""]},{"type":{"value":"ButtonStates::ButtonObjectEffectTween::PropertyPreviousState"},"parameters":["Object","Behavior","!=","\"Idle\""]}],"actions":[{"type":{"value":"ButtonStates::ButtonObjectEffectTween::SetPropertyPreviousState"},"parameters":["Object","Behavior","=","\"Idle\""]},{"type":{"value":"ButtonStates::ButtonObjectEffectTween::FadeOut"},"parameters":["Object","Behavior","IdleValue",""]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"ButtonStates::ButtonFSM::IsFocused"},"parameters":["Object","ButtonFSM",""]}],"actions":[],"events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"ButtonStates::ButtonObjectEffectTween::PropertyPreviousState"},"parameters":["Object","Behavior","=","\"Idle\""]}],"actions":[{"type":{"value":"ButtonStates::ButtonObjectEffectTween::SetPropertyPreviousState"},"parameters":["Object","Behavior","=","\"Focused\""]},{"type":{"value":"ButtonStates::ButtonObjectEffectTween::FadeIn"},"parameters":["Object","Behavior","FocusedValue",""]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"ButtonStates::ButtonObjectEffectTween::PropertyPreviousState"},"parameters":["Object","Behavior","=","\"Pressed\""]}],"actions":[{"type":{"value":"ButtonStates::ButtonObjectEffectTween::SetPropertyPreviousState"},"parameters":["Object","Behavior","=","\"Focused\""]},{"type":{"value":"ButtonStates::ButtonObjectEffectTween::FadeOut"},"parameters":["Object","Behavior","FocusedValue",""]}]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"ButtonStates::ButtonFSM::IsPressed"},"parameters":["Object","ButtonFSM",""]},{"type":{"value":"ButtonStates::ButtonObjectEffectTween::PropertyPreviousState"},"parameters":["Object","Behavior","!=","\"Pressed\""]}],"actions":[{"type":{"value":"ButtonStates::ButtonObjectEffectTween::SetPropertyPreviousState"},"parameters":["Object","Behavior","=","\"Pressed\""]},{"type":{"value":"ButtonStates::ButtonObjectEffectTween::FadeIn"},"parameters":["Object","Behavior","PressedValue",""]}]}],"parameters":[]},{"colorB":228,"colorG":176,"colorR":74,"creationTime":0,"name":"Tween","source":"","type":"BuiltinCommonInstructions::Group","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"ButtonStates::ButtonObjectEffectTween::PropertyTweenState"},"parameters":["Object","Behavior","=","\"FadeIn\""]}],"actions":[{"type":{"value":"ButtonStates::ButtonObjectEffectTween::PlayTween"},"parameters":["Object","Behavior","FadeInDuration","FadeInEasing",""]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"ButtonStates::ButtonObjectEffectTween::PropertyTweenState"},"parameters":["Object","Behavior","=","\"FadeOut\""]}],"actions":[{"type":{"value":"ButtonStates::ButtonObjectEffectTween::PlayTween"},"parameters":["Object","Behavior","FadeOutDuration","FadeOutEasing",""]}]}],"parameters":[]}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"ButtonStates::ButtonObjectEffectTween","type":"behavior"}],"objectGroups":[]},{"fullName":"Time delta","functionType":"Expression","name":"TimeDelta","private":true,"sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetReturnNumber"},"parameters":["TimeDelta() * LayerTimeScale(Object.Layer())"]}]}],"expressionType":{"type":"expression"},"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"ButtonStates::ButtonObjectEffectTween","type":"behavior"}],"objectGroups":[]},{"fullName":"Fade in","functionType":"Action","name":"FadeIn","private":true,"sentence":"_PARAM0_ fade in to _PARAM2_","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"ButtonStates::ButtonObjectEffectTween::SetPropertyTweenTime"},"parameters":["Object","Behavior","=","0"]},{"type":{"value":"ButtonStates::ButtonObjectEffectTween::SetPropertyTweenState"},"parameters":["Object","Behavior","=","\"FadeIn\""]},{"type":{"value":"ButtonStates::ButtonObjectEffectTween::SetPropertyTweenInitialValue"},"parameters":["Object","Behavior","=","EffectValue"]},{"type":{"value":"ButtonStates::ButtonObjectEffectTween::SetPropertyTweenTargetedValue"},"parameters":["Object","Behavior","=","Value"]}]}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"ButtonStates::ButtonObjectEffectTween","type":"behavior"},{"description":"Value","name":"Value","type":"expression"}],"objectGroups":[]},{"fullName":"Fade out","functionType":"Action","name":"FadeOut","private":true,"sentence":"_PARAM0_ fade out to _PARAM2_","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"ButtonStates::ButtonObjectEffectTween::SetPropertyTweenTime"},"parameters":["Object","Behavior","=","0"]},{"type":{"value":"ButtonStates::ButtonObjectEffectTween::SetPropertyTweenState"},"parameters":["Object","Behavior","=","\"FadeOut\""]},{"type":{"value":"ButtonStates::ButtonObjectEffectTween::SetPropertyTweenInitialValue"},"parameters":["Object","Behavior","=","EffectValue"]},{"type":{"value":"ButtonStates::ButtonObjectEffectTween::SetPropertyTweenTargetedValue"},"parameters":["Object","Behavior","=","Value"]}]}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"ButtonStates::ButtonObjectEffectTween","type":"behavior"},{"description":"Value","name":"Value","type":"expression"}],"objectGroups":[]},{"fullName":"Play tween","functionType":"Action","name":"PlayTween","private":true,"sentence":"Tween the effect property of object _PARAM0_ over _PARAM2_ seconds with _PARAM3_ easing","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"ButtonStates::ButtonObjectEffectTween::PropertyTweenTime"},"parameters":["Object","Behavior","<","Duration"]}],"actions":[{"type":{"value":"ButtonStates::ButtonObjectEffectTween::SetPropertyTweenTime"},"parameters":["Object","Behavior","+","Object.Behavior::TimeDelta()"]},{"type":{"value":"ButtonStates::ButtonObjectEffectTween::SetPropertyEffectValue"},"parameters":["Object","Behavior","=","Tween::Ease(Easing, TweenInitialValue, TweenTargetedValue, TweenTime / Duration)"]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"ButtonStates::ButtonObjectEffectTween::PropertyTweenTime"},"parameters":["Object","Behavior",">=","Duration"]}],"actions":[{"type":{"value":"ButtonStates::ButtonObjectEffectTween::SetPropertyTweenState"},"parameters":["Object","Behavior","=","\"NoTween\""]},{"type":{"value":"ButtonStates::ButtonObjectEffectTween::SetPropertyEffectValue"},"parameters":["Object","Behavior","=","TweenTargetedValue"]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"EffectCapability::EffectBehavior::SetEffectDoubleParameter"},"parameters":["Object","Effect","EffectName","EffectProperty","EffectValue"]}]}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"ButtonStates::ButtonObjectEffectTween","type":"behavior"},{"description":"Duration (in seconds)","name":"Duration","type":"expression"},{"description":"Easing","name":"Easing","supplementaryInformation":"[]","type":"string"}],"objectGroups":[]},{"description":"the effect name of the object.","fullName":"Effect name","functionType":"ExpressionAndCondition","group":"Button effect tween configuration","name":"EffectName","sentence":"the effect name","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetReturnString"},"parameters":["EffectName"]}]}],"expressionType":{"type":"string"},"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"ButtonStates::ButtonObjectEffectTween","type":"behavior"}],"objectGroups":[]},{"description":"the effect parameter of the object. The effect parameter names can be found in the effects tab with the \"Show parameter names\" action of the drop down menu.","fullName":"Effect parameter","functionType":"ExpressionAndCondition","group":"Button effect tween configuration","name":"EffectProperty","sentence":"the effect parameter","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetReturnString"},"parameters":["EffectProperty"]}]}],"expressionType":{"type":"string"},"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"ButtonStates::ButtonObjectEffectTween","type":"behavior"}],"objectGroups":[]},{"description":"Change the effect parameter of the object. The effect parameter names can be found in the effects tab with the \"Show parameter names\" action of the drop down menu.","fullName":"Effect parameter","functionType":"Action","getterName":"EffectName","group":"Button effect tween configuration","name":"SetEffectProperty","sentence":"Change the tweened effect of _PARAM0_ to _PARAM2_ with parameter _PARAM3_","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"ButtonStates::ButtonObjectEffectTween::SetPropertyEffectName"},"parameters":["Object","Behavior","=","Value"]},{"type":{"value":"ButtonStates::ButtonObjectEffectTween::SetPropertyEffectProperty"},"parameters":["Object","Behavior","=","Value"]}]}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"ButtonStates::ButtonObjectEffectTween","type":"behavior"},{"description":"Effect name","name":"EffectName","type":"string"},{"description":"Parameter name","name":"PropertyName","type":"string"}],"objectGroups":[]},{"description":"the idle effect parameter value of the object.","fullName":"Idle effect parameter value","functionType":"ExpressionAndCondition","group":"Button effect tween configuration","name":"IdleValue","sentence":"the idle effect parameter value","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetReturnNumber"},"parameters":["IdleValue"]}]}],"expressionType":{"type":"expression"},"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"ButtonStates::ButtonObjectEffectTween","type":"behavior"}],"objectGroups":[]},{"fullName":"","functionType":"ActionWithOperator","getterName":"IdleValue","name":"SetIdleValue","sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"ButtonStates::ButtonObjectEffectTween::SetPropertyIdleValue"},"parameters":["Object","Behavior","=","Value"]}]}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"ButtonStates::ButtonObjectEffectTween","type":"behavior"}],"objectGroups":[]},{"description":"the focused effect parameter value of the object. The state is Focused when the button is hovered or held outside.","fullName":"Focused effect parameter value","functionType":"ExpressionAndCondition","group":"Button effect tween configuration","name":"FocusedValue","sentence":"the focused effect parameter value","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetReturnNumber"},"parameters":["FocusedValue"]}]}],"expressionType":{"type":"expression"},"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"ButtonStates::ButtonObjectEffectTween","type":"behavior"}],"objectGroups":[]},{"fullName":"","functionType":"ActionWithOperator","getterName":"FocusedValue","name":"SetFocusedValue","sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"ButtonStates::ButtonObjectEffectTween::SetPropertyFocusedValue"},"parameters":["Object","Behavior","=","Value"]}]}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"ButtonStates::ButtonObjectEffectTween","type":"behavior"}],"objectGroups":[]},{"description":"the pressed effect parameter value of the object.","fullName":"Pressed effect parameter value","functionType":"ExpressionAndCondition","group":"Button effect tween configuration","name":"PressedValue","sentence":"the pressed effect parameter value","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetReturnNumber"},"parameters":["PressedValue"]}]}],"expressionType":{"type":"expression"},"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"ButtonStates::ButtonObjectEffectTween","type":"behavior"}],"objectGroups":[]},{"fullName":"","functionType":"ActionWithOperator","getterName":"PressedValue","name":"SetPressedValue","sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"ButtonStates::ButtonObjectEffectTween::SetPropertyPressedValue"},"parameters":["Object","Behavior","=","Value"]}]}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"ButtonStates::ButtonObjectEffectTween","type":"behavior"}],"objectGroups":[]},{"description":"the fade-in easing of the object.","fullName":"Fade-in easing","functionType":"ExpressionAndCondition","group":"Button effect tween configuration","name":"FadeInEasing","sentence":"the fade-in easing","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetReturnString"},"parameters":["FadeInEasing"]}]}],"expressionType":{"supplementaryInformation":"[\"linear\",\"easeInQuad\",\"easeOutQuad\",\"easeInOutQuad\",\"easeInCubic\",\"easeOutCubic\",\"easeInOutCubic\",\"easeInQuart\",\"easeOutQuart\",\"easeInOutQuart\",\"easeInQuint\",\"easeOutQuint\",\"easeInOutQuint\",\"easeInOutSine\",\"easeInExpo\",\"easeOutExpo\",\"easeInOutExpo\",\"easeInCirc\",\"easeOutCirc\",\"easeInOutCirc\",\"easeOutBounce\",\"easeInBack\",\"easeOutBack\",\"easeInOutBack\",\"elastic\",\"swingFromTo\",\"swingFrom\",\"swingTo\",\"bounce\",\"bouncePast\",\"easeFromTo\",\"easeFrom\",\"easeTo\"]","type":"stringWithSelector"},"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"ButtonStates::ButtonObjectEffectTween","type":"behavior"}],"objectGroups":[]},{"fullName":"","functionType":"ActionWithOperator","getterName":"FadeInEasing","name":"SetFadeInEasing","sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"ButtonStates::ButtonObjectEffectTween::SetPropertyFadeInEasing"},"parameters":["Object","Behavior","=","Value"]}]}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"ButtonStates::ButtonObjectEffectTween","type":"behavior"}],"objectGroups":[]},{"description":"the fade-out easing of the object.","fullName":"Fade-out easing","functionType":"ExpressionAndCondition","group":"Button effect tween configuration","name":"FadeOutEasing","sentence":"the fade-out easing","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetReturnString"},"parameters":["FadeOutEasing"]}]}],"expressionType":{"supplementaryInformation":"[\"linear\",\"easeInQuad\",\"easeOutQuad\",\"easeInOutQuad\",\"easeInCubic\",\"easeOutCubic\",\"easeInOutCubic\",\"easeInQuart\",\"easeOutQuart\",\"easeInOutQuart\",\"easeInQuint\",\"easeOutQuint\",\"easeInOutQuint\",\"easeInOutSine\",\"easeInExpo\",\"easeOutExpo\",\"easeInOutExpo\",\"easeInCirc\",\"easeOutCirc\",\"easeInOutCirc\",\"easeOutBounce\",\"easeInBack\",\"easeOutBack\",\"easeInOutBack\",\"elastic\",\"swingFromTo\",\"swingFrom\",\"swingTo\",\"bounce\",\"bouncePast\",\"easeFromTo\",\"easeFrom\",\"easeTo\"]","type":"stringWithSelector"},"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"ButtonStates::ButtonObjectEffectTween","type":"behavior"}],"objectGroups":[]},{"fullName":"","functionType":"ActionWithOperator","getterName":"FadeOutEasing","name":"SetFadeOutEasing","sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"ButtonStates::ButtonObjectEffectTween::SetPropertyFadeOutEasing"},"parameters":["Object","Behavior","=","Value"]}]}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"ButtonStates::ButtonObjectEffectTween","type":"behavior"}],"objectGroups":[]},{"description":"the fade-in duration of the object.","fullName":"Fade-in duration","functionType":"ExpressionAndCondition","group":"Button effect tween configuration","name":"FadeInDuration","sentence":"the fade-in duration","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetReturnNumber"},"parameters":["FadeInDuration"]}]}],"expressionType":{"type":"expression"},"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"ButtonStates::ButtonObjectEffectTween","type":"behavior"}],"objectGroups":[]},{"fullName":"","functionType":"ActionWithOperator","getterName":"FadeInDuration","name":"SetFadeInDuration","sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"ButtonStates::ButtonObjectEffectTween::SetPropertyFadeInDuration"},"parameters":["Object","Behavior","=","Value"]}]}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"ButtonStates::ButtonObjectEffectTween","type":"behavior"}],"objectGroups":[]},{"description":"the fade-out duration of the object.","fullName":"Fade-out duration","functionType":"ExpressionAndCondition","group":"Button effect tween configuration","name":"FadeOutDuration","sentence":"the fade-out duration","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetReturnNumber"},"parameters":["FadeOutDuration"]}]}],"expressionType":{"type":"expression"},"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"ButtonStates::ButtonObjectEffectTween","type":"behavior"}],"objectGroups":[]},{"fullName":"","functionType":"ActionWithOperator","getterName":"FadeOutDuration","name":"SetFadeOutDuration","sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"ButtonStates::ButtonObjectEffectTween::SetPropertyFadeOutDuration"},"parameters":["Object","Behavior","=","Value"]}]}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"ButtonStates::ButtonObjectEffectTween","type":"behavior"}],"objectGroups":[]}],"propertyDescriptors":[{"value":"","type":"Behavior","label":"Button states","description":"","group":"","extraInformation":["ButtonStates::ButtonFSM"],"name":"ButtonFSM"},{"value":"","type":"Behavior","label":"Effect capability","description":"","group":"","extraInformation":["EffectCapability::EffectBehavior"],"name":"Effect"},{"value":"Effect","type":"String","label":"Effect name","description":"","group":"Effect","extraInformation":[],"name":"EffectName"},{"value":"","type":"String","label":"Effect parameter","description":"The effect parameter names can be found in the effects tab with the \"Show parameter names\" action of the drop down menu.","group":"Effect","extraInformation":[],"name":"EffectProperty"},{"value":"0","type":"Number","label":"Idle effect parameter value","description":"","group":"Value","extraInformation":[],"name":"IdleValue"},{"value":"0","type":"Number","label":"Focused effect parameter value","description":"The state is Focused when the button is hovered or held outside.","group":"Value","extraInformation":[],"name":"FocusedValue"},{"value":"0","type":"Number","label":"Pressed effect parameter value","description":"","group":"Value","extraInformation":[],"name":"PressedValue"},{"value":"easeInOutQuad","type":"Choice","label":"Fade-in easing","description":"","group":"Speed","extraInformation":["linear","easeInQuad","easeOutQuad","easeInOutQuad","easeInCubic","easeOutCubic","easeInOutCubic","easeInQuart","easeOutQuart","easeInOutQuart","easeInQuint","easeOutQuint","easeInOutQuint","easeInOutSine","easeInExpo","easeOutExpo","easeInOutExpo","easeInCirc","easeOutCirc","easeInOutCirc","easeOutBounce","easeInBack","easeOutBack","easeInOutBack","elastic","swingFromTo","swingFrom","swingTo","bounce","bouncePast","easeFromTo","easeFrom","easeTo"],"name":"FadeInEasing"},{"value":"easeInOutQuad","type":"Choice","label":"Fade-out easing","description":"","group":"Speed","extraInformation":["linear","easeInQuad","easeOutQuad","easeInOutQuad","easeInCubic","easeOutCubic","easeInOutCubic","easeInQuart","easeOutQuart","easeInOutQuart","easeInQuint","easeOutQuint","easeInOutQuint","easeInOutSine","easeInExpo","easeOutExpo","easeInOutExpo","easeInCirc","easeOutCirc","easeInOutCirc","easeOutBounce","easeInBack","easeOutBack","easeInOutBack","elastic","swingFromTo","swingFrom","swingTo","bounce","bouncePast","easeFromTo","easeFrom","easeTo"],"name":"FadeOutEasing"},{"value":"0.125","type":"Number","unit":"Second","label":"Fade-in duration","description":"","group":"Speed","extraInformation":[],"name":"FadeInDuration"},{"value":"0.5","type":"Number","unit":"Second","label":"Fade-out duration","description":"","group":"Speed","extraInformation":[],"name":"FadeOutDuration"},{"value":"Idle","type":"Choice","label":"","description":"","group":"","extraInformation":["Idle","Focused","Pressed"],"hidden":true,"name":"PreviousState"},{"value":"0","type":"Number","label":"","description":"","group":"","extraInformation":[],"hidden":true,"name":"TweenInitialValue"},{"value":"0","type":"Number","label":"","description":"","group":"","extraInformation":[],"hidden":true,"name":"TweenTargetedValue"},{"value":"0","type":"Number","label":"","description":"","group":"","extraInformation":[],"hidden":true,"name":"TweenTime"},{"value":"NoTween","type":"Choice","label":"","description":"","group":"","extraInformation":["NoTween","FadeIn","FadeOut"],"hidden":true,"name":"TweenState"},{"value":"0","type":"Number","label":"","description":"","group":"","extraInformation":[],"hidden":true,"name":"EffectValue"}],"sharedPropertyDescriptors":[]},{"description":"Smoothly resize buttons according to their state.","fullName":"Button scale tween","name":"ButtonScaleTween","objectType":"","eventsFunctions":[{"fullName":"","functionType":"Action","name":"onCreated","sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"ScalableCapability::ScalableBehavior::SetValue"},"parameters":["Object","Scale","=","IdleScale"]}]}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"ButtonStates::ButtonScaleTween","type":"behavior"}],"objectGroups":[]},{"fullName":"","functionType":"Action","name":"doStepPreEvents","sentence":"","events":[{"colorB":228,"colorG":176,"colorR":74,"creationTime":0,"name":"Change based on state","source":"","type":"BuiltinCommonInstructions::Group","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"ButtonStates::ButtonFSM::IsIdle"},"parameters":["Object","ButtonFSM",""]},{"type":{"value":"ButtonStates::ButtonScaleTween::PropertyPreviousState"},"parameters":["Object","Behavior","!=","\"Idle\""]}],"actions":[{"type":{"value":"ButtonStates::ButtonScaleTween::SetPropertyPreviousState"},"parameters":["Object","Behavior","=","\"Idle\""]},{"type":{"value":"ButtonStates::ButtonScaleTween::FadeOut"},"parameters":["Object","Behavior","IdleScale",""]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"ButtonStates::ButtonFSM::IsFocused"},"parameters":["Object","ButtonFSM",""]}],"actions":[],"events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"ButtonStates::ButtonScaleTween::PropertyPreviousState"},"parameters":["Object","Behavior","=","\"Idle\""]}],"actions":[{"type":{"value":"ButtonStates::ButtonScaleTween::SetPropertyPreviousState"},"parameters":["Object","Behavior","=","\"Focused\""]},{"type":{"value":"ButtonStates::ButtonScaleTween::FadeIn"},"parameters":["Object","Behavior","FocusedScale",""]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"ButtonStates::ButtonScaleTween::PropertyPreviousState"},"parameters":["Object","Behavior","=","\"Pressed\""]}],"actions":[{"type":{"value":"ButtonStates::ButtonScaleTween::SetPropertyPreviousState"},"parameters":["Object","Behavior","=","\"Focused\""]},{"type":{"value":"ButtonStates::ButtonScaleTween::FadeOut"},"parameters":["Object","Behavior","FocusedScale",""]}]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"ButtonStates::ButtonFSM::IsPressed"},"parameters":["Object","ButtonFSM",""]},{"type":{"value":"ButtonStates::ButtonScaleTween::PropertyPreviousState"},"parameters":["Object","Behavior","!=","\"Pressed\""]}],"actions":[{"type":{"value":"ButtonStates::ButtonScaleTween::SetPropertyPreviousState"},"parameters":["Object","Behavior","=","\"Pressed\""]},{"type":{"value":"ButtonStates::ButtonScaleTween::FadeIn"},"parameters":["Object","Behavior","PressedScale",""]}]}],"parameters":[]}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"ButtonStates::ButtonScaleTween","type":"behavior"}],"objectGroups":[]},{"fullName":"Fade in","functionType":"Action","name":"FadeIn","private":true,"sentence":"_PARAM0_ fade in to _PARAM2_","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"Tween::AddObjectScaleTween"},"parameters":["Object","Tween","\"__ButtonScaleTween.Fade\"","Value","Value","FadeInEasing","1000 * FadeInDuration","no","yes"]}]}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"ButtonStates::ButtonScaleTween","type":"behavior"},{"description":"Value","name":"Value","type":"expression"}],"objectGroups":[]},{"fullName":"Fade out","functionType":"Action","name":"FadeOut","private":true,"sentence":"_PARAM0_ fade out to _PARAM2_","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"Tween::AddObjectScaleTween"},"parameters":["Object","Tween","\"__ButtonScaleTween.Fade\"","Value","Value","FadeOutEasing","1000 * FadeOutDuration","no","yes"]}]}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"ButtonStates::ButtonScaleTween","type":"behavior"},{"description":"Value","name":"Value","type":"expression"}],"objectGroups":[]},{"description":"the idle state size scale of the object.","fullName":"Idle state size scale","functionType":"ExpressionAndCondition","group":"Button scale tween configuration","name":"IdleScale","sentence":"the idle state size scale","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetReturnNumber"},"parameters":["IdleScale"]}]}],"expressionType":{"type":"expression"},"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"ButtonStates::ButtonScaleTween","type":"behavior"}],"objectGroups":[]},{"fullName":"","functionType":"ActionWithOperator","getterName":"IdleScale","name":"SetIdleScale","sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"ButtonStates::ButtonScaleTween::SetPropertyIdleScale"},"parameters":["Object","Behavior","=","Value"]}]}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"ButtonStates::ButtonScaleTween","type":"behavior"}],"objectGroups":[]},{"description":"the focused state size scale of the object. The state is Focused when the button is hovered or held outside.","fullName":"Focused state size scale","functionType":"ExpressionAndCondition","group":"Button scale tween configuration","name":"FocusedScale","sentence":"the focused state size scale","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetReturnNumber"},"parameters":["FocusedScale"]}]}],"expressionType":{"type":"expression"},"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"ButtonStates::ButtonScaleTween","type":"behavior"}],"objectGroups":[]},{"fullName":"","functionType":"ActionWithOperator","getterName":"FocusedScale","name":"SetFocusedScale","sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"ButtonStates::ButtonScaleTween::SetPropertyFocusedScale"},"parameters":["Object","Behavior","=","Value"]}]}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"ButtonStates::ButtonScaleTween","type":"behavior"}],"objectGroups":[]},{"description":"the pressed state size scale of the object.","fullName":"Pressed state size scale","functionType":"ExpressionAndCondition","group":"Button scale tween configuration","name":"PressedScale","sentence":"the pressed state size scale","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetReturnNumber"},"parameters":["PressedScale"]}]}],"expressionType":{"type":"expression"},"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"ButtonStates::ButtonScaleTween","type":"behavior"}],"objectGroups":[]},{"fullName":"","functionType":"ActionWithOperator","getterName":"PressedScale","name":"SetPressedScale","sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"ButtonStates::ButtonScaleTween::SetPropertyPressedScale"},"parameters":["Object","Behavior","=","Value"]}]}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"ButtonStates::ButtonScaleTween","type":"behavior"}],"objectGroups":[]},{"description":"the fade-in duration of the object.","fullName":"Fade-in duration","functionType":"ExpressionAndCondition","group":"Button scale tween configuration","name":"FadeInDuration","sentence":"the fade-in duration","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetReturnNumber"},"parameters":["FadeInDuration"]}]}],"expressionType":{"type":"expression"},"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"ButtonStates::ButtonScaleTween","type":"behavior"}],"objectGroups":[]},{"fullName":"","functionType":"ActionWithOperator","getterName":"FadeInDuration","name":"SetFadeInDuration","sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"ButtonStates::ButtonScaleTween::SetPropertyFadeInDuration"},"parameters":["Object","Behavior","=","Value"]}]}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"ButtonStates::ButtonScaleTween","type":"behavior"}],"objectGroups":[]},{"description":"the fade-out duration of the object.","fullName":"Fade-out duration","functionType":"ExpressionAndCondition","group":"Button scale tween configuration","name":"FadeOutDuration","sentence":"the fade-out duration","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetReturnNumber"},"parameters":["FadeOutDuration"]}]}],"expressionType":{"type":"expression"},"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"ButtonStates::ButtonScaleTween","type":"behavior"}],"objectGroups":[]},{"fullName":"","functionType":"ActionWithOperator","getterName":"FadeOutDuration","name":"SetFadeOutDuration","sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"ButtonStates::ButtonScaleTween::SetPropertyFadeOutDuration"},"parameters":["Object","Behavior","=","Value"]}]}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"ButtonStates::ButtonScaleTween","type":"behavior"}],"objectGroups":[]},{"description":"the fade-in easing of the object.","fullName":"Fade-in easing","functionType":"ExpressionAndCondition","group":"Button scale tween configuration","name":"FadeInEasing","sentence":"the fade-in easing","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetReturnString"},"parameters":["FadeInEasing"]}]}],"expressionType":{"supplementaryInformation":"[\"linear\",\"easeInQuad\",\"easeOutQuad\",\"easeInOutQuad\",\"easeInCubic\",\"easeOutCubic\",\"easeInOutCubic\",\"easeInQuart\",\"easeOutQuart\",\"easeInOutQuart\",\"easeInQuint\",\"easeOutQuint\",\"easeInOutQuint\",\"easeInOutSine\",\"easeInExpo\",\"easeOutExpo\",\"easeInOutExpo\",\"easeInCirc\",\"easeOutCirc\",\"easeInOutCirc\",\"easeOutBounce\",\"easeInBack\",\"easeOutBack\",\"easeInOutBack\",\"elastic\",\"swingFromTo\",\"swingFrom\",\"swingTo\",\"bounce\",\"bouncePast\",\"easeFromTo\",\"easeFrom\",\"easeTo\"]","type":"stringWithSelector"},"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"ButtonStates::ButtonScaleTween","type":"behavior"}],"objectGroups":[]},{"fullName":"","functionType":"ActionWithOperator","getterName":"FadeInEasing","name":"SetFadeInEasing","sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"ButtonStates::ButtonScaleTween::SetPropertyFadeInEasing"},"parameters":["Object","Behavior","=","Value"]}]}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"ButtonStates::ButtonScaleTween","type":"behavior"}],"objectGroups":[]},{"description":"the fade-out easing of the object.","fullName":"Fade-out easing","functionType":"ExpressionAndCondition","group":"Button scale tween configuration","name":"FadeOutEasing","sentence":"the fade-out easing","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetReturnString"},"parameters":["FadeOutEasing"]}]}],"expressionType":{"supplementaryInformation":"[\"linear\",\"easeInQuad\",\"easeOutQuad\",\"easeInOutQuad\",\"easeInCubic\",\"easeOutCubic\",\"easeInOutCubic\",\"easeInQuart\",\"easeOutQuart\",\"easeInOutQuart\",\"easeInQuint\",\"easeOutQuint\",\"easeInOutQuint\",\"easeInOutSine\",\"easeInExpo\",\"easeOutExpo\",\"easeInOutExpo\",\"easeInCirc\",\"easeOutCirc\",\"easeInOutCirc\",\"easeOutBounce\",\"easeInBack\",\"easeOutBack\",\"easeInOutBack\",\"elastic\",\"swingFromTo\",\"swingFrom\",\"swingTo\",\"bounce\",\"bouncePast\",\"easeFromTo\",\"easeFrom\",\"easeTo\"]","type":"stringWithSelector"},"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"ButtonStates::ButtonScaleTween","type":"behavior"}],"objectGroups":[]},{"fullName":"","functionType":"ActionWithOperator","getterName":"FadeOutEasing","name":"SetFadeOutEasing","sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"ButtonStates::ButtonScaleTween::SetPropertyFadeOutEasing"},"parameters":["Object","Behavior","=","Value"]}]}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"ButtonStates::ButtonScaleTween","type":"behavior"}],"objectGroups":[]}],"propertyDescriptors":[{"value":"","type":"Behavior","label":"Scalable capability","description":"","group":"","extraInformation":["ScalableCapability::ScalableBehavior"],"name":"Scale"},{"value":"","type":"Behavior","label":"Button states behavior (required)","description":"","group":"","extraInformation":["ButtonStates::ButtonFSM"],"name":"ButtonFSM"},{"value":"","type":"Behavior","label":"Tween behavior (required)","description":"","group":"","extraInformation":["Tween::TweenBehavior"],"name":"Tween"},{"value":"1","type":"Number","unit":"Dimensionless","label":"Idle state size scale","description":"","group":"Size","extraInformation":[],"name":"IdleScale"},{"value":"1","type":"Number","unit":"Dimensionless","label":"Focused state size scale","description":"The state is Focused when the button is hovered or held outside.","group":"Size","extraInformation":[],"name":"FocusedScale"},{"value":"0.1","type":"Number","unit":"Second","label":"Fade-in duration","description":"","group":"Speed","extraInformation":[],"name":"FadeInDuration"},{"value":"0.2","type":"Number","unit":"Second","label":"Fade-out duration","description":"","group":"Speed","extraInformation":[],"name":"FadeOutDuration"},{"value":"0.95","type":"Number","unit":"Dimensionless","label":"Pressed state size scale","description":"","group":"Size","extraInformation":[],"name":"PressedScale"},{"value":"easeInOutQuad","type":"Choice","label":"Fade-in easing","description":"","group":"Speed","extraInformation":["linear","easeInQuad","easeOutQuad","easeInOutQuad","easeInCubic","easeOutCubic","easeInOutCubic","easeInQuart","easeOutQuart","easeInOutQuart","easeInQuint","easeOutQuint","easeInOutQuint","easeInOutSine","easeInExpo","easeOutExpo","easeInOutExpo","easeInCirc","easeOutCirc","easeInOutCirc","easeOutBounce","easeInBack","easeOutBack","easeInOutBack","elastic","swingFromTo","swingFrom","swingTo","bounce","bouncePast","easeFromTo","easeFrom","easeTo"],"name":"FadeInEasing"},{"value":"easeInOutQuad","type":"Choice","label":"Fade-out easing","description":"","group":"Speed","extraInformation":["linear","easeInQuad","easeOutQuad","easeInOutQuad","easeInCubic","easeOutCubic","easeInOutCubic","easeInQuart","easeOutQuart","easeInOutQuart","easeInQuint","easeOutQuint","easeInOutQuint","easeInOutSine","easeInExpo","easeOutExpo","easeInOutExpo","easeInCirc","easeOutCirc","easeInOutCirc","easeOutBounce","easeInBack","easeOutBack","easeInOutBack","elastic","swingFromTo","swingFrom","swingTo","bounce","bouncePast","easeFromTo","easeFrom","easeTo"],"name":"FadeOutEasing"},{"value":"Idle","type":"Choice","label":"","description":"","group":"","extraInformation":["Idle","Focused","Pressed"],"hidden":true,"name":"PreviousState"}],"sharedPropertyDescriptors":[]},{"description":"Smoothly change the color tint of buttons according to their state.","fullName":"Button color tint tween","name":"ButtonColorTintTween","objectType":"Sprite","eventsFunctions":[{"fullName":"","functionType":"Action","name":"onCreated","sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"ChangeColor"},"parameters":["Object","IdleColorTint"]}]}],"parameters":[{"description":"Object","name":"Object","supplementaryInformation":"Sprite","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"ButtonStates::ButtonColorTintTween","type":"behavior"}],"objectGroups":[]},{"fullName":"","functionType":"Action","name":"doStepPreEvents","sentence":"","events":[{"colorB":228,"colorG":176,"colorR":74,"creationTime":0,"name":"States","source":"","type":"BuiltinCommonInstructions::Group","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"ButtonStates::ButtonFSM::IsIdle"},"parameters":["Object","ButtonFSM",""]},{"type":{"value":"ButtonStates::ButtonColorTintTween::PropertyPreviousState"},"parameters":["Object","Behavior","!=","\"Idle\""]}],"actions":[{"type":{"value":"ButtonStates::ButtonColorTintTween::SetPropertyPreviousState"},"parameters":["Object","Behavior","=","\"Idle\""]},{"type":{"value":"ButtonStates::ButtonColorTintTween::FadeOut"},"parameters":["Object","Behavior","IdleColorTint",""]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"ButtonStates::ButtonFSM::IsFocused"},"parameters":["Object","ButtonFSM",""]}],"actions":[],"events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"ButtonStates::ButtonColorTintTween::PropertyPreviousState"},"parameters":["Object","Behavior","=","\"Idle\""]}],"actions":[{"type":{"value":"ButtonStates::ButtonColorTintTween::SetPropertyPreviousState"},"parameters":["Object","Behavior","=","\"Focused\""]},{"type":{"value":"ButtonStates::ButtonColorTintTween::FadeIn"},"parameters":["Object","Behavior","FocusedColorTint",""]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"ButtonStates::ButtonColorTintTween::PropertyPreviousState"},"parameters":["Object","Behavior","=","\"Pressed\""]}],"actions":[{"type":{"value":"ButtonStates::ButtonColorTintTween::SetPropertyPreviousState"},"parameters":["Object","Behavior","=","\"Focused\""]},{"type":{"value":"ButtonStates::ButtonColorTintTween::FadeOut"},"parameters":["Object","Behavior","FocusedColorTint",""]}]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"ButtonStates::ButtonFSM::IsPressed"},"parameters":["Object","ButtonFSM",""]},{"type":{"value":"ButtonStates::ButtonColorTintTween::PropertyPreviousState"},"parameters":["Object","Behavior","!=","\"Pressed\""]}],"actions":[{"type":{"value":"ButtonStates::ButtonColorTintTween::SetPropertyPreviousState"},"parameters":["Object","Behavior","=","\"Pressed\""]},{"type":{"value":"ButtonStates::ButtonColorTintTween::FadeIn"},"parameters":["Object","Behavior","PressedColorTint",""]}]}],"parameters":[]}],"parameters":[{"description":"Object","name":"Object","supplementaryInformation":"Sprite","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"ButtonStates::ButtonColorTintTween","type":"behavior"}],"objectGroups":[]},{"fullName":"Fade in","functionType":"Action","name":"FadeIn","private":true,"sentence":"_PARAM0_ fade in to _PARAM2_","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"Tween::AddObjectColorTween"},"parameters":["Object","Tween","\"__ButtonColorTintTween.Fade\"","Value","FadeInEasing","1000 * FadeInDuration","no","yes"]}]}],"parameters":[{"description":"Object","name":"Object","supplementaryInformation":"Sprite","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"ButtonStates::ButtonColorTintTween","type":"behavior"},{"description":"Value","name":"Value","type":"color"}],"objectGroups":[]},{"fullName":"Fade out","functionType":"Action","name":"FadeOut","private":true,"sentence":"_PARAM0_ fade out to _PARAM2_","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"Tween::AddObjectColorTween"},"parameters":["Object","Tween","\"__ButtonColorTintTween.Fade\"","Value","FadeOutEasing","1000 * FadeOutDuration","no","yes"]}]}],"parameters":[{"description":"Object","name":"Object","supplementaryInformation":"Sprite","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"ButtonStates::ButtonColorTintTween","type":"behavior"},{"description":"Value","name":"Value","type":"color"}],"objectGroups":[]},{"description":"the idle state color tint of the object.","fullName":"Idle state color tint","functionType":"ExpressionAndCondition","group":"Button color tint tween","name":"IdleColorTint","sentence":"the idle state color tint","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetReturnString"},"parameters":["IdleColorTint"]}]}],"expressionType":{"type":"color"},"parameters":[{"description":"Object","name":"Object","supplementaryInformation":"Sprite","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"ButtonStates::ButtonColorTintTween","type":"behavior"}],"objectGroups":[]},{"fullName":"","functionType":"ActionWithOperator","getterName":"IdleColorTint","name":"SetIdleColorTint","sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"ButtonStates::ButtonColorTintTween::SetPropertyIdleColorTint"},"parameters":["Object","Behavior","=","Value"]}]}],"parameters":[{"description":"Object","name":"Object","supplementaryInformation":"Sprite","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"ButtonStates::ButtonColorTintTween","type":"behavior"}],"objectGroups":[]},{"description":"the focused state color tint of the object. The state is Focused when the button is hovered or held outside.","fullName":"Focused state color tint","functionType":"ExpressionAndCondition","group":"Button color tint tween","name":"FocusedColorTint","sentence":"the focused state color tint","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetReturnString"},"parameters":["FocusedColorTint"]}]}],"expressionType":{"type":"color"},"parameters":[{"description":"Object","name":"Object","supplementaryInformation":"Sprite","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"ButtonStates::ButtonColorTintTween","type":"behavior"}],"objectGroups":[]},{"fullName":"","functionType":"ActionWithOperator","getterName":"FocusedColorTint","name":"SetFocusedColorTint","sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"ButtonStates::ButtonColorTintTween::SetPropertyFocusedColorTint"},"parameters":["Object","Behavior","=","Value"]}]}],"parameters":[{"description":"Object","name":"Object","supplementaryInformation":"Sprite","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"ButtonStates::ButtonColorTintTween","type":"behavior"}],"objectGroups":[]},{"description":"the pressed state color tint of the object.","fullName":"Pressed state color tint","functionType":"ExpressionAndCondition","group":"Button color tint tween","name":"PressedColorTint","sentence":"the pressed state color tint","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetReturnString"},"parameters":["PressedColorTint"]}]}],"expressionType":{"type":"color"},"parameters":[{"description":"Object","name":"Object","supplementaryInformation":"Sprite","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"ButtonStates::ButtonColorTintTween","type":"behavior"}],"objectGroups":[]},{"fullName":"","functionType":"ActionWithOperator","getterName":"PressedColorTint","name":"SetPressedColorTint","sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"ButtonStates::ButtonColorTintTween::SetPropertyPressedColorTint"},"parameters":["Object","Behavior","=","Value"]}]}],"parameters":[{"description":"Object","name":"Object","supplementaryInformation":"Sprite","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"ButtonStates::ButtonColorTintTween","type":"behavior"}],"objectGroups":[]},{"description":"the fade-in duration of the object.","fullName":"Fade-in duration","functionType":"ExpressionAndCondition","group":"Button color tint tween","name":"FadeInDuration","sentence":"the fade-in duration","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetReturnNumber"},"parameters":["FadeInDuration"]}]}],"expressionType":{"type":"expression"},"parameters":[{"description":"Object","name":"Object","supplementaryInformation":"Sprite","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"ButtonStates::ButtonColorTintTween","type":"behavior"}],"objectGroups":[]},{"fullName":"","functionType":"ActionWithOperator","getterName":"FadeInDuration","name":"SetFadeInDuration","sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"ButtonStates::ButtonColorTintTween::SetPropertyFadeInDuration"},"parameters":["Object","Behavior","=","Value"]}]}],"parameters":[{"description":"Object","name":"Object","supplementaryInformation":"Sprite","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"ButtonStates::ButtonColorTintTween","type":"behavior"}],"objectGroups":[]},{"description":"the fade-out duration of the object.","fullName":"Fade-out duration","functionType":"ExpressionAndCondition","group":"Button color tint tween","name":"FadeOutDuration","sentence":"the fade-out duration","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetReturnNumber"},"parameters":["FadeOutDuration"]}]}],"expressionType":{"type":"expression"},"parameters":[{"description":"Object","name":"Object","supplementaryInformation":"Sprite","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"ButtonStates::ButtonColorTintTween","type":"behavior"}],"objectGroups":[]},{"fullName":"","functionType":"ActionWithOperator","getterName":"FadeOutDuration","name":"SetFadeOutDuration","sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"ButtonStates::ButtonColorTintTween::SetPropertyFadeOutDuration"},"parameters":["Object","Behavior","=","Value"]}]}],"parameters":[{"description":"Object","name":"Object","supplementaryInformation":"Sprite","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"ButtonStates::ButtonColorTintTween","type":"behavior"}],"objectGroups":[]},{"description":"the fade-in easing of the object.","fullName":"Fade-in easing","functionType":"ExpressionAndCondition","group":"Button color tint tween","name":"FadeInEasing","sentence":"the fade-in easing","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetReturnString"},"parameters":["FadeInEasing"]}]}],"expressionType":{"supplementaryInformation":"[\"linear\",\"easeInQuad\",\"easeOutQuad\",\"easeInOutQuad\",\"easeInCubic\",\"easeOutCubic\",\"easeInOutCubic\",\"easeInQuart\",\"easeOutQuart\",\"easeInOutQuart\",\"easeInQuint\",\"easeOutQuint\",\"easeInOutQuint\",\"easeInOutSine\",\"easeInExpo\",\"easeOutExpo\",\"easeInOutExpo\",\"easeInCirc\",\"easeOutCirc\",\"easeInOutCirc\",\"easeOutBounce\",\"easeInBack\",\"easeOutBack\",\"easeInOutBack\",\"elastic\",\"swingFromTo\",\"swingFrom\",\"swingTo\",\"bounce\",\"bouncePast\",\"easeFromTo\",\"easeFrom\",\"easeTo\"]","type":"stringWithSelector"},"parameters":[{"description":"Object","name":"Object","supplementaryInformation":"Sprite","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"ButtonStates::ButtonColorTintTween","type":"behavior"}],"objectGroups":[]},{"fullName":"","functionType":"ActionWithOperator","getterName":"FadeInEasing","name":"SetFadeInEasing","sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"ButtonStates::ButtonColorTintTween::SetPropertyFadeInEasing"},"parameters":["Object","Behavior","=","Value"]}]}],"parameters":[{"description":"Object","name":"Object","supplementaryInformation":"Sprite","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"ButtonStates::ButtonColorTintTween","type":"behavior"}],"objectGroups":[]},{"description":"the fade-out easing of the object.","fullName":"Fade-out easing","functionType":"ExpressionAndCondition","group":"Button color tint tween","name":"FadeOutEasing","sentence":"the fade-out easing","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetReturnString"},"parameters":["FadeOutEasing"]}]}],"expressionType":{"supplementaryInformation":"[\"linear\",\"easeInQuad\",\"easeOutQuad\",\"easeInOutQuad\",\"easeInCubic\",\"easeOutCubic\",\"easeInOutCubic\",\"easeInQuart\",\"easeOutQuart\",\"easeInOutQuart\",\"easeInQuint\",\"easeOutQuint\",\"easeInOutQuint\",\"easeInOutSine\",\"easeInExpo\",\"easeOutExpo\",\"easeInOutExpo\",\"easeInCirc\",\"easeOutCirc\",\"easeInOutCirc\",\"easeOutBounce\",\"easeInBack\",\"easeOutBack\",\"easeInOutBack\",\"elastic\",\"swingFromTo\",\"swingFrom\",\"swingTo\",\"bounce\",\"bouncePast\",\"easeFromTo\",\"easeFrom\",\"easeTo\"]","type":"stringWithSelector"},"parameters":[{"description":"Object","name":"Object","supplementaryInformation":"Sprite","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"ButtonStates::ButtonColorTintTween","type":"behavior"}],"objectGroups":[]},{"fullName":"","functionType":"ActionWithOperator","getterName":"FadeOutEasing","name":"SetFadeOutEasing","sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"ButtonStates::ButtonColorTintTween::SetPropertyFadeOutEasing"},"parameters":["Object","Behavior","=","Value"]}]}],"parameters":[{"description":"Object","name":"Object","supplementaryInformation":"Sprite","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"ButtonStates::ButtonColorTintTween","type":"behavior"}],"objectGroups":[]}],"propertyDescriptors":[{"value":"","type":"Behavior","label":"Button states","description":"","group":"","extraInformation":["ButtonStates::ButtonFSM"],"name":"ButtonFSM"},{"value":"","type":"Behavior","label":"Tween","description":"","group":"","extraInformation":["Tween::TweenBehavior"],"name":"Tween"},{"value":"255;255;255","type":"Color","label":"Idle state color tint","description":"","group":"Color","extraInformation":[],"name":"IdleColorTint"},{"value":"192;192;192","type":"Color","label":"Focused state color tint","description":"The state is Focused when the button is hovered or held outside.","group":"Color","extraInformation":[],"name":"FocusedColorTint"},{"value":"64;64;64","type":"Color","label":"Pressed state color tint","description":"","group":"Color","extraInformation":[],"name":"PressedColorTint"},{"value":"0.1","type":"Number","unit":"Second","label":"Fade-in duration","description":"","group":"Speed","extraInformation":[],"name":"FadeInDuration"},{"value":"0.2","type":"Number","unit":"Second","label":"Fade-out duration","description":"","group":"Speed","extraInformation":[],"name":"FadeOutDuration"},{"value":"easeInOutQuad","type":"Choice","label":"Fade-in easing","description":"","group":"Speed","extraInformation":["linear","easeInQuad","easeOutQuad","easeInOutQuad","easeInCubic","easeOutCubic","easeInOutCubic","easeInQuart","easeOutQuart","easeInOutQuart","easeInQuint","easeOutQuint","easeInOutQuint","easeInOutSine","easeInExpo","easeOutExpo","easeInOutExpo","easeInCirc","easeOutCirc","easeInOutCirc","easeOutBounce","easeInBack","easeOutBack","easeInOutBack","elastic","swingFromTo","swingFrom","swingTo","bounce","bouncePast","easeFromTo","easeFrom","easeTo"],"name":"FadeInEasing"},{"value":"easeInOutQuad","type":"Choice","label":"Fade-out easing","description":"","group":"Speed","extraInformation":["linear","easeInQuad","easeOutQuad","easeInOutQuad","easeInCubic","easeOutCubic","easeInOutCubic","easeInQuart","easeOutQuart","easeInOutQuart","easeInQuint","easeOutQuint","easeInOutQuint","easeInOutSine","easeInExpo","easeOutExpo","easeInOutExpo","easeInCirc","easeOutCirc","easeInOutCirc","easeOutBounce","easeInBack","easeOutBack","easeInOutBack","elastic","swingFromTo","swingFrom","swingTo","bounce","bouncePast","easeFromTo","easeFrom","easeTo"],"name":"FadeOutEasing"},{"value":"Idle","type":"Choice","label":"","description":"","group":"","extraInformation":["Idle","Focused","Pressed"],"hidden":true,"name":"PreviousState"}],"sharedPropertyDescriptors":[]}],"eventsBasedObjects":[]},{"author":"","category":"User interface","extensionNamespace":"","fullName":"Panel sprite button","helpPath":"/objects/button","iconUrl":"data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4NCjwhLS0gR2VuZXJhdG9yOiBBZG9iZSBJbGx1c3RyYXRvciAyMy4wLjMsIFNWRyBFeHBvcnQgUGx1Zy1JbiAuIFNWRyBWZXJzaW9uOiA2LjAwIEJ1aWxkIDApICAtLT4NCjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iSWNvbnMiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4Ig0KCSB2aWV3Qm94PSIwIDAgMzIgMzIiIHN0eWxlPSJlbmFibGUtYmFja2dyb3VuZDpuZXcgMCAwIDMyIDMyOyIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+DQo8c3R5bGUgdHlwZT0idGV4dC9jc3MiPg0KCS5zdDB7ZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoyO3N0cm9rZS1saW5lY2FwOnJvdW5kO3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2UtbWl0ZXJsaW1pdDoxMDt9DQo8L3N0eWxlPg0KPHBhdGggY2xhc3M9InN0MCIgZD0iTTI5LDIzSDNjLTEuMSwwLTItMC45LTItMlYxMWMwLTEuMSwwLjktMiwyLTJoMjZjMS4xLDAsMiwwLjksMiwydjEwQzMxLDIyLjEsMzAuMSwyMywyOSwyM3oiLz4NCjxwYXRoIGNsYXNzPSJzdDAiIGQ9Ik0xMywxOUwxMywxOWMtMS4xLDAtMi0wLjktMi0ydi0yYzAtMS4xLDAuOS0yLDItMmgwYzEuMSwwLDIsMC45LDIsMnYyQzE1LDE4LjEsMTQuMSwxOSwxMywxOXoiLz4NCjxsaW5lIGNsYXNzPSJzdDAiIHgxPSIxOCIgeTE9IjEzIiB4Mj0iMTgiIHkyPSIxOSIvPg0KPGxpbmUgY2xhc3M9InN0MCIgeDE9IjIxIiB5MT0iMTMiIHgyPSIxOCIgeTI9IjE3Ii8+DQo8bGluZSBjbGFzcz0ic3QwIiB4MT0iMjEiIHkxPSIxOSIgeDI9IjE5IiB5Mj0iMTYiLz4NCjwvc3ZnPg0K","name":"PanelSpriteButton","previewIconUrl":"https://resources.gdevelop-app.com/assets/Icons/Line Hero Pack/Master/SVG/Interface Elements/Interface Elements_interface_ui_button_ok_cta_clock_tap.svg","shortDescription":"A button that can be customized.","version":"1.4.4","description":["The button can be customized with a background for each state and a label. It handles user interactions and a simple condition can be used to check if it is clicked.","","There are ready-to-use buttons in the asset-store [menu buttons pack](https://editor.gdevelop.io/?initial-dialog=asset-store&asset-pack=menu-buttons-menu-buttons)."],"origin":{"identifier":"PanelSpriteButton","name":"gdevelop-extension-store"},"tags":["button","ui"],"authorIds":["IWykYNRvhCZBN3vEgKEbBPOR3Oc2"],"dependencies":[],"globalVariables":[],"sceneVariables":[],"eventsFunctions":[],"eventsBasedBehaviors":[{"description":"The finite state machine used internally by the button object.","fullName":"Button finite state machine","name":"ButtonFSM","objectType":"","private":true,"eventsFunctions":[{"fullName":"","functionType":"Action","name":"doStepPostEvents","sentence":"","events":[{"colorB":228,"colorG":176,"colorR":74,"creationTime":0,"name":"Finite state machine","source":"","type":"BuiltinCommonInstructions::Group","events":[{"type":"BuiltinCommonInstructions::Comment","color":{"b":109,"g":230,"r":255,"textB":0,"textG":0,"textR":0},"comment":"The \"Validated\" state only last one frame."},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"PanelSpriteButton::ButtonFSM::PropertyState"},"parameters":["Object","Behavior","=","\"Validated\""]}],"actions":[{"type":{"value":"PanelSpriteButton::ButtonFSM::SetPropertyState"},"parameters":["Object","Behavior","=","\"Idle\""]}]},{"colorB":228,"colorG":176,"colorR":74,"creationTime":0,"name":"Check position","source":"","type":"BuiltinCommonInstructions::Group","events":[{"type":"BuiltinCommonInstructions::Comment","color":{"b":109,"g":230,"r":255,"textB":0,"textG":0,"textR":0},"comment":"Make sure the cursor position is only checked once per frame."},{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"PanelSpriteButton::ButtonFSM::SetPropertyMouseIsInside"},"parameters":["Object","Behavior","no"]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"PanelSpriteButton::ButtonFSM::PropertyShouldCheckHovering"},"parameters":["Object","Behavior"]},{"type":{"value":"CollisionPoint"},"parameters":["Object","MouseOnlyCursorX(Object.Layer(), 0)","MouseOnlyCursorY(Object.Layer(), 0)"]}],"actions":[{"type":{"value":"PanelSpriteButton::ButtonFSM::SetPropertyMouseIsInside"},"parameters":["Object","Behavior","yes"]}]},{"type":"BuiltinCommonInstructions::Comment","color":{"b":109,"g":230,"r":255,"textB":0,"textG":0,"textR":0},"comment":"Touches are always pressed, so ShouldCheckHovering doesn't matter."},{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"PanelSpriteButton::ButtonFSM::SetPropertyTouchIsInside"},"parameters":["Object","Behavior","no"]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"PanelSpriteButton::ButtonFSM::PropertyTouchId"},"parameters":["Object","Behavior","!=","0"]},{"type":{"value":"CollisionPoint"},"parameters":["Object","TouchX(Object.Behavior::PropertyTouchId(), Object.Layer(), 0)","TouchY(Object.Behavior::PropertyTouchId(), Object.Layer(), 0)"]}],"actions":[{"type":{"value":"PanelSpriteButton::ButtonFSM::SetPropertyTouchIsInside"},"parameters":["Object","Behavior","yes"]}]}],"parameters":[]},{"colorB":228,"colorG":176,"colorR":74,"creationTime":0,"name":"Handle touch start","source":"","type":"BuiltinCommonInstructions::Group","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"HasAnyTouchOrMouseStarted"},"parameters":[""]}],"actions":[{"type":{"value":"PanelSpriteButton::ButtonFSM::SetPropertyIndex"},"parameters":["Object","Behavior","=","0"]}],"events":[{"type":"BuiltinCommonInstructions::Repeat","repeatExpression":"StartedTouchOrMouseCount()","conditions":[],"actions":[],"events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"CollisionPoint"},"parameters":["Object","TouchX(StartedTouchOrMouseId(Object.Behavior::PropertyIndex()), Object.Layer(), 0)","TouchY(StartedTouchOrMouseId(Object.Behavior::PropertyIndex()), Object.Layer(), 0)"]}],"actions":[{"type":{"value":"PanelSpriteButton::ButtonFSM::SetPropertyTouchId"},"parameters":["Object","Behavior","=","StartedTouchOrMouseId(Object.Behavior::PropertyIndex())"]},{"type":{"value":"PanelSpriteButton::ButtonFSM::SetPropertyTouchIsInside"},"parameters":["Object","Behavior","yes"]}],"events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"BuiltinCommonInstructions::Or"},"parameters":[],"subInstructions":[{"type":{"value":"PanelSpriteButton::ButtonFSM::PropertyState"},"parameters":["Object","Behavior","=","\"Hovered\""]},{"type":{"value":"PanelSpriteButton::ButtonFSM::PropertyState"},"parameters":["Object","Behavior","=","\"Idle\""]}]}],"actions":[{"type":{"value":"PanelSpriteButton::ButtonFSM::SetPropertyState"},"parameters":["Object","Behavior","=","\"PressedInside\""]}]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"PanelSpriteButton::ButtonFSM::SetPropertyIndex"},"parameters":["Object","Behavior","+","1"]}]}]}]}],"parameters":[]},{"colorB":228,"colorG":176,"colorR":74,"creationTime":0,"name":"Apply position changes","source":"","type":"BuiltinCommonInstructions::Group","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"inverted":true,"value":"PanelSpriteButton::ButtonFSM::PropertyMouseIsInside"},"parameters":["Object","Behavior"]},{"type":{"value":"PanelSpriteButton::ButtonFSM::PropertyState"},"parameters":["Object","Behavior","=","\"Hovered\""]}],"actions":[{"type":{"value":"PanelSpriteButton::ButtonFSM::SetPropertyState"},"parameters":["Object","Behavior","=","\"Idle\""]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"PanelSpriteButton::ButtonFSM::PropertyMouseIsInside"},"parameters":["Object","Behavior"]},{"type":{"value":"PanelSpriteButton::ButtonFSM::PropertyState"},"parameters":["Object","Behavior","=","\"Idle\""]}],"actions":[{"type":{"value":"PanelSpriteButton::ButtonFSM::SetPropertyState"},"parameters":["Object","Behavior","=","\"Hovered\""]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"inverted":true,"value":"PanelSpriteButton::ButtonFSM::PropertyTouchIsInside"},"parameters":["Object","Behavior"]},{"type":{"value":"PanelSpriteButton::ButtonFSM::PropertyState"},"parameters":["Object","Behavior","=","\"PressedInside\""]}],"actions":[{"type":{"value":"PanelSpriteButton::ButtonFSM::SetPropertyState"},"parameters":["Object","Behavior","=","\"PressedOutside\""]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"PanelSpriteButton::ButtonFSM::PropertyTouchIsInside"},"parameters":["Object","Behavior"]},{"type":{"value":"PanelSpriteButton::ButtonFSM::PropertyState"},"parameters":["Object","Behavior","=","\"PressedOutside\""]}],"actions":[{"type":{"value":"PanelSpriteButton::ButtonFSM::SetPropertyState"},"parameters":["Object","Behavior","=","\"PressedInside\""]}]}],"parameters":[]},{"colorB":228,"colorG":176,"colorR":74,"creationTime":0,"name":"Handle touch end","source":"","type":"BuiltinCommonInstructions::Group","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"HasTouchEnded"},"parameters":["","Object.Behavior::PropertyTouchId()"]}],"actions":[{"type":{"value":"PanelSpriteButton::ButtonFSM::SetPropertyTouchId"},"parameters":["Object","Behavior","=","0"]}],"events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"PanelSpriteButton::ButtonFSM::PropertyState"},"parameters":["Object","Behavior","=","\"PressedInside\""]}],"actions":[{"type":{"value":"PanelSpriteButton::ButtonFSM::SetPropertyState"},"parameters":["Object","Behavior","=","\"Validated\""]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"inverted":true,"value":"PanelSpriteButton::ButtonFSM::PropertyState"},"parameters":["Object","Behavior","=","\"PressedInside\""]},{"type":{"inverted":true,"value":"PanelSpriteButton::ButtonFSM::PropertyState"},"parameters":["Object","Behavior","=","\"Validated\""]}],"actions":[{"type":{"value":"PanelSpriteButton::ButtonFSM::SetPropertyState"},"parameters":["Object","Behavior","=","\"Idle\""]}]}]}],"parameters":[]}],"parameters":[]}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"PanelSpriteButton::ButtonFSM","type":"behavior"}],"objectGroups":[]},{"fullName":"","functionType":"Action","name":"onDeActivate","sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"PanelSpriteButton::ButtonFSM::ResetState"},"parameters":["Object","Behavior",""]}]}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"PanelSpriteButton::ButtonFSM","type":"behavior"}],"objectGroups":[]},{"description":"Reset the state of the button.","fullName":"Reset state","functionType":"Action","name":"ResetState","private":true,"sentence":"Reset the button state of _PARAM0_","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"PanelSpriteButton::ButtonFSM::SetPropertyState"},"parameters":["Object","Behavior","=","\"Idle\""]},{"type":{"value":"PanelSpriteButton::ButtonFSM::SetPropertyTouchId"},"parameters":["Object","Behavior","=","0"]}]}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"PanelSpriteButton::ButtonFSM","type":"behavior"}],"objectGroups":[]},{"description":"Check if the button is not used.","fullName":"Is idle","functionType":"Condition","name":"IsIdle","sentence":"_PARAM0_ is idle","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"PanelSpriteButton::ButtonFSM::PropertyState"},"parameters":["Object","Behavior","=","\"Idle\""]}],"actions":[{"type":{"value":"SetReturnBoolean"},"parameters":["True"]}]}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"PanelSpriteButton::ButtonFSM","type":"behavior"}],"objectGroups":[]},{"description":"Check if the button was just clicked.","fullName":"Is clicked","functionType":"Condition","name":"IsClicked","sentence":"_PARAM0_ is clicked","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"PanelSpriteButton::ButtonFSM::PropertyState"},"parameters":["Object","Behavior","=","\"Validated\""]}],"actions":[{"type":{"value":"SetReturnBoolean"},"parameters":["True"]}]}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"PanelSpriteButton::ButtonFSM","type":"behavior"}],"objectGroups":[]},{"description":"Check if the cursor is hovered over the button.","fullName":"Is hovered","functionType":"Condition","name":"IsHovered","sentence":"_PARAM0_ is hovered","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"PanelSpriteButton::ButtonFSM::PropertyState"},"parameters":["Object","Behavior","=","\"Hovered\""]}],"actions":[{"type":{"value":"SetReturnBoolean"},"parameters":["True"]}]}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"PanelSpriteButton::ButtonFSM","type":"behavior"}],"objectGroups":[]},{"description":"Check if the button is either hovered or pressed but not hovered.","fullName":"Is focused","functionType":"Condition","name":"IsFocused","sentence":"_PARAM0_ is focused","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"PanelSpriteButton::ButtonFSM::PropertyState"},"parameters":["Object","Behavior","=","\"Hovered\""]}],"actions":[{"type":{"value":"SetReturnBoolean"},"parameters":["True"]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"PanelSpriteButton::ButtonFSM::PropertyState"},"parameters":["Object","Behavior","=","\"PressedOutside\""]}],"actions":[{"type":{"value":"SetReturnBoolean"},"parameters":["True"]}]}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"PanelSpriteButton::ButtonFSM","type":"behavior"}],"objectGroups":[]},{"description":"Check if the button is currently being pressed with mouse or touch.","fullName":"Is pressed","functionType":"Condition","name":"IsPressed","sentence":"_PARAM0_ is pressed","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"PanelSpriteButton::ButtonFSM::PropertyState"},"parameters":["Object","Behavior","=","\"PressedInside\""]}],"actions":[{"type":{"value":"SetReturnBoolean"},"parameters":["True"]}]}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"PanelSpriteButton::ButtonFSM","type":"behavior"}],"objectGroups":[]},{"description":"Check if the button is currently being pressed outside with mouse or touch.","fullName":"Is held outside","functionType":"Condition","name":"IsPressedOutside","sentence":"_PARAM0_ is held outside","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"PanelSpriteButton::ButtonFSM::PropertyState"},"parameters":["Object","Behavior","=","\"PressedOutside\""]}],"actions":[{"type":{"value":"SetReturnBoolean"},"parameters":["True"]}]}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"PanelSpriteButton::ButtonFSM","type":"behavior"}],"objectGroups":[]},{"description":"the touch id that is using the button or 0 if none.","fullName":"Touch id","functionType":"ExpressionAndCondition","name":"TouchId","sentence":"the touch id","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetReturnNumber"},"parameters":["Object.Behavior::PropertyTouchId()"]}]}],"expressionType":{"type":"expression"},"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"PanelSpriteButton::ButtonFSM","type":"behavior"}],"objectGroups":[]}],"propertyDescriptors":[{"value":"true","type":"Boolean","label":"","description":"Should check hovering","group":"","extraInformation":[],"hidden":true,"name":"ShouldCheckHovering"},{"value":"Idle","type":"Choice","label":"State","description":"","group":"","extraInformation":["Idle","Hovered","PressedInside","PressedOutside","Validated"],"hidden":true,"name":"State"},{"value":"0","type":"Number","label":"Touch id","description":"","group":"","extraInformation":[],"hidden":true,"name":"TouchId"},{"value":"","type":"Boolean","label":"Touch is inside","description":"","group":"","extraInformation":[],"hidden":true,"name":"TouchIsInside"},{"value":"","type":"Boolean","label":"Mouse is inside","description":"","group":"","extraInformation":[],"hidden":true,"name":"MouseIsInside"},{"value":"","type":"Number","label":"","description":"","group":"","extraInformation":[],"hidden":true,"name":"Index"}],"sharedPropertyDescriptors":[]}],"eventsBasedObjects":[{"areaMaxX":64,"areaMaxY":64,"areaMaxZ":64,"areaMinX":0,"areaMinY":0,"areaMinZ":0,"defaultName":"Button","description":"A button that can be customized.","fullName":"Button (panel sprite)","isUsingLegacyInstancesRenderer":true,"name":"PanelSpriteButton","eventsFunctions":[{"fullName":"","functionType":"Action","name":"onCreated","sentence":"","events":[{"type":"BuiltinCommonInstructions::Comment","color":{"b":109,"g":230,"r":255,"textB":0,"textG":0,"textR":0},"comment":"Create one background instance for of each state.\nOnly the instance for the current state is shown."},{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"Create"},"parameters":["","Idle","0","0",""]},{"type":{"value":"Create"},"parameters":["","Hovered","0","0",""]},{"type":{"value":"Create"},"parameters":["","Pressed","0","0",""]},{"type":{"value":"Cache"},"parameters":["Hovered"]},{"type":{"value":"Cache"},"parameters":["Pressed"]},{"type":{"value":"ChangePlan"},"parameters":["Hovered","=","1"]}]},{"type":"BuiltinCommonInstructions::Comment","color":{"b":109,"g":230,"r":255,"textB":0,"textG":0,"textR":0},"comment":"Place the label over the backgrounds."},{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"Create"},"parameters":["","Label","0","0",""]},{"type":{"value":"ChangePlan"},"parameters":["Label","=","2"]},{"type":{"value":"TextObject::SetWrapping"},"parameters":["Label","yes"]},{"type":{"value":"PanelSpriteButton::PanelSpriteButton::CenterLabel"},"parameters":["Object",""]}]}],"parameters":[{"description":"Object","name":"Object","supplementaryInformation":"PanelSpriteButton::PanelSpriteButton","type":"object"}],"objectGroups":[{"name":"Background","objects":[{"name":"Idle"},{"name":"Hovered"},{"name":"Pressed"}]}]},{"fullName":"","functionType":"Action","name":"onHotReloading","sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"PanelSpriteButton::PanelSpriteButton::CenterLabel"},"parameters":["Object",""]}]}],"parameters":[{"description":"Object","name":"Object","supplementaryInformation":"PanelSpriteButton::PanelSpriteButton","type":"object"}],"objectGroups":[]},{"fullName":"","functionType":"Action","name":"doStepPostEvents","sentence":"","events":[{"colorB":228,"colorG":176,"colorR":74,"creationTime":0,"name":"Apply states","source":"","type":"BuiltinCommonInstructions::Group","events":[{"type":"BuiltinCommonInstructions::Comment","color":{"b":109,"g":230,"r":255,"textB":0,"textG":0,"textR":0},"comment":"Show the right background accordingly to the new state."},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"PanelSpriteButton::PanelSpriteButton::IsIdle"},"parameters":["Object","ButtonFSM"]},{"type":{"value":"BuiltinCommonInstructions::Once"},"parameters":[]}],"actions":[{"type":{"value":"SetCenterY"},"parameters":["Label","=","Object.CenterWithPaddingY()"]},{"type":{"value":"Montre"},"parameters":["Idle",""]},{"type":{"value":"Cache"},"parameters":["Pressed"]}],"events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"Visible"},"parameters":["Hovered"]},{"type":{"value":"PanelSpriteButton::PanelSpriteButton::PropertyHoveredFadeOutDuration"},"parameters":["Object",">","0"]}],"actions":[{"type":{"value":"Tween::AddObjectOpacityTween"},"parameters":["Hovered","Tween","\"Fadeout\"","0","\"linear\"","Object.PropertyHoveredFadeOutDuration() * 1000",""]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"PanelSpriteButton::PanelSpriteButton::PropertyHoveredFadeOutDuration"},"parameters":["Object","=","0"]}],"actions":[{"type":{"value":"Cache"},"parameters":["Hovered"]}]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"PanelSpriteObject::Opacity"},"parameters":["Hovered","=","0"]}],"actions":[{"type":{"value":"Cache"},"parameters":["Hovered"]},{"type":{"value":"PanelSpriteObject::SetOpacity"},"parameters":["Hovered","=","255"]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"PanelSpriteButton::PanelSpriteButton::IsHovered"},"parameters":["Object","ButtonFSM"]},{"type":{"value":"BuiltinCommonInstructions::Once"},"parameters":[]}],"actions":[{"type":{"value":"SetCenterY"},"parameters":["Label","=","Object.CenterWithPaddingY()"]},{"type":{"value":"Cache"},"parameters":["Idle"]},{"type":{"value":"Montre"},"parameters":["Hovered",""]},{"type":{"value":"Cache"},"parameters":["Pressed"]},{"type":{"value":"Tween::RemoveTween"},"parameters":["Hovered","Tween","\"Fadeout\""]},{"type":{"value":"PanelSpriteObject::SetOpacity"},"parameters":["Hovered","=","255"]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"PanelSpriteButton::PanelSpriteButton::IsPressed"},"parameters":["Object","ButtonFSM"]},{"type":{"value":"BuiltinCommonInstructions::Once"},"parameters":[]}],"actions":[{"type":{"value":"SetCenterY"},"parameters":["Label","=","Object.CenterWithPaddingY() + Object.PropertyPressedLabelOffsetY()"]},{"type":{"value":"Cache"},"parameters":["Idle"]},{"type":{"value":"Cache"},"parameters":["Hovered"]},{"type":{"value":"Montre"},"parameters":["Pressed",""]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"PanelSpriteButton::PanelSpriteButton::IsFocused"},"parameters":["Object","ButtonFSM"]},{"type":{"value":"BuiltinCommonInstructions::Once"},"parameters":[]}],"actions":[{"type":{"value":"SetCenterY"},"parameters":["Label","=","Object.CenterWithPaddingY()"]},{"type":{"value":"Cache"},"parameters":["Idle"]},{"type":{"value":"Montre"},"parameters":["Hovered",""]},{"type":{"value":"Cache"},"parameters":["Pressed"]}]}],"parameters":[]},{"colorB":228,"colorG":176,"colorR":74,"creationTime":0,"name":"Resize","source":"","type":"BuiltinCommonInstructions::Group","events":[{"type":"BuiltinCommonInstructions::Comment","color":{"b":109,"g":230,"r":255,"textB":0,"textG":0,"textR":0},"comment":"Children instances must be resized when the button size change:\n- backgrounds for each state are resized to take the full dimensions of the button\n- the label is put back at the center of the button\n\nThe scale is set back to 1 because it means that the parent instance has the same dimensions as the union of its children instances."},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"BuiltinCommonInstructions::Or"},"parameters":[],"subInstructions":[{"type":{"value":"BuiltinCommonInstructions::CompareNumbers"},"parameters":["Object.Width()","!=","max(Idle.BoundingBoxRight(), Label.BoundingBoxRight()) - min(Idle.BoundingBoxLeft(), Label.BoundingBoxLeft())"]},{"type":{"value":"BuiltinCommonInstructions::CompareNumbers"},"parameters":["Object.Height()","!=","max(Idle.BoundingBoxBottom(), Label.BoundingBoxBottom()) - min(Idle.BoundingBoxTop(), Label.BoundingBoxTop())"]}]}],"actions":[{"type":{"value":"ModVarObjet"},"parameters":["Idle","Width","=","Object.Width()"]},{"type":{"value":"ModVarObjet"},"parameters":["Idle","Height","=","Object.Height()"]},{"type":{"value":"PanelSpriteButton::Scale"},"parameters":["Object","=","1"]},{"type":{"value":"PanelSpriteObject::Width"},"parameters":["Background","=","Idle.Variable(Width)"]},{"type":{"value":"PanelSpriteObject::Height"},"parameters":["Background","=","Idle.Variable(Height)"]},{"type":{"value":"PanelSpriteButton::PanelSpriteButton::CenterLabel"},"parameters":["Object",""]}]}],"parameters":[]}],"parameters":[{"description":"Object","name":"Object","supplementaryInformation":"PanelSpriteButton::PanelSpriteButton","type":"object"}],"objectGroups":[{"name":"Background","objects":[{"name":"Idle"},{"name":"Hovered"},{"name":"Pressed"}]}]},{"description":"Check if the button is not used.","fullName":"Is idle","functionType":"Condition","name":"IsIdle","sentence":"_PARAM0_ is idle","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"PanelSpriteButton::ButtonFSM::IsIdle"},"parameters":["Idle","ButtonFSM",""]}],"actions":[{"type":{"value":"SetReturnBoolean"},"parameters":["True"]}]}],"parameters":[{"description":"Object","name":"Object","supplementaryInformation":"PanelSpriteButton::PanelSpriteButton","type":"object"}],"objectGroups":[]},{"description":"Check if the button was just clicked.","fullName":"Is clicked","functionType":"Condition","name":"IsClicked","sentence":"_PARAM0_ is clicked","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"PanelSpriteButton::ButtonFSM::IsClicked"},"parameters":["Idle","ButtonFSM",""]}],"actions":[{"type":{"value":"SetReturnBoolean"},"parameters":["True"]}]}],"parameters":[{"description":"Object","name":"Object","supplementaryInformation":"PanelSpriteButton::PanelSpriteButton","type":"object"}],"objectGroups":[]},{"description":"Check if the cursor is hovered over the button.","fullName":"Is hovered","functionType":"Condition","name":"IsHovered","sentence":"_PARAM0_ is hovered","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"PanelSpriteButton::ButtonFSM::IsHovered"},"parameters":["Idle","ButtonFSM",""]}],"actions":[{"type":{"value":"SetReturnBoolean"},"parameters":["True"]}]}],"parameters":[{"description":"Object","name":"Object","supplementaryInformation":"PanelSpriteButton::PanelSpriteButton","type":"object"}],"objectGroups":[]},{"description":"Check if the button is either hovered or pressed but not hovered.","fullName":"Is focused","functionType":"Condition","name":"IsFocused","sentence":"_PARAM0_ is focused","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"PanelSpriteButton::ButtonFSM::IsFocused"},"parameters":["Idle","ButtonFSM",""]}],"actions":[{"type":{"value":"SetReturnBoolean"},"parameters":["True"]}]}],"parameters":[{"description":"Object","name":"Object","supplementaryInformation":"PanelSpriteButton::PanelSpriteButton","type":"object"}],"objectGroups":[]},{"description":"Check if the button is currently being pressed with mouse or touch.","fullName":"Is pressed","functionType":"Condition","name":"IsPressed","sentence":"_PARAM0_ is pressed","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"PanelSpriteButton::ButtonFSM::IsPressed"},"parameters":["Idle","ButtonFSM",""]}],"actions":[{"type":{"value":"SetReturnBoolean"},"parameters":["True"]}]}],"parameters":[{"description":"Object","name":"Object","supplementaryInformation":"PanelSpriteButton::PanelSpriteButton","type":"object"}],"objectGroups":[]},{"description":"Change the text of the button label.","fullName":"Label text","functionType":"Action","name":"SetLabelText","sentence":"Change the text of _PARAM0_ to _PARAM1_","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"TextObject::String"},"parameters":["Label","=","GetArgumentAsString(\"LabelText\")"]},{"type":{"value":"PanelSpriteButton::PanelSpriteButton::CenterLabel"},"parameters":["Object",""]}]}],"parameters":[{"description":"Object","name":"Object","supplementaryInformation":"PanelSpriteButton::PanelSpriteButton","type":"object"},{"description":"Text","name":"LabelText","type":"string"}],"objectGroups":[]},{"description":"Return the label text.","fullName":"Label text","functionType":"StringExpression","name":"LabelText","sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetReturnString"},"parameters":["Label.String()"]}]}],"expressionType":{"type":"string"},"parameters":[{"description":"Object","name":"Object","supplementaryInformation":"PanelSpriteButton::PanelSpriteButton","type":"object"}],"objectGroups":[]},{"description":"Return the label center Y according to the button configuration. This expression is used in doStepPostEvents when the button is pressed or released.","fullName":"","functionType":"Expression","name":"CenterWithPaddingY","private":true,"sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetReturnNumber"},"parameters":["Idle.CenterY() + (Object.PropertyTopPadding() - Object.PropertyBottomPadding()) / 2"]}]}],"expressionType":{"type":"expression"},"parameters":[{"description":"Object","name":"Object","supplementaryInformation":"PanelSpriteButton::PanelSpriteButton","type":"object"}],"objectGroups":[]},{"description":"Center the label according to the button configuration. This is used in doStepPostEvents when the button is resized.","fullName":"","functionType":"Action","name":"CenterLabel","private":true,"sentence":"Center the label of _PARAM0_","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"MettreXY"},"parameters":["Label","=","Object.PropertyLeftPadding()","=","Object.PropertyTopPadding()"]},{"type":{"value":"TextObject::WrappingWidth"},"parameters":["Label","=","Idle.Width() - Object.PropertyLeftPadding() - Object.PropertyRightPadding()"]},{"type":{"value":"SetCenterY"},"parameters":["Label","=","Object.CenterWithPaddingY()"]}],"events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"SetCenterX"},"parameters":["Label","=","Background.CenterX() +  (Object.PropertyLeftPadding() - Object.PropertyRightPadding()) / 2"]}]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"PanelSpriteButton::PanelSpriteButton::IsPressed"},"parameters":["Object",""]}],"actions":[{"type":{"value":"MettreY"},"parameters":["Label","+","Object.PropertyPressedLabelOffsetY()"]}]}],"parameters":[{"description":"Object","name":"Object","supplementaryInformation":"PanelSpriteButton::PanelSpriteButton","type":"object"}],"objectGroups":[{"name":"Background","objects":[{"name":"Idle"},{"name":"Hovered"},{"name":"Pressed"}]}]},{"description":"De/activate interactions with the button.","fullName":"De/activate interactions","functionType":"Action","name":"Activate","sentence":"Activate interactions with _PARAM0_: _PARAM1_","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"GetArgumentAsBoolean"},"parameters":["\"ShouldActivate\""]}],"actions":[{"type":{"value":"ActivateBehavior"},"parameters":["Idle","ButtonFSM","yes"]}]},{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"inverted":true,"value":"GetArgumentAsBoolean"},"parameters":["\"ShouldActivate\""]}],"actions":[{"type":{"value":"ActivateBehavior"},"parameters":["Idle","ButtonFSM","no"]}]}],"parameters":[{"description":"Object","name":"Object","supplementaryInformation":"PanelSpriteButton::PanelSpriteButton","type":"object"},{"description":"Activate","name":"ShouldActivate","type":"yesorno"}],"objectGroups":[]},{"description":"Check if interactions are activated on the button.","fullName":"Interactions activated","functionType":"Condition","name":"IsActivated","sentence":"Interactions on _PARAM0_ are activated","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[{"type":{"value":"BehaviorActivated"},"parameters":["Idle","ButtonFSM"]}],"actions":[{"type":{"value":"SetReturnBoolean"},"parameters":["True"]}]}],"parameters":[{"description":"Object","name":"Object","supplementaryInformation":"PanelSpriteButton::PanelSpriteButton","type":"object"}],"objectGroups":[]}],"propertyDescriptors":[{"value":"0","type":"Number","label":"Label offset on Y axis when pressed","description":"","group":"","extraInformation":[],"name":"PressedLabelOffsetY"},{"value":"0","type":"Number","label":"Left padding","description":"","group":"Padding","extraInformation":["Label"],"name":"LeftPadding"},{"value":"0","type":"Number","label":"Right padding","description":"","group":"Padding","extraInformation":["Label"],"name":"RightPadding"},{"value":"0","type":"Number","label":"Top padding","description":"","group":"Padding","extraInformation":["Label"],"name":"TopPadding"},{"value":"0","type":"Number","label":"Bottom padding","description":"","group":"Padding","extraInformation":["Label"],"name":"BottomPadding"},{"value":"0.25","type":"Number","label":"Hovered fade out duration (in seconds)","description":"","group":"","extraInformation":[],"name":"HoveredFadeOutDuration"}],"objects":[{"assetStoreId":"","bold":false,"italic":false,"name":"Label","smoothed":true,"type":"TextObject::Text","underlined":false,"variables":[],"effects":[],"behaviors":[],"string":"Text","font":"","textAlignment":"","characterSize":20.0,"color":{"b":0,"g":0,"r":0},"content":{"bold":false,"isOutlineEnabled":false,"isShadowEnabled":false,"italic":false,"outlineColor":"255;255;255","outlineThickness":2.0,"shadowAngle":90.0,"shadowBlurRadius":2.0,"shadowColor":"0;0;0","shadowDistance":4.0,"shadowOpacity":127.0,"smoothed":true,"underlined":false,"text":"Text","font":"","textAlignment":"","characterSize":20.0,"color":"0;0;0"}},{"assetStoreId":"","bottomMargin":0.0,"height":32.0,"leftMargin":0.0,"name":"Idle","rightMargin":0.0,"texture":"","tiled":false,"topMargin":0.0,"type":"PanelSpriteObject::PanelSprite","width":32.0,"variables":[{"folded":true,"name":"State","type":"string","value":"Idle"}],"effects":[],"behaviors":[{"name":"ButtonFSM","type":"PanelSpriteButton::ButtonFSM","ShouldCheckHovering":true}]},{"assetStoreId":"","bottomMargin":0.0,"height":32.0,"leftMargin":0.0,"name":"Hovered","rightMargin":0.0,"texture":"","tiled":false,"topMargin":0.0,"type":"PanelSpriteObject::PanelSprite","width":32.0,"variables":[],"effects":[],"behaviors":[{"name":"Tween","type":"Tween::TweenBehavior"}]},{"assetStoreId":"","bottomMargin":0.0,"height":32.0,"leftMargin":0.0,"name":"Pressed","rightMargin":0.0,"texture":"","tiled":false,"topMargin":0.0,"type":"PanelSpriteObject::PanelSprite","width":32.0,"variables":[],"effects":[],"behaviors":[]}],"objectsFolderStructure":{"folderName":"__ROOT","children":[{"objectName":"Label"},{"objectName":"Idle"},{"objectName":"Hovered"},{"objectName":"Pressed"}]},"objectsGroups":[],"layers":[{"ambientLightColorB":200,"ambientLightColorG":200,"ambientLightColorR":200,"camera3DFarPlaneDistance":10000.0,"camera3DFieldOfView":45.0,"camera3DNearPlaneDistance":3.0,"cameraType":"","followBaseLayerCamera":false,"isLightingLayer":false,"isLocked":false,"name":"","renderingType":"","visibility":true,"cameras":[{"defaultSize":true,"defaultViewport":true,"height":0.0,"viewportBottom":1.0,"viewportLeft":0.0,"viewportRight":1.0,"viewportTop":0.0,"width":0.0}],"effects":[]}],"instances":[]}]},{"author":"Lim98SE","category":"Input","extensionNamespace":"","fullName":"Cursor object","helpPath":"","iconUrl":"data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiBpZD0ibWRpLWN1cnNvci1kZWZhdWx0LW91dGxpbmUiIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0Ij48cGF0aCBkPSJNMTAuMDcsMTQuMjdDMTAuNTcsMTQuMDMgMTEuMTYsMTQuMjUgMTEuNCwxNC43NUwxMy43LDE5Ljc0TDE1LjUsMTguODlMMTMuMTksMTMuOTFDMTIuOTUsMTMuNDEgMTMuMTcsMTIuODEgMTMuNjcsMTIuNThMMTMuOTUsMTIuNUwxNi4yNSwxMi4wNUw4LDUuMTJWMTUuOUw5LjgyLDE0LjQzTDEwLjA3LDE0LjI3TTEzLjY0LDIxLjk3QzEzLjE0LDIyLjIxIDEyLjU0LDIyIDEyLjMxLDIxLjVMMTAuMTMsMTYuNzZMNy42MiwxOC43OEM3LjQ1LDE4LjkyIDcuMjQsMTkgNywxOUExLDEgMCAwLDEgNiwxOFYzQTEsMSAwIDAsMSA3LDJDNy4yNCwyIDcuNDcsMi4wOSA3LjY0LDIuMjNMNy42NSwyLjIyTDE5LjE0LDExLjg2QzE5LjU3LDEyLjIyIDE5LjYyLDEyLjg1IDE5LjI3LDEzLjI3QzE5LjEyLDEzLjQ1IDE4LjkxLDEzLjU3IDE4LjcsMTMuNjFMMTUuNTQsMTQuMjNMMTcuNzQsMTguOTZDMTgsMTkuNDYgMTcuNzYsMjAuMDUgMTcuMjYsMjAuMjhMMTMuNjQsMjEuOTdaIiAvPjwvc3ZnPg==","name":"MouseHelper","previewIconUrl":"https://asset-resources.gdevelop.io/public-resources/Icons/8f81db7cf269c88bf0b13f816ee501ae786b3f15526d59c9d0005da09c13a18d_cursor-default-outline.svg","shortDescription":"Turn any object into a cursor.","version":"2.0.0","description":["This extension allows to replace the cursor with an object.","","Breaking change of the version 2.0.0:","- The button behavior has been removed. The button object can be used instead. Some ready to use buttons can be downloaded from the [Buttons pack](https://editor.gdevelop.io/?initial-dialog=asset-store&asset-pack=menu-buttons-menu-buttons) of the asset store."],"origin":{"identifier":"MouseHelper","name":"gdevelop-extension-store"},"tags":["mouse","pointer","cursor"],"authorIds":[],"dependencies":[],"globalVariables":[],"sceneVariables":[],"eventsFunctions":[],"eventsBasedBehaviors":[{"description":"Turn any object into a mouse cursor.","fullName":"Cursor","name":"cursor","objectType":"","eventsFunctions":[{"fullName":"","functionType":"Action","name":"onCreated","sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"CacheSouris"},"parameters":[""]}]}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"MouseHelper::cursor","type":"behavior"}],"objectGroups":[]},{"fullName":"","functionType":"Action","name":"doStepPreEvents","sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"MettreXY"},"parameters":["Object","=","CursorX()","=","CursorY()"]}]}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"MouseHelper::cursor","type":"behavior"}],"objectGroups":[]},{"fullName":"","functionType":"Action","name":"onActivate","sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"CacheSouris"},"parameters":[""]},{"type":{"value":"Montre"},"parameters":["Object",""]}]}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"MouseHelper::cursor","type":"behavior"}],"objectGroups":[]},{"fullName":"","functionType":"Action","name":"onDeActivate","sentence":"","events":[{"type":"BuiltinCommonInstructions::Standard","conditions":[],"actions":[{"type":{"value":"MontreSouris"},"parameters":[""]},{"type":{"value":"Cache"},"parameters":["Object"]}]}],"parameters":[{"description":"Object","name":"Object","type":"object"},{"description":"Behavior","name":"Behavior","supplementaryInformation":"MouseHelper::cursor","type":"behavior"}],"objectGroups":[]}],"propertyDescriptors":[],"sharedPropertyDescriptors":[]}],"eventsBasedObjects":[]}],"externalLayouts":[],"externalSourceFiles":[]}